
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/generated/prisma/runtime/edge-esm.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">src/generated/prisma/runtime</a> edge-esm.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/4782</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/3220</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1069</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/18</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">&nbsp;
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
var aa=<span class="cstat-no" title="statement not covered" >Object.create;</span>var tn=<span class="cstat-no" title="statement not covered" >Object.defineProperty;</span>var la=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor;</span>var ua=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames;</span>var ca=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf,</span>pa=<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty;</span>var me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;(t=e(e=0)),t);v</span></span></span>ar Fe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >t</span>||e((t={exports:{}}).exports,t),t.exports</span></span></span>),or=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >for(var r in t)<span class="cstat-no" title="statement not covered" >tn(e,r,{get:t[r],enumerable:!0})}</span></span>,m</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r,n)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&amp;&amp;typeof t=="object"||typeof t=="function")<span class="cstat-no" title="statement not covered" >for(let i of ua(t))<span class="cstat-no" title="statement not covered" >!pa.call(e,i)&amp;&amp;i!==r&amp;&amp;tn(e,i,{get:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>[i],</span>enumerable:!(n=la(t,i))||n.enumerable});<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn e}</span>;v</span>ar Qe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;(<span class="cstat-no" title="statement not covered" >r=e!=null?aa(ca(e)):{},ma(t||!e||!e.__esModule?tn(r,"default",{value:e,enumerable:!0}):r,e)</span>);v</span>ar y,u=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >y={nextTick:<span class="fstat-no" title="function not covered" >(e</span>,...t)=&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >e</span>(...t)}</span>,0)}</span>,env:{},version:"",cwd:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>/",s</span>tderr:{},argv:["/bin/node"]}}</span>);v</span>ar b,c=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >b=globalThis.performance??(<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et e=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" >r</span>eturn{now:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >D</span>ate.now()-e}</span>}</span>)()}</span>);v</span>ar E,p=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >E=<span class="fstat-no" title="function not covered" >()=&gt;{}</span>;<span class="cstat-no" title="statement not covered" >E</span>.prototype=E}</span>);v</span>ar m=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict"});v</span>ar bi=<span class="cstat-no" title="statement not covered" >Fe(<span class="fstat-no" title="function not covered" >Ke=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar si=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >t</span>||e((t={exports:{}}).exports,t),t.exports</span></span></span>),fa=<span class="cstat-no" title="statement not covered" >si(<span class="fstat-no" title="function not covered" >e=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >e.byteLength=l,e.toByteArray=g,e.fromByteArray=S;v</span>ar t=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >typeof Uint8Array&lt;"u"?Uint8Array:Array,i</span>=<span class="cstat-no" title="statement not covered" >"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";<span class="cstat-no" title="statement not covered" >f</span>or(o=0,s=i.length;o&lt;s;++o)<span class="cstat-no" title="statement not covered" >t[o]=i[o],r[i.charCodeAt(o)]=o;v</span></span>ar o,s;<span class="cstat-no" title="statement not covered" >r[45]=62,r[95]=63;f</span>unction <span class="fstat-no" title="function not covered" >a(A</span>){var R=<span class="cstat-no" title="statement not covered" >A.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(R%4&gt;0)<span class="cstat-no" title="statement not covered" >throw new Error("Invalid string. Length must be a multiple of 4");v</span></span>ar D=<span class="cstat-no" title="statement not covered" >A.indexOf("=");<span class="cstat-no" title="statement not covered" >D</span>===-1&amp;&amp;(D=R);v</span>ar M=<span class="cstat-no" title="statement not covered" >D===R?0:4-D%4;<span class="cstat-no" title="statement not covered" >r</span>eturn[D,M]}f</span>unction <span class="fstat-no" title="function not covered" >l(A</span>){var R=<span class="cstat-no" title="statement not covered" >a(A),D</span>=<span class="cstat-no" title="statement not covered" >R[0],</span>M=<span class="cstat-no" title="statement not covered" >R[1];<span class="cstat-no" title="statement not covered" ></span>return(D+M)*3/4-M}</span>function <span class="fstat-no" title="function not covered" >d(A</span>,R,D){<span class="cstat-no" title="statement not covered" >return(R+D)*3/4-D}</span>function <span class="fstat-no" title="function not covered" >g(A</span>){var R,D=<span class="cstat-no" title="statement not covered" >a(A),M</span>=<span class="cstat-no" title="statement not covered" >D[0],</span>B=<span class="cstat-no" title="statement not covered" >D[1],</span>k=<span class="cstat-no" title="statement not covered" >new n(d(A,M,B)),F</span>=<span class="cstat-no" title="statement not covered" >0,i</span>e=<span class="cstat-no" title="statement not covered" >B&gt;0?M-4:M,G</span>;<span class="cstat-no" title="statement not covered" >for(G=0;G&lt;ie;G+=4)<span class="cstat-no" title="statement not covered" >R=r[A.charCodeAt(G)]&lt;&lt;18|r[A.charCodeAt(G+1)]&lt;&lt;12|r[A.charCodeAt(G+2)]&lt;&lt;6|r[A.charCodeAt(G+3)],k[F++]=R&gt;&gt;16&amp;255,k[F++]=R&gt;&gt;8&amp;255,k[F++]=R&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn B===2&amp;&amp;(R=r[A.charCodeAt(G)]&lt;&lt;2|r[A.charCodeAt(G+1)]&gt;&gt;4,k[F++]=R&amp;255),B===1&amp;&amp;(R=r[A.charCodeAt(G)]&lt;&lt;10|r[A.charCodeAt(G+1)]&lt;&lt;4|r[A.charCodeAt(G+2)]&gt;&gt;2,k[F++]=R&gt;&gt;8&amp;255,k[F++]=R&amp;255),k}</span>function <span class="fstat-no" title="function not covered" >h(A</span>){<span class="cstat-no" title="statement not covered" >return t[A&gt;&gt;18&amp;63]+t[A&gt;&gt;12&amp;63]+t[A&gt;&gt;6&amp;63]+t[A&amp;63]}f</span>unction <span class="fstat-no" title="function not covered" >v(A</span>,R,D){<span class="cstat-no" title="statement not covered" >for(var M,B=<span class="cstat-no" title="statement not covered" >[],</span>k=<span class="cstat-no" title="statement not covered" >R;k</span>&lt;D;k+=3)<span class="cstat-no" title="statement not covered" >M=(A[k]&lt;&lt;16&amp;16711680)+(A[k+1]&lt;&lt;8&amp;65280)+(A[k+2]&amp;255),B.push(h(M));<span class="cstat-no" title="statement not covered" >r</span></span>eturn B.join("")}</span>function <span class="fstat-no" title="function not covered" >S(A</span>){<span class="cstat-no" title="statement not covered" >for(var R,D=<span class="cstat-no" title="statement not covered" >A.length,</span>M=<span class="cstat-no" title="statement not covered" >D%3,B</span>=<span class="cstat-no" title="statement not covered" >[],</span>k=<span class="cstat-no" title="statement not covered" >16383,F</span>=<span class="cstat-no" title="statement not covered" >0,i</span>e=<span class="cstat-no" title="statement not covered" >D-M;F</span>&lt;ie;F+=k)<span class="cstat-no" title="statement not covered" >B.push(v(A,F,F+k&gt;ie?ie:F+k));<span class="cstat-no" title="statement not covered" >r</span></span>eturn M===1?(R=A[D-1],B.push(t[R&gt;&gt;2]+t[R&lt;&lt;4&amp;63]+"==")):M===2&amp;&amp;(R=(A[D-2]&lt;&lt;8)+A[D-1],B.push(t[R&gt;&gt;10]+t[R&gt;&gt;4&amp;63]+t[R&lt;&lt;2&amp;63]+"=")),B.join("")}</span>}),d</span>a=<span class="cstat-no" title="statement not covered" >si(<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.read=<span class="fstat-no" title="function not covered" >function(t</span>,r,n,i,o){var s,a,l=<span class="cstat-no" title="statement not covered" >o*8-i-1,d</span>=<span class="cstat-no" title="statement not covered" >(1&lt;&lt;l)-1,g</span>=<span class="cstat-no" title="statement not covered" >d&gt;&gt;1,h</span>=<span class="cstat-no" title="statement not covered" >-7,v</span>=<span class="cstat-no" title="statement not covered" >n?o-1:0,S</span>=<span class="cstat-no" title="statement not covered" >n?-1:1,A</span>=<span class="cstat-no" title="statement not covered" >t[r+v];<span class="cstat-no" title="statement not covered" ></span>for(v+=S,s=A&amp;(1&lt;&lt;-h)-1,A&gt;&gt;=-h,h+=l;h&gt;0;s=s*256+t[r+v],v+=S,h-=8);<span class="cstat-no" title="statement not covered" >f</span>or(a=s&amp;(1&lt;&lt;-h)-1,s&gt;&gt;=-h,h+=i;h&gt;0;a=a*256+t[r+v],v+=S,h-=8);<span class="cstat-no" title="statement not covered" >i</span>f(s===0)<span class="cstat-no" title="statement not covered" >s=1-g;else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(s===d)<span class="cstat-no" title="statement not covered" >return a?NaN:(A?-1:1)*(1/0);<span class="cstat-no" title="statement not covered" >a</span></span>=a+Math.pow(2,i),s=s-g}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn(A?-1:1)*a*Math.pow(2,s-i)}</span>,e.write=<span class="fstat-no" title="function not covered" >function(t</span>,r,n,i,o,s){var a,l,d,g=<span class="cstat-no" title="statement not covered" >s*8-o-1,h</span>=<span class="cstat-no" title="statement not covered" >(1&lt;&lt;g)-1,v</span>=<span class="cstat-no" title="statement not covered" >h&gt;&gt;1,S</span>=<span class="cstat-no" title="statement not covered" >o===23?Math.pow(2,-24)-Math.pow(2,-77):0,A</span>=<span class="cstat-no" title="statement not covered" >i?0:s-1,R</span>=<span class="cstat-no" title="statement not covered" >i?1:-1,D</span>=<span class="cstat-no" title="statement not covered" >r&lt;0||r===0&amp;&amp;1/r&lt;0?1:0;<span class="cstat-no" title="statement not covered" >f</span>or(r=Math.abs(r),isNaN(r)||r===1/0?(l=isNaN(r)?1:0,a=h):(a=Math.floor(Math.log(r)/Math.LN2),r*(d=Math.pow(2,-a))&lt;1&amp;&amp;(a--,d*=2),a+v&gt;=1?r+=S/d:r+=S*Math.pow(2,1-v),r*d&gt;=2&amp;&amp;(a++,d/=2),a+v&gt;=h?(l=0,a=h):a+v&gt;=1?(l=(r*d-1)*Math.pow(2,o),a=a+v):(l=r*Math.pow(2,v-1)*Math.pow(2,o),a=0));o&gt;=8;t[n+A]=l&amp;255,A+=R,l/=256,o-=8);<span class="cstat-no" title="statement not covered" >f</span>or(a=a&lt;&lt;o|l,g+=o;g&gt;0;t[n+A]=a&amp;255,A+=R,a/=256,g-=8);<span class="cstat-no" title="statement not covered" >t</span>[n+A-R]|=D*128}</span>}</span>),r</span>n=<span class="cstat-no" title="statement not covered" >fa(),W</span>e=<span class="cstat-no" title="statement not covered" >da(),r</span>i=<span class="cstat-no" title="statement not covered" >typeof Symbol=="function"&amp;&amp;typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;<span class="cstat-no" title="statement not covered" >K</span>e.Buffer=T;<span class="cstat-no" title="statement not covered" >K</span>e.SlowBuffer=ba;<span class="cstat-no" title="statement not covered" >K</span>e.INSPECT_MAX_BYTES=50;v</span>ar sr=<span class="cstat-no" title="statement not covered" >2147483647;<span class="cstat-no" title="statement not covered" >K</span>e.kMaxLength=sr;<span class="cstat-no" title="statement not covered" >T</span>.TYPED_ARRAY_SUPPORT=ga();<span class="cstat-no" title="statement not covered" >!</span>T.TYPED_ARRAY_SUPPORT&amp;&amp;typeof console&lt;"u"&amp;&amp;typeof console.error=="function"&amp;&amp;console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");f</span>unction <span class="fstat-no" title="function not covered" >ga(){<span class="cstat-no" title="statement not covered" >t</span>ry{let e=<span class="cstat-no" title="statement not covered" >new Uint8Array(1),t</span>=<span class="cstat-no" title="statement not covered" >{foo:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn 42}</span>};<span class="cstat-no" title="statement not covered" >r</span>eturn Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(e,t),e.foo()===42}</span>catch{<span class="cstat-no" title="statement not covered" >return!1}</span>}<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(T.prototype,"parent",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(T.isBuffer(this))<span class="cstat-no" title="statement not covered" >return this.buffer}}</span></span>);<span class="cstat-no" title="statement not covered" >O</span>bject.defineProperty(T.prototype,"offset",{enumerable:!0,get:<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(T.isBuffer(this))<span class="cstat-no" title="statement not covered" >return this.byteOffset}}</span></span>);f</span>unction <span class="fstat-no" title="function not covered" >xe(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e&gt;sr)<span class="cstat-no" title="statement not covered" >throw new RangeError('The value "'+e+'" is invalid for option "size"');l</span></span>et t=<span class="cstat-no" title="statement not covered" >new Uint8Array(e);<span class="cstat-no" title="statement not covered" >r</span>eturn Object.setPrototypeOf(t,T.prototype),t}</span>function <span class="fstat-no" title="function not covered" >T(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="number"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t=="string")<span class="cstat-no" title="statement not covered" >throw new TypeError('The "string" argument must be of type string. Received type number');<span class="cstat-no" title="statement not covered" >r</span></span>eturn sn(e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn ai(e,t,r)}<span class="cstat-no" title="statement not covered" ></span>T.poolSize=8192;f</span>unction <span class="fstat-no" title="function not covered" >ai(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="string")<span class="cstat-no" title="statement not covered" >return ya(e,t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(e))<span class="cstat-no" title="statement not covered" >return wa(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e==null)<span class="cstat-no" title="statement not covered" >throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(fe(e,ArrayBuffer)||e&amp;&amp;fe(e.buffer,ArrayBuffer)||typeof SharedArrayBuffer&lt;"u"&amp;&amp;(fe(e,SharedArrayBuffer)||e&amp;&amp;fe(e.buffer,SharedArrayBuffer)))<span class="cstat-no" title="statement not covered" >return ui(e,t,r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="number")<span class="cstat-no" title="statement not covered" >throw new TypeError('The "value" argument must not be of type number. Received type number');l</span></span>et n=<span class="cstat-no" title="statement not covered" >e.valueOf&amp;&amp;e.valueOf();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n!=null&amp;&amp;n!==e)<span class="cstat-no" title="statement not covered" >return T.from(n,t,r);l</span></span>et i=<span class="cstat-no" title="statement not covered" >Ea(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i)<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof Symbol&lt;"u"&amp;&amp;Symbol.toPrimitive!=null&amp;&amp;typeof e[Symbol.toPrimitive]=="function")<span class="cstat-no" title="statement not covered" >return T.from(e[Symbol.toPrimitive]("string"),t,r);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof e)}<span class="cstat-no" title="statement not covered" ></span>T.from=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return ai(e,t,r)}</span>;<span class="cstat-no" title="statement not covered" >O</span>bject.setPrototypeOf(T.prototype,Uint8Array.prototype);<span class="cstat-no" title="statement not covered" >O</span>bject.setPrototypeOf(T,Uint8Array);f</span>unction <span class="fstat-no" title="function not covered" >li(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError('"size" argument must be of type number');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError('The value "'+e+'" is invalid for option "size"')}</span></span>function <span class="fstat-no" title="function not covered" >ha(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return li(e),e&lt;=0?xe(e):t!==void 0?typeof r=="string"?xe(e).fill(t,r):xe(e).fill(t):xe(e)}<span class="cstat-no" title="statement not covered" ></span>T.alloc=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return ha(e,t,r)}</span>;f</span>unction <span class="fstat-no" title="function not covered" >sn(e</span>){<span class="cstat-no" title="statement not covered" >return li(e),xe(e&lt;0?0:an(e)|0)}<span class="cstat-no" title="statement not covered" ></span>T.allocUnsafe=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return sn(e)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.allocUnsafeSlow=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return sn(e)}</span>;f</span>unction <span class="fstat-no" title="function not covered" >ya(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((typeof t!="string"||t==="")&amp;&amp;(t="utf8"),!T.isEncoding(t))<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+t);l</span></span>et r=<span class="cstat-no" title="statement not covered" >ci(e,t)|0,n</span>=<span class="cstat-no" title="statement not covered" >xe(r),i</span>=<span class="cstat-no" title="statement not covered" >n.write(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn i!==r&amp;&amp;(n=n.slice(0,i)),n}</span>function <span class="fstat-no" title="function not covered" >nn(e</span>){let t=<span class="cstat-no" title="statement not covered" >e.length&lt;0?0:an(e.length)|0,r</span>=<span class="cstat-no" title="statement not covered" >xe(t);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;n</span>&lt;t;n+=1)<span class="cstat-no" title="statement not covered" >r[n]=e[n]&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >wa(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(fe(e,Uint8Array)){let t=<span class="cstat-no" title="statement not covered" >new Uint8Array(e);<span class="cstat-no" title="statement not covered" >r</span>eturn ui(t.buffer,t.byteOffset,t.byteLength)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn nn(e)}</span>function <span class="fstat-no" title="function not covered" >ui(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&lt;0||e.byteLength&lt;t)<span class="cstat-no" title="statement not covered" >throw new RangeError('"offset" is outside of buffer bounds');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.byteLength&lt;t+(r||0))<span class="cstat-no" title="statement not covered" >throw new RangeError('"length" is outside of buffer bounds');l</span></span>et n;<span class="cstat-no" title="statement not covered" >return t===void 0&amp;&amp;r===void 0?n=new Uint8Array(e):r===void 0?n=new Uint8Array(e,t):n=new Uint8Array(e,t,r),Object.setPrototypeOf(n,T.prototype),n}</span>function <span class="fstat-no" title="function not covered" >Ea(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(T.isBuffer(e)){let t=<span class="cstat-no" title="statement not covered" >an(e.length)|0,r</span>=<span class="cstat-no" title="statement not covered" >xe(t);<span class="cstat-no" title="statement not covered" >r</span>eturn r.length===0||e.copy(r,0,0,t),r}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(e.length!==void 0)<span class="cstat-no" title="statement not covered" >return typeof e.length!="number"||un(e.length)?xe(0):nn(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.type==="Buffer"&amp;&amp;Array.isArray(e.data))<span class="cstat-no" title="statement not covered" >return nn(e.data)}</span></span>function <span class="fstat-no" title="function not covered" >an(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e&gt;=sr)<span class="cstat-no" title="statement not covered" >throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+sr.toString(16)+" bytes");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e|0}</span>function <span class="fstat-no" title="function not covered" >ba(e</span>){<span class="cstat-no" title="statement not covered" >return+e!=e&amp;&amp;(e=0),T.alloc(+e)}<span class="cstat-no" title="statement not covered" ></span>T.isBuffer=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return e!=null&amp;&amp;e._isBuffer===!0&amp;&amp;e!==T.prototype};<span class="cstat-no" title="statement not covered" >T</span></span>.compare=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(fe(e,Uint8Array)&amp;&amp;(e=T.from(e,e.offset,e.byteLength)),fe(t,Uint8Array)&amp;&amp;(t=T.from(t,t.offset,t.byteLength)),!T.isBuffer(e)||!T.isBuffer(t))<span class="cstat-no" title="statement not covered" >throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e===t)<span class="cstat-no" title="statement not covered" >return 0;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.length,</span>n=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,o</span>=<span class="cstat-no" title="statement not covered" >Math.min(r,n);i</span>&lt;o;++i)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e[i]!==t[i]){<span class="cstat-no" title="statement not covered" >r=e[i],n=t[i];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn r&lt;n?-1:n&lt;r?1:0}</span>;<span class="cstat-no" title="statement not covered" >T</span>.isEncoding=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return!0;d</span>efault:<span class="cstat-no" title="statement not covered" >return!1}</span>}</span>;<span class="cstat-no" title="statement not covered" >T</span>.concat=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new TypeError('"list" argument must be an Array of Buffers');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.length===0)<span class="cstat-no" title="statement not covered" >return T.alloc(0);l</span></span>et r;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t===void 0)<span class="cstat-no" title="statement not covered" >for(t=0,r=0;r&lt;e.length;++r)<span class="cstat-no" title="statement not covered" >t+=e[r].length;l</span></span></span>et n=<span class="cstat-no" title="statement not covered" >T.allocUnsafe(t),i</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(r=0;r&lt;e.length;++r){let o=<span class="cstat-no" title="statement not covered" >e[r];<span class="cstat-no" title="statement not covered" ></span>if(fe(o,Uint8Array))<span class="cstat-no" title="statement not covered" >i+o.length&gt;n.length?(T.isBuffer(o)||(o=T.from(o)),o.copy(n,i)):Uint8Array.prototype.set.call(n,o,i);else <span class="cstat-no" title="statement not covered" >i</span>f(T.isBuffer(o))<span class="cstat-no" title="statement not covered" >o.copy(n,i);else <span class="cstat-no" title="statement not covered" >t</span>hrow new TypeError('"list" argument must be an Array of Buffers');<span class="cstat-no" title="statement not covered" >i</span></span></span>+=o.length}<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>;f</span>unction <span class="fstat-no" title="function not covered" >ci(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(T.isBuffer(e))<span class="cstat-no" title="statement not covered" >return e.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(e)||fe(e,ArrayBuffer))<span class="cstat-no" title="statement not covered" >return e.byteLength;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof e);l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.length,</span>n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;arguments[2]===!0;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!n&amp;&amp;r===0)<span class="cstat-no" title="statement not covered" >return 0;l</span></span>et i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" >f</span>or(;;)<span class="cstat-no" title="statement not covered" >switch(t){case"ascii":case"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return r;c</span>ase"utf8":case"utf-8":<span class="cstat-no" title="statement not covered" >return on(e).length;c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return r*2;c</span>ase"hex":<span class="cstat-no" title="statement not covered" >return r&gt;&gt;&gt;1;c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return Ei(e).length;d</span>efault:<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i)<span class="cstat-no" title="statement not covered" >return n?-1:on(e).length;<span class="cstat-no" title="statement not covered" >t</span></span>=(""+t).toLowerCase(),i=!0}</span>}<span class="cstat-no" title="statement not covered" ></span></span>T.byteLength=ci;f</span>unction <span class="fstat-no" title="function not covered" >xa(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f((t===void 0||t&lt;0)&amp;&amp;(t=0),t&gt;this.length||((r===void 0||r&gt;this.length)&amp;&amp;(r=this.length),r&lt;=0)||(r&gt;&gt;&gt;=0,t&gt;&gt;&gt;=0,r&lt;=t))<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >f</span></span>or(e||(e="utf8");;)<span class="cstat-no" title="statement not covered" >switch(e){case"hex":<span class="cstat-no" title="statement not covered" >return Oa(this,t,r);c</span>ase"utf8":case"utf-8":<span class="cstat-no" title="statement not covered" >return mi(this,t,r);c</span>ase"ascii":<span class="cstat-no" title="statement not covered" >return ka(this,t,r);c</span>ase"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return Ia(this,t,r);c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return Ra(this,t,r);c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return Da(this,t,r);d</span>efault:<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n)<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+e);<span class="cstat-no" title="statement not covered" >e</span></span>=(e+"").toLowerCase(),n=!0}</span>}<span class="cstat-no" title="statement not covered" ></span></span>T.prototype._isBuffer=!0;f</span>unction <span class="fstat-no" title="function not covered" >Le(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>e[t]=e[r],e[r]=n}<span class="cstat-no" title="statement not covered" ></span>T.prototype.swap16=<span class="fstat-no" title="function not covered" >function(){l</span>et e=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e%2!==0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 16-bits");<span class="cstat-no" title="statement not covered" >f</span></span>or(let t=<span class="cstat-no" title="statement not covered" >0;t</span>&lt;e;t+=2)<span class="cstat-no" title="statement not covered" >Le(this,t,t+1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this};<span class="cstat-no" title="statement not covered" >T</span></span>.prototype.swap32=<span class="fstat-no" title="function not covered" >function(){l</span>et e=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e%4!==0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 32-bits");<span class="cstat-no" title="statement not covered" >f</span></span>or(let t=<span class="cstat-no" title="statement not covered" >0;t</span>&lt;e;t+=4)<span class="cstat-no" title="statement not covered" >Le(this,t,t+3),Le(this,t+1,t+2);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this};<span class="cstat-no" title="statement not covered" >T</span></span>.prototype.swap64=<span class="fstat-no" title="function not covered" >function(){l</span>et e=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e%8!==0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Buffer size must be a multiple of 64-bits");<span class="cstat-no" title="statement not covered" >f</span></span>or(let t=<span class="cstat-no" title="statement not covered" >0;t</span>&lt;e;t+=8)<span class="cstat-no" title="statement not covered" >Le(this,t,t+7),Le(this,t+1,t+6),Le(this,t+2,t+5),Le(this,t+3,t+4);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this};<span class="cstat-no" title="statement not covered" >T</span></span>.prototype.toString=<span class="fstat-no" title="function not covered" >function(){l</span>et e=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ></span>return e===0?"":arguments.length===0?mi(this,0,e):xa.apply(this,arguments)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.toLocaleString=T.prototype.toString;<span class="cstat-no" title="statement not covered" >T</span>.prototype.equals=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!T.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("Argument must be a Buffer");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this===e?!0:T.compare(this,e)===0}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.inspect=<span class="fstat-no" title="function not covered" >function(){l</span>et e=<span class="cstat-no" title="statement not covered" >"",t</span>=<span class="cstat-no" title="statement not covered" >Ke.INSPECT_MAX_BYTES;<span class="cstat-no" title="statement not covered" ></span>return e=this.toString("hex",0,t).replace(/(.{2})/g,"$1 ").trim(),this.length&gt;t&amp;&amp;(e+=" ... "),"&lt;Buffer "+e+"&gt;"}</span>;<span class="cstat-no" title="statement not covered" >r</span>i&amp;&amp;(T.prototype[ri]=T.prototype.inspect</span>);<span class="cstat-no" title="statement not covered" >T.prototype.compare=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n,i){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(fe(e,Uint8Array)&amp;&amp;(e=T.from(e,e.offset,e.byteLength)),!T.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t===void 0&amp;&amp;(t=0),r===void 0&amp;&amp;(r=e?e.length:0),n===void 0&amp;&amp;(n=0),i===void 0&amp;&amp;(i=this.length),t&lt;0||r&gt;e.length||n&lt;0||i&gt;this.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("out of range index");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n&gt;=i&amp;&amp;t&gt;=r)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n&gt;=i)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t&gt;=r)<span class="cstat-no" title="statement not covered" >return 1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t&gt;&gt;&gt;=0,r&gt;&gt;&gt;=0,n&gt;&gt;&gt;=0,i&gt;&gt;&gt;=0,this===e)<span class="cstat-no" title="statement not covered" >return 0;l</span></span>et o=<span class="cstat-no" title="statement not covered" >i-n,s</span>=<span class="cstat-no" title="statement not covered" >r-t,a</span>=<span class="cstat-no" title="statement not covered" >Math.min(o,s),l</span>=<span class="cstat-no" title="statement not covered" >this.slice(n,i),d</span>=<span class="cstat-no" title="statement not covered" >e.slice(t,r);<span class="cstat-no" title="statement not covered" >f</span>or(let g=<span class="cstat-no" title="statement not covered" >0;g</span>&lt;a;++g)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(l[g]!==d[g]){<span class="cstat-no" title="statement not covered" >o=l[g],s=d[g];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn o&lt;s?-1:s&lt;o?1:0}</span>;f</span>unction <span class="fstat-no" title="function not covered" >pi(e</span>,t,r,n,i){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===0)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >i</span></span>f(typeof r=="string"?(n=r,r=0):r&gt;2147483647?r=2147483647:r&lt;-2147483648&amp;&amp;(r=-2147483648),r=+r,un(r)&amp;&amp;(r=i?0:e.length-1),r&lt;0&amp;&amp;(r=e.length+r),r&gt;=e.length){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >r</span></span>=e.length-1}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r&lt;0)<span class="cstat-no" title="statement not covered" >if(i)<span class="cstat-no" title="statement not covered" >r=0;else <span class="cstat-no" title="statement not covered" >r</span>eturn-1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span></span>f(typeof t=="string"&amp;&amp;(t=T.from(t,n)),T.isBuffer(t))<span class="cstat-no" title="statement not covered" >return t.length===0?-1:ni(e,t,r,n,i);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t=="number")<span class="cstat-no" title="statement not covered" >return t=t&amp;255,typeof Uint8Array.prototype.indexOf=="function"?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):ni(e,[t],r,n,i);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("val must be string, number or Buffer")}</span>function <span class="fstat-no" title="function not covered" >ni(e</span>,t,r,n,i){let o=<span class="cstat-no" title="statement not covered" >1,s</span>=<span class="cstat-no" title="statement not covered" >e.length,</span>a=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(n!==void 0&amp;&amp;(n=String(n).toLowerCase(),n==="ucs2"||n==="ucs-2"||n==="utf16le"||n==="utf-16le")){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length&lt;2||t.length&lt;2)<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" >o</span></span>=2,s/=2,a/=2,r/=2}</span>f</span>unction <span class="fstat-no" title="function not covered" >l(g</span>,h){<span class="cstat-no" title="statement not covered" >return o===1?g[h]:g.readUInt16BE(h*o)}</span>let d;<span class="cstat-no" title="statement not covered" >if(i){let g=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" >f</span>or(d=r;d&lt;s;d++)<span class="cstat-no" title="statement not covered" >if(l(e,d)===l(t,g===-1?0:d-g)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(g===-1&amp;&amp;(g=d),d-g+1===a)<span class="cstat-no" title="statement not covered" >return g*o}</span></span>else <span class="cstat-no" title="statement not covered" >g!==-1&amp;&amp;(d-=d-g),g=-1}</span></span></span>else <span class="cstat-no" title="statement not covered" >for(r+a&gt;s&amp;&amp;(r=s-a),d=r;d&gt;=0;d--){let g=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" >f</span>or(let h=<span class="cstat-no" title="statement not covered" >0;h</span>&lt;a;h++)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(l(e,d+h)!==l(t,h)){<span class="cstat-no" title="statement not covered" >g=!1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span></span>f(g)<span class="cstat-no" title="statement not covered" >return d}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn-1}<span class="cstat-no" title="statement not covered" ></span>T.prototype.includes=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return this.indexOf(e,t,r)!==-1}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.indexOf=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return pi(this,e,t,r,!0)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.lastIndexOf=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return pi(this,e,t,r,!1)}</span>;f</span>unction <span class="fstat-no" title="function not covered" >Pa(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >r=Number(r)||0;l</span>et i=<span class="cstat-no" title="statement not covered" >e.length-r;<span class="cstat-no" title="statement not covered" >n</span>?(n=Number(n),n&gt;i&amp;&amp;(n=i)):n=i;l</span>et o=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>n&gt;o/2&amp;&amp;(n=o/2);l</span>et s;<span class="cstat-no" title="statement not covered" >for(s=0;s&lt;n;++s){let a=<span class="cstat-no" title="statement not covered" >parseInt(t.substr(s*2,2),16);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(un(a))<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >e</span></span>[r+s]=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>function <span class="fstat-no" title="function not covered" >va(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >return ar(on(t,e.length-r),e,r,n)}</span>function <span class="fstat-no" title="function not covered" >Ta(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >return ar(Fa(t),e,r,n)}</span>function <span class="fstat-no" title="function not covered" >Ca(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >return ar(Ei(t),e,r,n)}</span>function <span class="fstat-no" title="function not covered" >Aa(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >return ar(La(t,e.length-r),e,r,n)}<span class="cstat-no" title="statement not covered" ></span>T.prototype.write=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >if(t===void 0)<span class="cstat-no" title="statement not covered" >n="utf8",r=this.length,t=0;else <span class="cstat-no" title="statement not covered" >i</span>f(r===void 0&amp;&amp;typeof t=="string")<span class="cstat-no" title="statement not covered" >n=t,r=this.length,t=0;else <span class="cstat-no" title="statement not covered" >i</span>f(isFinite(t))<span class="cstat-no" title="statement not covered" >t=t&gt;&gt;&gt;0,isFinite(r)?(r=r&gt;&gt;&gt;0,n===void 0&amp;&amp;(n="utf8")):(n=r,r=void 0);else <span class="cstat-no" title="statement not covered" >t</span>hrow new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");l</span></span></span></span>et i=<span class="cstat-no" title="statement not covered" >this.length-t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f((r===void 0||r&gt;i)&amp;&amp;(r=i),e.length&gt;0&amp;&amp;(r&lt;0||t&lt;0)||t&gt;this.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Attempt to write outside buffer bounds");<span class="cstat-no" title="statement not covered" >n</span></span>||(n="utf8");l</span>et o=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" >f</span>or(;;)<span class="cstat-no" title="statement not covered" >switch(n){case"hex":<span class="cstat-no" title="statement not covered" >return Pa(this,e,t,r);c</span>ase"utf8":case"utf-8":<span class="cstat-no" title="statement not covered" >return va(this,e,t,r);c</span>ase"ascii":case"latin1":case"binary":<span class="cstat-no" title="statement not covered" >return Ta(this,e,t,r);c</span>ase"base64":<span class="cstat-no" title="statement not covered" >return Ca(this,e,t,r);c</span>ase"ucs2":case"ucs-2":case"utf16le":case"utf-16le":<span class="cstat-no" title="statement not covered" >return Aa(this,e,t,r);d</span>efault:<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o)<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+n);<span class="cstat-no" title="statement not covered" >n</span></span>=(""+n).toLowerCase(),o=!0}</span>}</span></span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.toJSON=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}}</span>;f</span>unction <span class="fstat-no" title="function not covered" >Ra(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return t===0&amp;&amp;r===e.length?rn.fromByteArray(e):rn.fromByteArray(e.slice(t,r))}</span>function <span class="fstat-no" title="function not covered" >mi(e</span>,t,r){<span class="cstat-no" title="statement not covered" >r=Math.min(e.length,r);l</span>et n=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >f</span>or(;i&lt;r;){let o=<span class="cstat-no" title="statement not covered" >e[i],</span>s=<span class="cstat-no" title="statement not covered" >null,a</span>=<span class="cstat-no" title="statement not covered" >o&gt;239?4:o&gt;223?3:o&gt;191?2:1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i+a&lt;=r){let l,d,g,h;<span class="cstat-no" title="statement not covered" >switch(a){case 1:<span class="cstat-no" title="statement not covered" >o&lt;128&amp;&amp;(s=o);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >l=e[i+1],(l&amp;192)===128&amp;&amp;(h=(o&amp;31)&lt;&lt;6|l&amp;63,h&gt;127&amp;&amp;(s=h));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >l=e[i+1],d=e[i+2],(l&amp;192)===128&amp;&amp;(d&amp;192)===128&amp;&amp;(h=(o&amp;15)&lt;&lt;12|(l&amp;63)&lt;&lt;6|d&amp;63,h&gt;2047&amp;&amp;(h&lt;55296||h&gt;57343)&amp;&amp;(s=h));<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >l=e[i+1],d=e[i+2],g=e[i+3],(l&amp;192)===128&amp;&amp;(d&amp;192)===128&amp;&amp;(g&amp;192)===128&amp;&amp;(h=(o&amp;15)&lt;&lt;18|(l&amp;63)&lt;&lt;12|(d&amp;63)&lt;&lt;6|g&amp;63,h&gt;65535&amp;&amp;h&lt;1114112&amp;&amp;(s=h))}</span>}<span class="cstat-no" title="statement not covered" ></span>s</span>===null?(s=65533,a=1):s&gt;65535&amp;&amp;(s-=65536,n.push(s&gt;&gt;&gt;10&amp;1023|55296),s=56320|s&amp;1023),n.push(s),i+=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Sa(n)}</span>var ii=<span class="cstat-no" title="statement not covered" >4096;f</span>unction <span class="fstat-no" title="function not covered" >Sa(e</span>){let t=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(t&lt;=ii)<span class="cstat-no" title="statement not covered" >return String.fromCharCode.apply(String,e);l</span></span>et r=<span class="cstat-no" title="statement not covered" >"",n</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;n&lt;t;)<span class="cstat-no" title="statement not covered" >r+=String.fromCharCode.apply(String,e.slice(n,n+=ii));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >ka(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" >r</span>=Math.min(e.length,r);<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >t;i</span>&lt;r;++i)<span class="cstat-no" title="statement not covered" >n+=String.fromCharCode(e[i]&amp;127);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >Ia(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" >r</span>=Math.min(e.length,r);<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >t;i</span>&lt;r;++i)<span class="cstat-no" title="statement not covered" >n+=String.fromCharCode(e[i]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >Oa(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >e.length;</span>(<span class="cstat-no" title="statement not covered" >!t||t&lt;0)&amp;&amp;(t=0),(!r||r&lt;0||r&gt;n)&amp;&amp;(r=n);l</span>et i=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >t;o</span>&lt;r;++o)<span class="cstat-no" title="statement not covered" >i+=Ba[e[o]];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Da(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >e.slice(t,r),i</span>=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;n.length-1;o+=2)<span class="cstat-no" title="statement not covered" >i+=String.fromCharCode(n[o]+n[o+1]*256);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>T.prototype.slice=<span class="fstat-no" title="function not covered" >function(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >this.length;<span class="cstat-no" title="statement not covered" ></span>e=~~e,t=t===void 0?r:~~t,e&lt;0?(e+=r,e&lt;0&amp;&amp;(e=0)):e&gt;r&amp;&amp;(e=r),t&lt;0?(t+=r,t&lt;0&amp;&amp;(t=0)):t&gt;r&amp;&amp;(t=r),t&lt;e&amp;&amp;(t=e);l</span>et n=<span class="cstat-no" title="statement not covered" >this.subarray(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn Object.setPrototypeOf(n,T.prototype),n}</span>;f</span>unction <span class="fstat-no" title="function not covered" >W(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e%1!==0||e&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("offset is not uint");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e+t&gt;r)<span class="cstat-no" title="statement not covered" >throw new RangeError("Trying to access beyond buffer length")}<span class="cstat-no" title="statement not covered" ></span></span>T.prototype.readUintLE=T.prototype.readUIntLE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,t=t&gt;&gt;&gt;0,r||W(e,t,this.length);l</span>et n=<span class="cstat-no" title="statement not covered" >this[e],</span>i=<span class="cstat-no" title="statement not covered" >1,o</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;++o&lt;t&amp;&amp;(i*=256);)<span class="cstat-no" title="statement not covered" >n+=this[e+o]*i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readUintBE=T.prototype.readUIntBE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,t=t&gt;&gt;&gt;0,r||W(e,t,this.length);l</span>et n=<span class="cstat-no" title="statement not covered" >this[e+--t],</span>i=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" >f</span>or(;t&gt;0&amp;&amp;(i*=256);)<span class="cstat-no" title="statement not covered" >n+=this[e+--t]*i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readUint8=T.prototype.readUInt8=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,1,this.length),this[e]};<span class="cstat-no" title="statement not covered" >T</span></span>.prototype.readUint16LE=T.prototype.readUInt16LE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,2,this.length),this[e]|this[e+1]&lt;&lt;8}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readUint16BE=T.prototype.readUInt16BE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,2,this.length),this[e]&lt;&lt;8|this[e+1]};<span class="cstat-no" title="statement not covered" >T</span></span>.prototype.readUint32LE=T.prototype.readUInt32LE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,4,this.length),(this[e]|this[e+1]&lt;&lt;8|this[e+2]&lt;&lt;16)+this[e+3]*16777216}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readUint32BE=T.prototype.readUInt32BE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,4,this.length),this[e]*16777216+(this[e+1]&lt;&lt;16|this[e+2]&lt;&lt;8|this[e+3]</span>)};<span class="cstat-no" title="statement not covered" >T</span>.prototype.readBigUInt64LE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,He(e,"offset");l</span>et t=<span class="cstat-no" title="statement not covered" >this[e],</span>r=<span class="cstat-no" title="statement not covered" >this[e+7];</span>(<span class="cstat-no" title="statement not covered" >t===void 0||r===void 0)&amp;&amp;bt(e,this.length-8);l</span>et n=<span class="cstat-no" title="statement not covered" >t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24,i</span>=<span class="cstat-no" title="statement not covered" >this[++e]+this[++e]*2**8+this[++e]*2**16+r*2**24;<span class="cstat-no" title="statement not covered" >r</span>eturn BigInt(n)+(BigInt(i)&lt;&lt;BigInt(32))}</span>);<span class="cstat-no" title="statement not covered" >T</span>.prototype.readBigUInt64BE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,He(e,"offset");l</span>et t=<span class="cstat-no" title="statement not covered" >this[e],</span>r=<span class="cstat-no" title="statement not covered" >this[e+7];</span>(<span class="cstat-no" title="statement not covered" >t===void 0||r===void 0)&amp;&amp;bt(e,this.length-8);l</span>et n=<span class="cstat-no" title="statement not covered" >t*2**24+this[++e]*2**16+this[++e]*2**8+this[++e],</span>i=<span class="cstat-no" title="statement not covered" >this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r;<span class="cstat-no" title="statement not covered" >r</span>eturn(BigInt(n)&lt;&lt;BigInt(32))+BigInt(i)}</span>);<span class="cstat-no" title="statement not covered" >T</span>.prototype.readIntLE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,t=t&gt;&gt;&gt;0,r||W(e,t,this.length);l</span>et n=<span class="cstat-no" title="statement not covered" >this[e],</span>i=<span class="cstat-no" title="statement not covered" >1,o</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;++o&lt;t&amp;&amp;(i*=256);)<span class="cstat-no" title="statement not covered" >n+=this[e+o]*i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i*=128,n&gt;=i&amp;&amp;(n-=Math.pow(2,8*t)),n}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readIntBE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,t=t&gt;&gt;&gt;0,r||W(e,t,this.length);l</span>et n=<span class="cstat-no" title="statement not covered" >t,i</span>=<span class="cstat-no" title="statement not covered" >1,o</span>=<span class="cstat-no" title="statement not covered" >this[e+--n];<span class="cstat-no" title="statement not covered" ></span>for(;n&gt;0&amp;&amp;(i*=256);)<span class="cstat-no" title="statement not covered" >o+=this[e+--n]*i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i*=128,o&gt;=i&amp;&amp;(o-=Math.pow(2,8*t)),o}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readInt8=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,1,this.length),this[e]&amp;128?(255-this[e]+1)*-1:this[e]};<span class="cstat-no" title="statement not covered" >T</span></span>.prototype.readInt16LE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,t||W(e,2,this.length);l</span>et r=<span class="cstat-no" title="statement not covered" >this[e]|this[e+1]&lt;&lt;8;<span class="cstat-no" title="statement not covered" >r</span>eturn r&amp;32768?r|4294901760:r}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readInt16BE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,t||W(e,2,this.length);l</span>et r=<span class="cstat-no" title="statement not covered" >this[e+1]|this[e]&lt;&lt;8;<span class="cstat-no" title="statement not covered" >r</span>eturn r&amp;32768?r|4294901760:r}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readInt32LE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,4,this.length),this[e]|this[e+1]&lt;&lt;8|this[e+2]&lt;&lt;16|this[e+3]&lt;&lt;24}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readInt32BE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,4,this.length),this[e]&lt;&lt;24|this[e+1]&lt;&lt;16|this[e+2]&lt;&lt;8|this[e+3]};<span class="cstat-no" title="statement not covered" >T</span></span>.prototype.readBigInt64LE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,He(e,"offset");l</span>et t=<span class="cstat-no" title="statement not covered" >this[e],</span>r=<span class="cstat-no" title="statement not covered" >this[e+7];</span>(<span class="cstat-no" title="statement not covered" >t===void 0||r===void 0)&amp;&amp;bt(e,this.length-8);l</span>et n=<span class="cstat-no" title="statement not covered" >this[e+4]+this[e+5]*2**8+this[e+6]*2**16+(r&lt;&lt;24);<span class="cstat-no" title="statement not covered" >r</span>eturn(BigInt(n)&lt;&lt;BigInt(32))+BigInt(t+this[++e]*2**8+this[++e]*2**16+this[++e]*2**24)}</span>);<span class="cstat-no" title="statement not covered" >T</span>.prototype.readBigInt64BE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >e=e&gt;&gt;&gt;0,He(e,"offset");l</span>et t=<span class="cstat-no" title="statement not covered" >this[e],</span>r=<span class="cstat-no" title="statement not covered" >this[e+7];</span>(<span class="cstat-no" title="statement not covered" >t===void 0||r===void 0)&amp;&amp;bt(e,this.length-8);l</span>et n=<span class="cstat-no" title="statement not covered" >(t&lt;&lt;24)+this[++e]*2**16+this[++e]*2**8+this[++e];<span class="cstat-no" title="statement not covered" ></span>return(BigInt(n)&lt;&lt;BigInt(32))+BigInt(this[++e]*2**24+this[++e]*2**16+this[++e]*2**8+r)}</span>);<span class="cstat-no" title="statement not covered" >T</span>.prototype.readFloatLE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,4,this.length),We.read(this,e,!0,23,4)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readFloatBE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,4,this.length),We.read(this,e,!1,23,4)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readDoubleLE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,8,this.length),We.read(this,e,!0,52,8)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.readDoubleBE=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return e=e&gt;&gt;&gt;0,t||W(e,8,this.length),We.read(this,e,!1,52,8)}</span>;f</span>unction <span class="fstat-no" title="function not covered" >te(e</span>,t,r,n,i,o){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!T.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new TypeError('"buffer" argument must be a Buffer instance');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t&gt;i||t&lt;o)<span class="cstat-no" title="statement not covered" >throw new RangeError('"value" argument is out of bounds');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r+n&gt;e.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range")}<span class="cstat-no" title="statement not covered" ></span></span>T.prototype.writeUintLE=T.prototype.writeUIntLE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e=+e,t=t&gt;&gt;&gt;0,r=r&gt;&gt;&gt;0,!n){let s=<span class="cstat-no" title="statement not covered" >Math.pow(2,8*r)-1;<span class="cstat-no" title="statement not covered" >t</span>e(this,e,t,r,s,0)}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >1,o</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(this[t]=e&amp;255;++o&lt;r&amp;&amp;(i*=256);)<span class="cstat-no" title="statement not covered" >this[t+o]=e/i&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t+r}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeUintBE=T.prototype.writeUIntBE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e=+e,t=t&gt;&gt;&gt;0,r=r&gt;&gt;&gt;0,!n){let s=<span class="cstat-no" title="statement not covered" >Math.pow(2,8*r)-1;<span class="cstat-no" title="statement not covered" >t</span>e(this,e,t,r,s,0)}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >r-1,o</span>=<span class="cstat-no" title="statement not covered" >1;<span class="cstat-no" title="statement not covered" >f</span>or(this[t+i]=e&amp;255;--i&gt;=0&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >this[t+i]=e/o&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t+r}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeUint8=T.prototype.writeUInt8=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,1,255,0),this[t]=e&amp;255,t+1}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeUint16LE=T.prototype.writeUInt16LE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,2,65535,0),this[t]=e&amp;255,this[t+1]=e&gt;&gt;&gt;8,t+2}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeUint16BE=T.prototype.writeUInt16BE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,2,65535,0),this[t]=e&gt;&gt;&gt;8,this[t+1]=e&amp;255,t+2}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeUint32LE=T.prototype.writeUInt32LE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,4,4294967295,0),this[t+3]=e&gt;&gt;&gt;24,this[t+2]=e&gt;&gt;&gt;16,this[t+1]=e&gt;&gt;&gt;8,this[t]=e&amp;255,t+4}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeUint32BE=T.prototype.writeUInt32BE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,4,4294967295,0),this[t]=e&gt;&gt;&gt;24,this[t+1]=e&gt;&gt;&gt;16,this[t+2]=e&gt;&gt;&gt;8,this[t+3]=e&amp;255,t+4}</span>;f</span>unction <span class="fstat-no" title="function not covered" >fi(e</span>,t,r,n,i){<span class="cstat-no" title="statement not covered" >wi(t,n,i,e,r,7);l</span>et o=<span class="cstat-no" title="statement not covered" >Number(t&amp;BigInt(4294967295));<span class="cstat-no" title="statement not covered" >e</span>[r++]=o,o=o&gt;&gt;8,e[r++]=o,o=o&gt;&gt;8,e[r++]=o,o=o&gt;&gt;8,e[r++]=o;l</span>et s=<span class="cstat-no" title="statement not covered" >Number(t&gt;&gt;BigInt(32)&amp;BigInt(4294967295));<span class="cstat-no" title="statement not covered" >r</span>eturn e[r++]=s,s=s&gt;&gt;8,e[r++]=s,s=s&gt;&gt;8,e[r++]=s,s=s&gt;&gt;8,e[r++]=s,r}</span>function <span class="fstat-no" title="function not covered" >di(e</span>,t,r,n,i){<span class="cstat-no" title="statement not covered" >wi(t,n,i,e,r,7);l</span>et o=<span class="cstat-no" title="statement not covered" >Number(t&amp;BigInt(4294967295));<span class="cstat-no" title="statement not covered" >e</span>[r+7]=o,o=o&gt;&gt;8,e[r+6]=o,o=o&gt;&gt;8,e[r+5]=o,o=o&gt;&gt;8,e[r+4]=o;l</span>et s=<span class="cstat-no" title="statement not covered" >Number(t&gt;&gt;BigInt(32)&amp;BigInt(4294967295));<span class="cstat-no" title="statement not covered" >r</span>eturn e[r+3]=s,s=s&gt;&gt;8,e[r+2]=s,s=s&gt;&gt;8,e[r+1]=s,s=s&gt;&gt;8,e[r]=s,r+8}<span class="cstat-no" title="statement not covered" ></span>T.prototype.writeBigUInt64LE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return fi(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}</span>);<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeBigUInt64BE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return di(this,e,t,BigInt(0),BigInt("0xffffffffffffffff"))}</span>);<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeIntLE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e=+e,t=t&gt;&gt;&gt;0,!n){let a=<span class="cstat-no" title="statement not covered" >Math.pow(2,8*r-1);<span class="cstat-no" title="statement not covered" >t</span>e(this,e,t,r,a-1,-a)}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >0,o</span>=<span class="cstat-no" title="statement not covered" >1,s</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(this[t]=e&amp;255;++i&lt;r&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >e&lt;0&amp;&amp;s===0&amp;&amp;this[t+i-1]!==0&amp;&amp;(s=1),this[t+i]=(e/o&gt;&gt;0)-s&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t+r}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeIntBE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e=+e,t=t&gt;&gt;&gt;0,!n){let a=<span class="cstat-no" title="statement not covered" >Math.pow(2,8*r-1);<span class="cstat-no" title="statement not covered" >t</span>e(this,e,t,r,a-1,-a)}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >r-1,o</span>=<span class="cstat-no" title="statement not covered" >1,s</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(this[t+i]=e&amp;255;--i&gt;=0&amp;&amp;(o*=256);)<span class="cstat-no" title="statement not covered" >e&lt;0&amp;&amp;s===0&amp;&amp;this[t+i+1]!==0&amp;&amp;(s=1),this[t+i]=(e/o&gt;&gt;0)-s&amp;255;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t+r}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeInt8=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,1,127,-128),e&lt;0&amp;&amp;(e=255+e+1),this[t]=e&amp;255,t+1}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeInt16LE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,2,32767,-32768),this[t]=e&amp;255,this[t+1]=e&gt;&gt;&gt;8,t+2}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeInt16BE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,2,32767,-32768),this[t]=e&gt;&gt;&gt;8,this[t+1]=e&amp;255,t+2}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeInt32LE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,4,2147483647,-2147483648),this[t]=e&amp;255,this[t+1]=e&gt;&gt;&gt;8,this[t+2]=e&gt;&gt;&gt;16,this[t+3]=e&gt;&gt;&gt;24,t+4}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeInt32BE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return e=+e,t=t&gt;&gt;&gt;0,r||te(this,e,t,4,2147483647,-2147483648),e&lt;0&amp;&amp;(e=4294967295+e+1),this[t]=e&gt;&gt;&gt;24,this[t+1]=e&gt;&gt;&gt;16,this[t+2]=e&gt;&gt;&gt;8,this[t+3]=e&amp;255,t+4}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeBigInt64LE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return fi(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}</span>);<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeBigInt64BE=Ae(<span class="fstat-no" title="function not covered" >function(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return di(this,e,t,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}</span>);f</span>unction <span class="fstat-no" title="function not covered" >gi(e</span>,t,r,n,i,o){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r+n&gt;e.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range")}</span></span>function <span class="fstat-no" title="function not covered" >hi(e</span>,t,r,n,i){<span class="cstat-no" title="statement not covered" >return t=+t,r=r&gt;&gt;&gt;0,i||gi(e,t,r,4,34028234663852886e22,-34028234663852886e22),We.write(e,t,r,n,23,4),r+4}<span class="cstat-no" title="statement not covered" ></span>T.prototype.writeFloatLE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return hi(this,e,t,!0,r)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeFloatBE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return hi(this,e,t,!1,r)}</span>;f</span>unction <span class="fstat-no" title="function not covered" >yi(e</span>,t,r,n,i){<span class="cstat-no" title="statement not covered" >return t=+t,r=r&gt;&gt;&gt;0,i||gi(e,t,r,8,17976931348623157e292,-17976931348623157e292),We.write(e,t,r,n,52,8),r+8}<span class="cstat-no" title="statement not covered" ></span>T.prototype.writeDoubleLE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return yi(this,e,t,!0,r)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.writeDoubleBE=<span class="fstat-no" title="function not covered" >function(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return yi(this,e,t,!1,r)}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.copy=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!T.isBuffer(e))<span class="cstat-no" title="statement not covered" >throw new TypeError("argument should be a Buffer");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r||(r=0),!n&amp;&amp;n!==0&amp;&amp;(n=this.length),t&gt;=e.length&amp;&amp;(t=e.length),t||(t=0),n&gt;0&amp;&amp;n&lt;r&amp;&amp;(n=r),n===r||e.length===0||this.length===0)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("targetStart out of bounds");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r&lt;0||r&gt;=this.length)<span class="cstat-no" title="statement not covered" >throw new RangeError("Index out of range");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n&lt;0)<span class="cstat-no" title="statement not covered" >throw new RangeError("sourceEnd out of bounds");<span class="cstat-no" title="statement not covered" >n</span></span>&gt;this.length&amp;&amp;(n=this.length),e.length-t&lt;n-r&amp;&amp;(n=e.length-t+r);l</span>et i=<span class="cstat-no" title="statement not covered" >n-r;<span class="cstat-no" title="statement not covered" >r</span>eturn this===e&amp;&amp;typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(t,r,n):Uint8Array.prototype.set.call(e,this.subarray(r,n),t),i}</span>;<span class="cstat-no" title="statement not covered" >T</span>.prototype.fill=<span class="fstat-no" title="function not covered" >function(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >if(typeof e=="string"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t=="string"?(n=t,t=0,r=this.length):typeof r=="string"&amp;&amp;(n=r,r=this.length),n!==void 0&amp;&amp;typeof n!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError("encoding must be a string");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof n=="string"&amp;&amp;!T.isEncoding(n))<span class="cstat-no" title="statement not covered" >throw new TypeError("Unknown encoding: "+n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.length===1){let o=<span class="cstat-no" title="statement not covered" >e.charCodeAt(0);(<span class="cstat-no" title="statement not covered" >n</span>==="utf8"&amp;&amp;o&lt;128||n==="latin1")&amp;&amp;(e=o)}</span>}</span>else <span class="cstat-no" title="statement not covered" >typeof e=="number"?e=e&amp;255:typeof e=="boolean"&amp;&amp;(e=Number(e));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t&lt;0||this.length&lt;t||this.length&lt;r)<span class="cstat-no" title="statement not covered" >throw new RangeError("Out of range index");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r&lt;=t)<span class="cstat-no" title="statement not covered" >return this;<span class="cstat-no" title="statement not covered" >t</span></span>=t&gt;&gt;&gt;0,r=r===void 0?this.length:r&gt;&gt;&gt;0,e||(e=0);l</span>et i;<span class="cstat-no" title="statement not covered" >if(typeof e=="number")<span class="cstat-no" title="statement not covered" >for(i=t;i&lt;r;++i)<span class="cstat-no" title="statement not covered" >this[i]=e;else{</span></span>let o=<span class="cstat-no" title="statement not covered" >T.isBuffer(e)?e:T.from(e,n),s</span>=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(s===0)<span class="cstat-no" title="statement not covered" >throw new TypeError('The value "'+e+'" is invalid for argument "value"');<span class="cstat-no" title="statement not covered" >f</span></span>or(i=0;i&lt;r-t;++i)<span class="cstat-no" title="statement not covered" >this[i+t]=o[i%s]}<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this};v</span></span>ar Je=<span class="cstat-no" title="statement not covered" >{};f</span>unction <span class="fstat-no" title="function not covered" >ln(e</span>,t,r){<span class="cstat-no" title="statement not covered" >Je[e]=class extends r{<span class="fstat-no" title="function not covered" >constructor(){<span class="cstat-no" title="statement not covered" ></span>super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${e}]`,this.stack,delete this.name}<span class="fstat-no" title="function not covered" >g</span>et c</span>ode(){<span class="cstat-no" title="statement not covered" >return e}<span class="fstat-no" title="function not covered" ></span>set c</span>ode(n){<span class="cstat-no" title="statement not covered" >Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:n,writable:!0})}<span class="fstat-no" title="function not covered" ></span>toString(){<span class="cstat-no" title="statement not covered" ></span>return`${this.name} [${e}]: ${this.message}`}}</span>}<span class="cstat-no" title="statement not covered" ></span>ln("ERR_BUFFER_OUT_OF_BOUNDS",<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return e?`${e} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"}</span>,RangeError);<span class="cstat-no" title="statement not covered" >l</span>n("ERR_INVALID_ARG_TYPE",<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return`The "${e}" argument must be of type number. Received type ${typeof t}`},T</span>ypeError);<span class="cstat-no" title="statement not covered" >l</span>n("ERR_OUT_OF_RANGE",<span class="fstat-no" title="function not covered" >function(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >`The value of "${e}" is out of range.`,</span>i=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >r</span>eturn Number.isInteger(r)&amp;&amp;Math.abs(r)&gt;2**32?i=oi(String(r)):typeof r=="bigint"&amp;&amp;(i=String(r),(r&gt;BigInt(2)**BigInt(32)||r&lt;-(BigInt(2)**BigInt(32)))&amp;&amp;(i=oi(i)),i+="n"),n+=` It must be ${t}. Received ${i}`,n}</span>,RangeError);f</span>unction <span class="fstat-no" title="function not covered" >oi(e</span>){let t=<span class="cstat-no" title="statement not covered" >"",r</span>=<span class="cstat-no" title="statement not covered" >e.length,</span>n=<span class="cstat-no" title="statement not covered" >e[0]==="-"?1:0;<span class="cstat-no" title="statement not covered" >f</span>or(;r&gt;=n+4;r-=3)<span class="cstat-no" title="statement not covered" >t=`_${e.slice(r-3,r)}${t}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn`${e.slice(0,r)}${t}`}f</span>unction <span class="fstat-no" title="function not covered" >Ma(e</span>,t,r){<span class="cstat-no" title="statement not covered" >He(t,"offset"),(e[t]===void 0||e[t+r]===void 0)&amp;&amp;bt(t,e.length-(r+1))}</span>function <span class="fstat-no" title="function not covered" >wi(e</span>,t,r,n,i,o){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e&gt;r||e&lt;t){let s=<span class="cstat-no" title="statement not covered" >typeof t=="bigint"?"n":"",a</span>;<span class="cstat-no" title="statement not covered" >throw o&gt;3?t===0||t===BigInt(0)?a=`&gt;= 0${s} and &lt; 2${s} ** ${(o+1)*8}${s}`:a=`&gt;= -(2${s} ** ${(o+1)*8-1}${s}) and &lt; 2 ** ${(o+1)*8-1}${s}`:a=`&gt;= ${t}${s} and &lt;= ${r}${s}`,new Je.ERR_OUT_OF_RANGE("value",a,e)}<span class="cstat-no" title="statement not covered" ></span>M</span>a(n,i,o)}</span>function <span class="fstat-no" title="function not covered" >He(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new Je.ERR_INVALID_ARG_TYPE(t,"number",e)}</span></span>function <span class="fstat-no" title="function not covered" >bt(e</span>,t,r){<span class="cstat-no" title="statement not covered" >throw Math.floor(e)!==e?(He(e,r),new Je.ERR_OUT_OF_RANGE(r||"offset","an integer",e)):t&lt;0?new Je.ERR_BUFFER_OUT_OF_BOUNDS:new Je.ERR_OUT_OF_RANGE(r||"offset",`&gt;= ${r?1:0} and &lt;= ${t}`,e)}</span>var _a=<span class="cstat-no" title="statement not covered" >/[^+/0-9A-Za-z-_]/g;f</span>unction <span class="fstat-no" title="function not covered" >Na(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e=e.split("=")[0],e=e.trim().replace(_a,""),e.length&lt;2)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >f</span></span>or(;e.length%4!==0;)<span class="cstat-no" title="statement not covered" >e=e+"=";<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >on(e</span>,t){<span class="cstat-no" title="statement not covered" >t=t||1/0;l</span>et r,n=<span class="cstat-no" title="statement not covered" >e.length,</span>i=<span class="cstat-no" title="statement not covered" >null,o</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;n;++s){<span class="cstat-no" title="statement not covered" >if(r=e.charCodeAt(s),r&gt;55295&amp;&amp;r&lt;57344){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!i){<span class="cstat-no" title="statement not covered" >if(r&gt;56319){(<span class="cstat-no" title="statement not covered" >t-=3)&gt;-1&amp;&amp;o.push(239,191,189);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s+1===n){(<span class="cstat-no" title="statement not covered" >t-=3)&gt;-1&amp;&amp;o.push(239,191,189);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>i</span></span>=r;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(r&lt;56320){(<span class="cstat-no" title="statement not covered" >t-=3)&gt;-1&amp;&amp;o.push(239,191,189),i=r;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>=(i-55296&lt;&lt;10|r-56320)+65536}</span>else <span class="cstat-no" title="statement not covered" >i&amp;&amp;(t-=3)&gt;-1&amp;&amp;o.push(239,191,189);<span class="cstat-no" title="statement not covered" >i</span></span>f(i=null,r&lt;128){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((t-=1)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>.push(r)}</span>else <span class="cstat-no" title="statement not covered" >if(r&lt;2048){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((t-=2)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>.push(r&gt;&gt;6|192,r&amp;63|128)}</span>else <span class="cstat-no" title="statement not covered" >if(r&lt;65536){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((t-=3)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>.push(r&gt;&gt;12|224,r&gt;&gt;6&amp;63|128,r&amp;63|128)}</span>else <span class="cstat-no" title="statement not covered" >if(r&lt;1114112){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((t-=4)&lt;0)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >o</span></span>.push(r&gt;&gt;18|240,r&gt;&gt;12&amp;63|128,r&gt;&gt;6&amp;63|128,r&amp;63|128)}</span>else <span class="cstat-no" title="statement not covered" >throw new Error("Invalid code point")}<span class="cstat-no" title="statement not covered" ></span></span></span></span></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Fa(e</span>){let t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;e.length;++r)<span class="cstat-no" title="statement not covered" >t.push(e.charCodeAt(r)&amp;255);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >La(e</span>,t){let r,n,i,o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;e.length&amp;&amp;!((t-=2)&lt;0);++s)<span class="cstat-no" title="statement not covered" >r=e.charCodeAt(s),n=r&gt;&gt;8,i=r%256,o.push(i),o.push(n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Ei(e</span>){<span class="cstat-no" title="statement not covered" >return rn.toByteArray(Na(e))}</span>function <span class="fstat-no" title="function not covered" >ar(e</span>,t,r,n){let i;<span class="cstat-no" title="statement not covered" >for(i=0;i&lt;n&amp;&amp;!(i+r&gt;=t.length||i&gt;=e.length);++i)<span class="cstat-no" title="statement not covered" >t[i+r]=e[i];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >fe(e</span>,t){<span class="cstat-no" title="statement not covered" >return e instanceof t||e!=null&amp;&amp;e.constructor!=null&amp;&amp;e.constructor.name!=null&amp;&amp;e.constructor.name===t.name}f</span>unction <span class="fstat-no" title="function not covered" >un(e</span>){<span class="cstat-no" title="statement not covered" >return e!==e}</span>var Ba=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(){l</span>et e=<span class="cstat-no" title="statement not covered" >"0123456789abcdef",t</span>=<span class="cstat-no" title="statement not covered" >new Array(256);<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;16;++r){let n=<span class="cstat-no" title="statement not covered" >r*16;<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;16;++i)<span class="cstat-no" title="statement not covered" >t[n+i]=e[r]+e[i]}<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ae(e</span>){<span class="cstat-no" title="statement not covered" >return typeof BigInt&gt;"u"?Ua:e}</span>function <span class="fstat-no" title="function not covered" >Ua(){<span class="cstat-no" title="statement not covered" >t</span>hrow new Error("BigInt not supported")}</span>});v</span>ar w,f=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >w=Qe(bi())}</span>);f</span>unction <span class="fstat-no" title="function not covered" >Qa(){<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Ui(){<span class="cstat-no" title="statement not covered" >r</span>eturn{dev:0,ino:0,mode:0,nlink:0,uid:0,gid:0,rdev:0,size:0,blksize:0,blocks:0,atimeMs:0,mtimeMs:0,ctimeMs:0,birthtimeMs:0,atime:new Date,mtime:new Date,ctime:new Date,birthtime:new Date}}</span>function <span class="fstat-no" title="function not covered" >Ja(){<span class="cstat-no" title="statement not covered" >r</span>eturn Ui()}</span>function <span class="fstat-no" title="function not covered" >Wa(){<span class="cstat-no" title="statement not covered" >r</span>eturn[]}f</span>unction <span class="fstat-no" title="function not covered" >Ha(e</span>){<span class="cstat-no" title="statement not covered" >e(null,[])}</span>function <span class="fstat-no" title="function not covered" >Ka(){<span class="cstat-no" title="statement not covered" >r</span>eturn""}</span>function <span class="fstat-no" title="function not covered" >za(){<span class="cstat-no" title="statement not covered" >r</span>eturn""}</span>function <span class="fstat-no" title="function not covered" >Ya(){}</span>function <span class="fstat-no" title="function not covered" >Za(){}</span>function <span class="fstat-no" title="function not covered" >Xa(){}</span>function <span class="fstat-no" title="function not covered" >el(){}</span>function <span class="fstat-no" title="function not covered" >tl(){}</span>function <span class="fstat-no" title="function not covered" >rl(){}</span>var nl,il,qi,$i=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >n</span>l={},il={existsSync:Qa,lstatSync:Ui,statSync:Ja,readdirSync:Wa,readdir:Ha,readlinkSync:Ka,realpathSync:za,chmodSync:Ya,renameSync:Za,mkdirSync:Xa,rmdirSync:el,rmSync:tl,unlinkSync:rl,promises:nl},qi=il}</span>);f</span>unction <span class="fstat-no" title="function not covered" >ol(.</span>..e){<span class="cstat-no" title="statement not covered" >return e.join("/")}</span>function <span class="fstat-no" title="function not covered" >sl(.</span>..e){<span class="cstat-no" title="statement not covered" >return e.join("/")}</span>function <span class="fstat-no" title="function not covered" >al(e</span>){let t=<span class="cstat-no" title="statement not covered" >ji(e),r</span>=<span class="cstat-no" title="statement not covered" >Vi(e),[</span>n,i]=<span class="cstat-no" title="statement not covered" >t.split(".");<span class="cstat-no" title="statement not covered" >r</span>eturn{root:"/",dir:r,base:t,ext:i,name:n}}</span>function <span class="fstat-no" title="function not covered" >ji(e</span>){let t=<span class="cstat-no" title="statement not covered" >e.split("/");<span class="cstat-no" title="statement not covered" >r</span>eturn t[t.length-1]}f</span>unction <span class="fstat-no" title="function not covered" >Vi(e</span>){<span class="cstat-no" title="statement not covered" >return e.split("/").slice(0,-1).join("/")}</span>var Gi,ll,ul,pr,Qi=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >G</span>i="/",ll={sep:Gi},ul={basename:ji,dirname:Vi,join:sl,parse:al,posix:ll,resolve:ol,sep:Gi},pr=ul}</span>);v</span>ar Ji=<span class="cstat-no" title="statement not covered" >Fe(<span class="fstat-no" title="function not covered" >(l</span>f,cl)=&gt;{<span class="cstat-no" title="statement not covered" >cl.exports={name:"@prisma/internals",version:"6.8.2",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.5.0",esbuild:"0.25.1","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.8.0-43.2060c79ba17c6bb9f5823312b6f6b7f4a845738e","@prisma/schema-engine-wasm":"6.8.0-43.2060c79ba17c6bb9f5823312b6f6b7f4a845738e","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:"&gt;=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}}</span>);v</span>ar Ki=<span class="cstat-no" title="statement not covered" >Fe(<span class="fstat-no" title="function not covered" >(R</span>f,Hi)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >H</span>i.exports=<span class="fstat-no" title="function not covered" >(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>r)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r={indent:" ",includeEmptyLines:!1,...r},typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof r.indent!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t===0)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;<span class="cstat-no" title="statement not covered" >r</span>eturn e.replace(n,r.indent.repeat(t))}</span>}</span>);v</span>ar Zi=<span class="cstat-no" title="statement not covered" >Fe(<span class="fstat-no" title="function not covered" >(U</span>f,Yi)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >Y</span>i.exports=<span class="fstat-no" title="function not covered" >({</span>onlyFirst:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=&gt;&lt;~]))"].join("|");<span class="cstat-no" title="statement not covered" >r</span>eturn new RegExp(t,e?void 0:"g")}</span>}</span>);v</span>ar eo=<span class="cstat-no" title="statement not covered" >Fe(<span class="fstat-no" title="function not covered" >(Q</span>f,Xi)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar wl=<span class="cstat-no" title="statement not covered" >Zi();<span class="cstat-no" title="statement not covered" >X</span>i.exports=<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof e=="string"?e.replace(wl(),""):e}</span></span>);v</span>ar vn=<span class="cstat-no" title="statement not covered" >Fe(<span class="fstat-no" title="function not covered" >(M</span>y,Eo)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >E</span>o.exports=<span class="fstat-no" title="function not covered" >function(){f</span>unction <span class="fstat-no" title="function not covered" >e(t</span>,r,n,i,o){<span class="cstat-no" title="statement not covered" >return t&lt;r||n&lt;r?t&gt;n?n+1:t+1:i===o?r:r+1}<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(t</span>,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t===r)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t.length&gt;r.length){var n=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >t</span>=r,r=n}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >r.length;</span>i&gt;0&amp;&amp;t.charCodeAt(i-1)===r.charCodeAt(o-1);)<span class="cstat-no" title="statement not covered" >i--,o--;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;i&amp;&amp;t.charCodeAt(s)===r.charCodeAt(s);)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(i-=s,o-=s,i===0||o&lt;3)<span class="cstat-no" title="statement not covered" >return o;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >0,l</span>,d,g,h,v,S,A,R,D,M,B,k,F=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(l=0;l&lt;i;l++)<span class="cstat-no" title="statement not covered" >F.push(l+1),F.push(t.charCodeAt(s+l));<span class="cstat-no" title="statement not covered" >f</span></span>or(var ie=<span class="cstat-no" title="statement not covered" >F.length-1;a</span>&lt;o-3;)<span class="cstat-no" title="statement not covered" >for(D=r.charCodeAt(s+(d=a)),M=r.charCodeAt(s+(g=a+1)),B=r.charCodeAt(s+(h=a+2)),k=r.charCodeAt(s+(v=a+3)),S=a+=4,l=0;l&lt;ie;l+=2)<span class="cstat-no" title="statement not covered" >A=F[l],R=F[l+1],d=e(A,d,g,D,R),g=e(d,g,h,M,R),h=e(g,h,v,B,R),S=e(h,v,S,k,R),F[l]=S,v=h,h=g,g=d,d=A;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;a&lt;o;)<span class="cstat-no" title="statement not covered" >for(D=r.charCodeAt(s+(d=a)),S=++a,l=0;l&lt;ie;l+=2)<span class="cstat-no" title="statement not covered" >A=F[l],F[l]=S=e(A,d,S,D,F[l+1]),d=A;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn S}</span>}</span>()}</span>);v</span>ar To=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>()}</span>);v</span>ar Co=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>()}</span>);v</span>ar Jo=<span class="cstat-no" title="statement not covered" >Fe(<span class="fstat-no" title="function not covered" >(t</span>1,lc)=&gt;{<span class="cstat-no" title="statement not covered" >lc.exports={name:"@prisma/engines-version",version:"6.8.0-43.2060c79ba17c6bb9f5823312b6f6b7f4a845738e",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"2060c79ba17c6bb9f5823312b6f6b7f4a845738e"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}}</span>);v</span>ar Ur,Wo=<span class="cstat-no" title="statement not covered" >me(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >U</span>r=class{<span class="cstat-no" title="statement not covered" >events={};<span class="fstat-no" title="function not covered" >o</span>n(t</span>,r){<span class="cstat-no" title="statement not covered" >return this.events[t]||(this.events[t]=[]),this.events[t].push(r),this}<span class="fstat-no" title="function not covered" >e</span>mit(t</span>,...r){<span class="cstat-no" title="statement not covered" >return this.events[t]?(this.events[t].forEach(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >n</span>(...r)}</span>),!0):!1}</span>}}</span>);<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar vi=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >o</span>r(vi,{defineExtension:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >x</span>i,g</span>etExtensionContext:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>i}</span>);<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >xi(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="function"?e:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.$extends(e)}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Pi(e</span>){<span class="cstat-no" title="statement not covered" >return e}</span>var Ci=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >o</span>r(Ci,{validator:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >T</span>i}</span>);<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ti(.</span>..e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar cn,Ai,Ri,Si,ki=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" >t</span>ypeof y&lt;"u"&amp;&amp;({FORCE_COLOR:cn,NODE_DISABLE_COLORS:Ai,NO_COLOR:Ri,TERM:Si}=y.env||{},ki=y.stdout&amp;&amp;y.stdout.isTTY</span>);var qa=<span class="cstat-no" title="statement not covered" >{enabled:!Ai&amp;&amp;Ri==null&amp;&amp;Si!=="dumb"&amp;&amp;(cn!=null&amp;&amp;cn!=="0"||ki)};f</span>unction <span class="fstat-no" title="function not covered" >j(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >new RegExp(`\\x1b\\[${t}m`,"g"),n</span>=<span class="cstat-no" title="statement not covered" >`\x1B[${e}m`,</span>i=<span class="cstat-no" title="statement not covered" >`\x1B[${t}m`;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(o</span>){<span class="cstat-no" title="statement not covered" >return!qa.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(r,i+n):o)+i}</span>}</span>var cm=<span class="cstat-no" title="statement not covered" >j(0,0),l</span>r=<span class="cstat-no" title="statement not covered" >j(1,22),u</span>r=<span class="cstat-no" title="statement not covered" >j(2,22),p</span>m=<span class="cstat-no" title="statement not covered" >j(3,23),I</span>i=<span class="cstat-no" title="statement not covered" >j(4,24),m</span>m=<span class="cstat-no" title="statement not covered" >j(7,27),f</span>m=<span class="cstat-no" title="statement not covered" >j(8,28),d</span>m=<span class="cstat-no" title="statement not covered" >j(9,29),g</span>m=<span class="cstat-no" title="statement not covered" >j(30,39),z</span>e=<span class="cstat-no" title="statement not covered" >j(31,39),O</span>i=<span class="cstat-no" title="statement not covered" >j(32,39),D</span>i=<span class="cstat-no" title="statement not covered" >j(33,39),M</span>i=<span class="cstat-no" title="statement not covered" >j(34,39),h</span>m=<span class="cstat-no" title="statement not covered" >j(35,39),_</span>i=<span class="cstat-no" title="statement not covered" >j(36,39),y</span>m=<span class="cstat-no" title="statement not covered" >j(37,39),N</span>i=<span class="cstat-no" title="statement not covered" >j(90,39),w</span>m=<span class="cstat-no" title="statement not covered" >j(90,39),E</span>m=<span class="cstat-no" title="statement not covered" >j(40,49),b</span>m=<span class="cstat-no" title="statement not covered" >j(41,49),x</span>m=<span class="cstat-no" title="statement not covered" >j(42,49),P</span>m=<span class="cstat-no" title="statement not covered" >j(43,49),v</span>m=<span class="cstat-no" title="statement not covered" >j(44,49),T</span>m=<span class="cstat-no" title="statement not covered" >j(45,49),C</span>m=<span class="cstat-no" title="statement not covered" >j(46,49),A</span>m=<span class="cstat-no" title="statement not covered" >j(47,49);<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar $a=<span class="cstat-no" title="statement not covered" >100,F</span>i=<span class="cstat-no" title="statement not covered" >["green","yellow","blue","magenta","cyan","red"],c</span>r=<span class="cstat-no" title="statement not covered" >[],</span>Li=<span class="cstat-no" title="statement not covered" >Date.now(),j</span>a=<span class="cstat-no" title="statement not covered" >0,p</span>n=<span class="cstat-no" title="statement not covered" >typeof y&lt;"u"?y.env:{};<span class="cstat-no" title="statement not covered" >g</span>lobalThis.DEBUG??=pn.DEBUG??"";<span class="cstat-no" title="statement not covered" >g</span>lobalThis.DEBUG_COLORS??=pn.DEBUG_COLORS?pn.DEBUG_COLORS==="true":!0;v</span>ar xt=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >enable(e</span>){<span class="cstat-no" title="statement not covered" >typeof e=="string"&amp;&amp;(globalThis.DEBUG=e)}</span>,<span class="fstat-no" title="function not covered" >disable(){l</span>et e=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG;<span class="cstat-no" title="statement not covered" ></span>return globalThis.DEBUG="",e}</span>,<span class="fstat-no" title="function not covered" >enabled(e</span>){let t=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG.split(",").map(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >i</span>.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;")),r</span></span>=<span class="cstat-no" title="statement not covered" >t.some(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >i</span>===""||i[0]==="-"?!1:e.match(RegExp(i.split("*").join(".*")+"$"))),n</span></span>=<span class="cstat-no" title="statement not covered" >t.some(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >i</span>===""||i[0]!=="-"?!1:e.match(RegExp(i.slice(1).split("*").join(".*")+"$")));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r&amp;&amp;!n}</span>,log:<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;{let[t,r,...n]=<span class="cstat-no" title="statement not covered" >e;(<span class="cstat-no" title="statement not covered" >c</span>onsole.warn??console.log)(`${t} ${r}`,...n)}</span>,formatters:{}};f</span>unction <span class="fstat-no" title="function not covered" >Va(e</span>){let t=<span class="cstat-no" title="statement not covered" >{color:Fi[ja++%Fi.length],enabled:xt.enabled(e),namespace:e,log:xt.log,extend:<span class="fstat-no" title="function not covered" >()=&gt;{}</span>},r</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..n)=&gt;{let{enabled:i,namespace:o,color:s,log:a}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n.length!==0&amp;&amp;cr.push([o,...n]),cr.length&gt;$a&amp;&amp;cr.shift(),xt.enabled(o)||i){let l=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >g=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof g=="string"?g:Ga(g)),d</span></span>=<span class="cstat-no" title="statement not covered" >`+${Date.now()-Li}ms`;<span class="cstat-no" title="statement not covered" ></span>Li=Date.now(),a(o,...l,d)}</span>}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn new Proxy(r,{get:<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t[i],</span>set:<span class="fstat-no" title="function not covered" >(n</span>,i,o)=&gt;<span class="cstat-no" title="statement not covered" >t[i]=o}</span>)}</span>var Y=<span class="cstat-no" title="statement not covered" >new Proxy(Va,{get:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >xt[t],</span>set:<span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >xt[t]=r}</span>);f</span>unction <span class="fstat-no" title="function not covered" >Ga(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{let r=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" >r</span>eturn JSON.stringify(e,<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof i=="object"&amp;&amp;i!==null){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r.has(i))<span class="cstat-no" title="statement not covered" >return"[Circular *]";<span class="cstat-no" title="statement not covered" >r</span></span>.add(i)}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof i=="bigint")<span class="cstat-no" title="statement not covered" >return i.toString();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>,t)}</span>function <span class="fstat-no" title="function not covered" >Bi(){<span class="cstat-no" title="statement not covered" >c</span>r.length=0}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar pl=<span class="cstat-no" title="statement not covered" >Ji(),m</span>n=<span class="cstat-no" title="statement not covered" >pl.version;<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ye(e</span>){let t=<span class="cstat-no" title="statement not covered" >ml();<span class="cstat-no" title="statement not covered" >r</span>eturn t||(e?.config.engineType==="library"?"library":e?.config.engineType==="binary"?"binary":e?.config.engineType==="client"?"client":fl(e))}</span>function <span class="fstat-no" title="function not covered" >ml(){l</span>et e=<span class="cstat-no" title="statement not covered" >y.env.PRISMA_CLIENT_ENGINE_TYPE;<span class="cstat-no" title="statement not covered" ></span>return e==="library"?"library":e==="binary"?"binary":e==="client"?"client":void 0}</span>function <span class="fstat-no" title="function not covered" >fl(e</span>){<span class="cstat-no" title="statement not covered" >return e?.previewFeatures.includes("queryCompiler")?"client":"library"}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Wi=<span class="cstat-no" title="statement not covered" >"prisma+postgres",m</span>r=<span class="cstat-no" title="statement not covered" >`${Wi}:`;</span>function <span class="fstat-no" title="function not covered" >fr(e</span>){<span class="cstat-no" title="statement not covered" >return e?.toString().startsWith(`${mr}//`)??!1}</span>function <span class="fstat-no" title="function not covered" >fn(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!fr(e))<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et{host:t}=<span class="cstat-no" title="statement not covered" >new URL(e);<span class="cstat-no" title="statement not covered" >r</span>eturn t.includes("localhost")||t.includes("127.0.0.1")}</span>var vt=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >o</span>r(vt,{error:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >h</span>l,i</span>nfo:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>l,l</span>og:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >d</span>l,q</span>uery:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >y</span>l,s</span>hould:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >z</span>i,t</span>ags:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>t,w</span>arn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >d</span>n}</span>);<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Pt=<span class="cstat-no" title="statement not covered" >{error:ze("prisma:error"),warn:Di("prisma:warn"),info:_i("prisma:info"),query:Mi("prisma:query")},z</span>i=<span class="cstat-no" title="statement not covered" >{warn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>y.env.PRISMA_DISABLE_WARNINGS}</span>;f</span>unction <span class="fstat-no" title="function not covered" >dl(.</span>..e){<span class="cstat-no" title="statement not covered" >console.log(...e)}</span>function <span class="fstat-no" title="function not covered" >dn(e</span>,...t){<span class="cstat-no" title="statement not covered" >zi.warn()&amp;&amp;console.warn(`${Pt.warn} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >gl(e</span>,...t){<span class="cstat-no" title="statement not covered" >console.info(`${Pt.info} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >hl(e</span>,...t){<span class="cstat-no" title="statement not covered" >console.error(`${Pt.error} ${e}`,...t)}</span>function <span class="fstat-no" title="function not covered" >yl(e</span>,...t){<span class="cstat-no" title="statement not covered" >console.log(`${Pt.query} ${e}`,...t)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Pe(e</span>,t){<span class="cstat-no" title="statement not covered" >throw new Error(t)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >gn(e</span>,t){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(e,t)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ze(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.keys(e))<span class="cstat-no" title="statement not covered" >r[n]=t(e[n],n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >hn(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===0)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;n</span>&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >t(r,e[n])&lt;0&amp;&amp;(r=e[n]</span></span>);<span class="cstat-no" title="statement not covered" >return r}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >N(e</span>,t){<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"name",{value:t,configurable:!0})}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar to=<span class="cstat-no" title="statement not covered" >new Set,d</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,...r)=&gt;{<span class="cstat-no" title="statement not covered" >to.has(e)||(to.add(e),dn(t,...r))}</span>;v</span>ar Q=<span class="cstat-no" title="statement not covered" >class e extends Error{clientVersion;errorCode;retryable;<span class="fstat-no" title="function not covered" >constructor(t</span>,r,n){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(e)}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientInitializationError"}</span>};<span class="cstat-no" title="statement not covered" >N</span>(Q,"PrismaClientInitializationError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar oe=<span class="cstat-no" title="statement not covered" >class extends Error{code;meta;clientVersion;batchRequestIdx;<span class="fstat-no" title="function not covered" >constructor(t</span>,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientKnownRequestError"}</span>};<span class="cstat-no" title="statement not covered" >N</span>(oe,"PrismaClientKnownRequestError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Re=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientRustPanicError",this.clientVersion=r}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientRustPanicError"}</span>};<span class="cstat-no" title="statement not covered" >N</span>(Re,"PrismaClientRustPanicError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar se=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;batchRequestIdx;<span class="fstat-no" title="function not covered" >constructor(t</span>,{clientVersion:r,batchRequestIdx:n}){<span class="cstat-no" title="statement not covered" >super(t),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientUnknownRequestError"}</span>};<span class="cstat-no" title="statement not covered" >N</span>(se,"PrismaClientUnknownRequestError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar X=<span class="cstat-no" title="statement not covered" >class extends Error{name="PrismaClientValidationError";clientVersion;<span class="fstat-no" title="function not covered" >constructor(t</span>,{clientVersion:r}){<span class="cstat-no" title="statement not covered" >super(t),this.clientVersion=r}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientValidationError"}</span>};<span class="cstat-no" title="statement not covered" >N</span>(X,"PrismaClientValidationError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Xe=<span class="cstat-no" title="statement not covered" >9e15,O</span>e=<span class="cstat-no" title="statement not covered" >1e9,y</span>n=<span class="cstat-no" title="statement not covered" >"0123456789abcdef",y</span>r=<span class="cstat-no" title="statement not covered" >"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",w</span>r=<span class="cstat-no" title="statement not covered" >"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",w</span>n=<span class="cstat-no" title="statement not covered" >{precision:20,rounding:4,modulo:1,toExpNeg:-7,toExpPos:21,minE:-Xe,maxE:Xe,crypto:!1},s</span>o,ve,_=<span class="cstat-no" title="statement not covered" >!0,b</span>r=<span class="cstat-no" title="statement not covered" >"[DecimalError] ",I</span>e=<span class="cstat-no" title="statement not covered" >br+"Invalid argument: ",a</span>o=<span class="cstat-no" title="statement not covered" >br+"Precision limit exceeded",l</span>o=<span class="cstat-no" title="statement not covered" >br+"crypto unavailable",u</span>o=<span class="cstat-no" title="statement not covered" >"[object Decimal]",Z</span>=<span class="cstat-no" title="statement not covered" >Math.floor,</span>J=<span class="cstat-no" title="statement not covered" >Math.pow,</span>El=<span class="cstat-no" title="statement not covered" >/^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,b</span>l=<span class="cstat-no" title="statement not covered" >/^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,x</span>l=<span class="cstat-no" title="statement not covered" >/^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,c</span>o=<span class="cstat-no" title="statement not covered" >/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,c</span>e=<span class="cstat-no" title="statement not covered" >1e7,O</span>=<span class="cstat-no" title="statement not covered" >7,P</span>l=<span class="cstat-no" title="statement not covered" >9007199254740991,v</span>l=<span class="cstat-no" title="statement not covered" >yr.length-1,E</span>n=<span class="cstat-no" title="statement not covered" >wr.length-1,C</span>=<span class="cstat-no" title="statement not covered" >{toStringTag:uo};<span class="cstat-no" title="statement not covered" >C</span>.absoluteValue=C.abs=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" >r</span>eturn e.s&lt;0&amp;&amp;(e.s=1),I(e)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.ceil=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn I(new this.constructor(this),this.e+1,2)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.clampedTo=C.clamp=<span class="fstat-no" title="function not covered" >function(e</span>,t){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e=new i(e),t=new i(t),!e.s||!t.s)<span class="cstat-no" title="statement not covered" >return new i(NaN);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.gt(t))<span class="cstat-no" title="statement not covered" >throw Error(Ie+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r=n.cmp(e),r&lt;0?e:n.cmp(t)&gt;0?t:new i(n)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.comparedTo=C.cmp=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r,n,i,o=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >o.d,</span>a=<span class="cstat-no" title="statement not covered" >(e=new o.constructor(e)).d,</span>l=<span class="cstat-no" title="statement not covered" >o.s,</span>d=<span class="cstat-no" title="statement not covered" >e.s;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!s||!a)<span class="cstat-no" title="statement not covered" >return!l||!d?NaN:l!==d?l:s===a?0:!s^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!s[0]||!a[0])<span class="cstat-no" title="statement not covered" >return s[0]?l:a[0]?-d:0;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(l!==d)<span class="cstat-no" title="statement not covered" >return l;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(o.e!==e.e)<span class="cstat-no" title="statement not covered" >return o.e&gt;e.e^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=s.length,i=a.length,t=0,r=n&lt;i?n:i;t&lt;r;++t)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s[t]!==a[t])<span class="cstat-no" title="statement not covered" >return s[t]&gt;a[t]^l&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n===i?0:n&gt;i^l&lt;0?1:-1}</span>;<span class="cstat-no" title="statement not covered" >C</span>.cosine=C.cos=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.d?r.d[0]?(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+O,n.rounding=1,r=Tl(n,ho(n,r)),n.precision=e,n.rounding=t,I(ve==2||ve==3?r.neg():r,e,t,!0)):new n(1):new n(NaN)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.cubeRoot=C.cbrt=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r,n,i,o,s,a,l,d,g=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >g.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!g.isFinite()||g.isZero())<span class="cstat-no" title="statement not covered" >return new h(g);<span class="cstat-no" title="statement not covered" >f</span></span>or(_=!1,o=g.s*J(g.s*g,1/3),!o||Math.abs(o)==1/0?(r=K(g.d),e=g.e,(o=(e-r.length+1)%3)&amp;&amp;(r+=o==1||o==-2?"0":"00"),o=J(r,1/3),e=Z((e+1)/3)-(e%3==(e&lt;0?-1:2)),o==1/0?r="5e"+e:(r=o.toExponential(),r=r.slice(0,r.indexOf("e")+1)+e),n=new h(r),n.s=g.s):n=new h(o.toString()),s=(e=h.precision)+3;;)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(a=n,l=a.times(a).times(a),d=l.plus(g),n=q(d.plus(g).times(a),d.plus(l),s+2,1),K(a.d).slice(0,s)===(r=K(n.d)).slice(0,s))<span class="cstat-no" title="statement not covered" >if(r=r.slice(s-3,s+1),r=="9999"||!i&amp;&amp;r=="4999"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!i&amp;&amp;(I(a,e+1,0),a.times(a).times(a).eq(g))){<span class="cstat-no" title="statement not covered" >n=a;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span>+=4,i=1}</span>else{(<span class="cstat-no" title="statement not covered" >!+r||!+r.slice(1)&amp;&amp;r.charAt(0)=="5")&amp;&amp;(I(n,e+1,1),t=!n.times(n).times(n).eq(g));<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn _=!0,I(n,e,h.rounding,t)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.decimalPlaces=C.dp=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t=<span class="cstat-no" title="statement not covered" >this.d,</span>r=<span class="cstat-no" title="statement not covered" >NaN;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e=t.length-1,r=(e-Z(this.e/O))*O,e=t[e],e)<span class="cstat-no" title="statement not covered" >for(;e%10==0;e/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >r</span></span></span>&lt;0&amp;&amp;(r=0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>;<span class="cstat-no" title="statement not covered" >C</span>.dividedBy=C.div=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return q(this,new this.constructor(e))}</span>;<span class="cstat-no" title="statement not covered" >C</span>.dividedToIntegerBy=C.divToInt=<span class="fstat-no" title="function not covered" >function(e</span>){var t=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return I(q(t,new r(e),0,1,1),r.precision,r.rounding)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.equals=C.eq=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)===0}</span>;<span class="cstat-no" title="statement not covered" >C</span>.floor=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn I(new this.constructor(this),this.e+1,3)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.greaterThan=C.gt=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&gt;0}</span>;<span class="cstat-no" title="statement not covered" >C</span>.greaterThanOrEqualTo=C.gte=<span class="fstat-no" title="function not covered" >function(e</span>){var t=<span class="cstat-no" title="statement not covered" >this.cmp(e);<span class="cstat-no" title="statement not covered" >r</span>eturn t==1||t===0}</span>;<span class="cstat-no" title="statement not covered" >C</span>.hyperbolicCosine=C.cosh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r,n,i,o=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >o.constructor,</span>a=<span class="cstat-no" title="statement not covered" >new s(1);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o.isFinite())<span class="cstat-no" title="statement not covered" >return new s(o.s?1/0:NaN);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(o.isZero())<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >r</span></span>=s.precision,n=s.rounding,s.precision=r+Math.max(o.e,o.sd())+4,s.rounding=1,i=o.d.length,i&lt;32?(e=Math.ceil(i/3),t=(1/Pr(4,e)).toString()):(e=16,t="2.3283064365386962890625e-10"),o=et(s,1,o.times(t),new s(1),!0);<span class="cstat-no" title="statement not covered" >f</span>or(var l,d=<span class="cstat-no" title="statement not covered" >e,g</span>=<span class="cstat-no" title="statement not covered" >new s(8);d</span>--;)<span class="cstat-no" title="statement not covered" >l=o.times(o),o=a.minus(l.times(g.minus(l.times(g))));<span class="cstat-no" title="statement not covered" >r</span></span>eturn I(o,s.precision=r,s.rounding=n,!0)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.hyperbolicSine=C.sinh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!i.isFinite()||i.isZero())<span class="cstat-no" title="statement not covered" >return new o(i);<span class="cstat-no" title="statement not covered" >i</span></span>f(t=o.precision,r=o.rounding,o.precision=t+Math.max(i.e,i.sd())+4,o.rounding=1,n=i.d.length,n&lt;3)<span class="cstat-no" title="statement not covered" >i=et(o,2,i,i,!0);else{<span class="cstat-no" title="statement not covered" ></span>e=1.4*Math.sqrt(n),e=e&gt;16?16:e|0,i=i.times(1/Pr(5,e)),i=et(o,2,i,i,!0);<span class="cstat-no" title="statement not covered" >f</span>or(var s,a=<span class="cstat-no" title="statement not covered" >new o(5),l</span>=<span class="cstat-no" title="statement not covered" >new o(16),d</span>=<span class="cstat-no" title="statement not covered" >new o(20);e</span>--;)<span class="cstat-no" title="statement not covered" >s=i.times(i),i=i.times(a.plus(s.times(l.times(s).plus(d))))}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn o.precision=t,o.rounding=r,I(i,t,r,!0)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.hyperbolicTangent=C.tanh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+7,n.rounding=1,q(r.sinh(),r.cosh(),n.precision=e,n.rounding=t)):new n(r.s)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.inverseCosine=C.acos=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor,</span>r=<span class="cstat-no" title="statement not covered" >e.abs().cmp(1),n</span>=<span class="cstat-no" title="statement not covered" >t.precision,</span>i=<span class="cstat-no" title="statement not covered" >t.rounding;<span class="cstat-no" title="statement not covered" ></span>return r!==-1?r===0?e.isNeg()?de(t,n,i):new t(0):new t(NaN):e.isZero()?de(t,n+4,i).times(.5):(t.precision=n+6,t.rounding=1,e=new t(1).minus(e).div(e.plus(1)).sqrt().atan(),t.precision=n,t.rounding=i,e.times(2))}</span>;<span class="cstat-no" title="statement not covered" >C</span>.inverseHyperbolicCosine=C.acosh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.lte(1)?new n(r.eq(1)?0:NaN):r.isFinite()?(e=n.precision,t=n.rounding,n.precision=e+Math.max(Math.abs(r.e),r.sd())+4,n.rounding=1,_=!1,r=r.times(r).minus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln()):new n(r)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.inverseHyperbolicSine=C.asinh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return!r.isFinite()||r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+2*Math.max(Math.abs(r.e),r.sd())+6,n.rounding=1,_=!1,r=r.times(r).plus(1).sqrt().plus(r),_=!0,n.precision=e,n.rounding=t,r.ln())}</span>;<span class="cstat-no" title="statement not covered" >C</span>.inverseHyperbolicTangent=C.atanh=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return i.isFinite()?i.e&gt;=0?new o(i.abs().eq(1)?i.s/0:i.isZero()?i:NaN):(e=o.precision,t=o.rounding,n=i.sd(),Math.max(n,e)&lt;2*-i.e-1?I(new o(i),e,t,!0):(o.precision=r=n-i.e,i=q(i.plus(1),new o(1).minus(i),r+e,1),o.precision=e+4,o.rounding=1,i=i.ln(),o.precision=e,o.rounding=t,i.times(.5))):new o(NaN)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.inverseSine=C.asin=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return i.isZero()?new o(i):(t=i.abs().cmp(1),r=o.precision,n=o.rounding,t!==-1?t===0?(e=de(o,r+4,n).times(.5),e.s=i.s,e):new o(NaN):(o.precision=r+6,o.rounding=1,i=i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(),o.precision=r,o.rounding=n,i.times(2)))}</span>;<span class="cstat-no" title="statement not covered" >C</span>.inverseTangent=C.atan=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r,n,i,o,s,a,l,d=<span class="cstat-no" title="statement not covered" >this,</span>g=<span class="cstat-no" title="statement not covered" >d.constructor,</span>h=<span class="cstat-no" title="statement not covered" >g.precision,</span>v=<span class="cstat-no" title="statement not covered" >g.rounding;<span class="cstat-no" title="statement not covered" ></span>if(d.isFinite()){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(d.isZero())<span class="cstat-no" title="statement not covered" >return new g(d);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(d.abs().eq(1)&amp;&amp;h+4&lt;=En)<span class="cstat-no" title="statement not covered" >return s=de(g,h+4,v).times(.25),s.s=d.s,s}</span></span>else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!d.s)<span class="cstat-no" title="statement not covered" >return new g(NaN);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(h+4&lt;=En)<span class="cstat-no" title="statement not covered" >return s=de(g,h+4,v).times(.5),s.s=d.s,s}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(g.precision=a=h+10,g.rounding=1,r=Math.min(28,a/O+2|0),e=r;e;--e)<span class="cstat-no" title="statement not covered" >d=d.div(d.times(d).plus(1).sqrt().plus(1));<span class="cstat-no" title="statement not covered" >f</span></span>or(_=!1,t=Math.ceil(a/O),n=1,l=d.times(d),s=new g(d),i=d;e!==-1;)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i=i.times(l),o=s.minus(i.div(n+=2)),i=i.times(l),s=o.plus(i.div(n+=2)),s.d[t]!==void 0)<span class="cstat-no" title="statement not covered" >for(e=t;s.d[e]===o.d[e]&amp;&amp;e--;);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r&amp;&amp;(s=s.times(2&lt;&lt;r-1)),_=!0,I(s,g.precision=h,g.rounding=v,!0)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.isFinite=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!!this.d};<span class="cstat-no" title="statement not covered" >C</span></span>.isInteger=C.isInt=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!!this.d&amp;&amp;Z(this.e/O)&gt;this.d.length-2}</span>;<span class="cstat-no" title="statement not covered" >C</span>.isNaN=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!this.s};<span class="cstat-no" title="statement not covered" >C</span></span>.isNegative=C.isNeg=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.s&lt;0}</span>;<span class="cstat-no" title="statement not covered" >C</span>.isPositive=C.isPos=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.s&gt;0}</span>;<span class="cstat-no" title="statement not covered" >C</span>.isZero=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn!!this.d&amp;&amp;this.d[0]===0}</span>;<span class="cstat-no" title="statement not covered" >C</span>.lessThan=C.lt=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;0}</span>;<span class="cstat-no" title="statement not covered" >C</span>.lessThanOrEqualTo=C.lte=<span class="fstat-no" title="function not covered" >function(e</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(e)&lt;1}</span>;<span class="cstat-no" title="statement not covered" >C</span>.logarithm=C.log=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r,n,i,o,s,a,l,d=<span class="cstat-no" title="statement not covered" >this,</span>g=<span class="cstat-no" title="statement not covered" >d.constructor,</span>h=<span class="cstat-no" title="statement not covered" >g.precision,</span>v=<span class="cstat-no" title="statement not covered" >g.rounding,</span>S=<span class="cstat-no" title="statement not covered" >5;<span class="cstat-no" title="statement not covered" >i</span>f(e==null)<span class="cstat-no" title="statement not covered" >e=new g(10),t=!0;else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e=new g(e),r=e.d,e.s&lt;0||!r||!r[0]||e.eq(1))<span class="cstat-no" title="statement not covered" >return new g(NaN);<span class="cstat-no" title="statement not covered" >t</span></span>=e.eq(10)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(r=d.d,d.s&lt;0||!r||!r[0]||d.eq(1))<span class="cstat-no" title="statement not covered" >return new g(r&amp;&amp;!r[0]?-1/0:d.s!=1?NaN:r?0:1/0);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t)<span class="cstat-no" title="statement not covered" >if(r.length&gt;1)<span class="cstat-no" title="statement not covered" >o=!0;else{<span class="cstat-no" title="statement not covered" ></span>for(i=r[0];i%10===0;)<span class="cstat-no" title="statement not covered" >i/=10;<span class="cstat-no" title="statement not covered" >o</span></span>=i!==1}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span></span>f(_=!1,a=h+S,s=ke(d,a),n=t?Er(g,a+10):ke(e,a),l=q(s,n,a,1),Tt(l.d,i=h,v))<span class="cstat-no" title="statement not covered" >do <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(a+=10,s=ke(d,a),n=t?Er(g,a+10):ke(e,a),l=q(s,n,a,1),!o){<span class="cstat-no" title="statement not covered" >+K(l.d).slice(i+1,i+15)+1==1e14&amp;&amp;(l=I(l,h+1,0));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>while(T</span>t(l.d,i+=10,v));<span class="cstat-no" title="statement not covered" >r</span></span>eturn _=!0,I(l,h,v)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.minus=C.sub=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r,n,i,o,s,a,l,d,g,h,v,S=<span class="cstat-no" title="statement not covered" >this,</span>A=<span class="cstat-no" title="statement not covered" >S.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e=new A(e),!S.d||!e.d)<span class="cstat-no" title="statement not covered" >return!S.s||!e.s?e=new A(NaN):S.d?e.s=-e.s:e=new A(e.d||S.s!==e.s?S:NaN),e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(S.s!=e.s)<span class="cstat-no" title="statement not covered" >return e.s=-e.s,S.plus(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(d=S.d,v=e.d,a=A.precision,l=A.rounding,!d[0]||!v[0]){<span class="cstat-no" title="statement not covered" >if(v[0])<span class="cstat-no" title="statement not covered" >e.s=-e.s;else <span class="cstat-no" title="statement not covered" >i</span>f(d[0])<span class="cstat-no" title="statement not covered" >e=new A(S);else <span class="cstat-no" title="statement not covered" >r</span>eturn new A(l===3?-0:0);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn _?I(e,a,l):e}<span class="cstat-no" title="statement not covered" ></span>i</span>f(r=Z(e.e/O),g=Z(S.e/O),d=d.slice(),o=g-r,o){<span class="cstat-no" title="statement not covered" >for(h=o&lt;0,h?(t=d,o=-o,s=v.length):(t=v,r=g,s=d.length),n=Math.max(Math.ceil(a/O),s)+2,o&gt;n&amp;&amp;(o=n,t.length=1),t.reverse(),n=o;n--;)<span class="cstat-no" title="statement not covered" >t.push(0);<span class="cstat-no" title="statement not covered" >t</span></span>.reverse()}</span>else{<span class="cstat-no" title="statement not covered" >for(n=d.length,s=v.length,h=n&lt;s,h&amp;&amp;(s=n),n=0;n&lt;s;n++)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(d[n]!=v[n]){<span class="cstat-no" title="statement not covered" >h=d[n]&lt;v[n];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>o</span></span>=0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(h&amp;&amp;(t=d,d=v,v=t,e.s=-e.s),s=d.length,n=v.length-s;n&gt;0;--n)<span class="cstat-no" title="statement not covered" >d[s++]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=v.length;n&gt;o;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(d[--n]&lt;v[n]){<span class="cstat-no" title="statement not covered" >for(i=n;i&amp;&amp;d[--i]===0;)<span class="cstat-no" title="statement not covered" >d[i]=ce-1;<span class="cstat-no" title="statement not covered" >-</span></span>-d[i],d[n]+=ce}<span class="cstat-no" title="statement not covered" ></span>d</span>[n]-=v[n]}<span class="cstat-no" title="statement not covered" >f</span></span>or(;d[--s]===0;)<span class="cstat-no" title="statement not covered" >d.pop();<span class="cstat-no" title="statement not covered" >f</span></span>or(;d[0]===0;d.shift())<span class="cstat-no" title="statement not covered" >--r;<span class="cstat-no" title="statement not covered" >r</span></span>eturn d[0]?(e.d=d,e.e=xr(d,r),_?I(e,a,l):e):new A(l===3?-0:0)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.modulo=C.mod=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return e=new n(e),!r.d||!e.s||e.d&amp;&amp;!e.d[0]?new n(NaN):!e.d||r.d&amp;&amp;!r.d[0]?I(new n(r),n.precision,n.rounding):(_=!1,n.modulo==9?(t=q(r,e.abs(),0,3,1),t.s*=e.s):t=q(r,e,0,n.modulo,1),t=t.times(e),_=!0,r.minus(t))}</span>;<span class="cstat-no" title="statement not covered" >C</span>.naturalExponential=C.exp=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn bn(this)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.naturalLogarithm=C.ln=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn ke(this)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.negated=C.neg=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" >r</span>eturn e.s=-e.s,I(e)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.plus=C.add=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r,n,i,o,s,a,l,d,g,h=<span class="cstat-no" title="statement not covered" >this,</span>v=<span class="cstat-no" title="statement not covered" >h.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e=new v(e),!h.d||!e.d)<span class="cstat-no" title="statement not covered" >return!h.s||!e.s?e=new v(NaN):h.d||(e=new v(e.d||h.s===e.s?h:NaN)),e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(h.s!=e.s)<span class="cstat-no" title="statement not covered" >return e.s=-e.s,h.minus(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(d=h.d,g=e.d,a=v.precision,l=v.rounding,!d[0]||!g[0])<span class="cstat-no" title="statement not covered" >return g[0]||(e=new v(h)),_?I(e,a,l):e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(o=Z(h.e/O),n=Z(e.e/O),d=d.slice(),i=o-n,i){<span class="cstat-no" title="statement not covered" >for(i&lt;0?(r=d,i=-i,s=g.length):(r=g,n=o,s=d.length),o=Math.ceil(a/O),s=o&gt;s?o+1:s+1,i&gt;s&amp;&amp;(i=s,r.length=1),r.reverse();i--;)<span class="cstat-no" title="statement not covered" >r.push(0);<span class="cstat-no" title="statement not covered" >r</span></span>.reverse()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(s=d.length,i=g.length,s-i&lt;0&amp;&amp;(i=s,r=g,g=d,d=r),t=0;i;)<span class="cstat-no" title="statement not covered" >t=(d[--i]=d[i]+g[i]+t)/ce|0,d[i]%=ce;<span class="cstat-no" title="statement not covered" >f</span></span>or(t&amp;&amp;(d.unshift(t),++n),s=d.length;d[--s]==0;)<span class="cstat-no" title="statement not covered" >d.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.d=d,e.e=xr(d,n),_?I(e,a,l):e}</span>;<span class="cstat-no" title="statement not covered" >C</span>.precision=C.sd=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e!==void 0&amp;&amp;e!==!!e&amp;&amp;e!==1&amp;&amp;e!==0)<span class="cstat-no" title="statement not covered" >throw Error(Ie+e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.d?(t=po(r.d),e&amp;&amp;r.e+1&gt;t&amp;&amp;(t=r.e+1)):t=NaN,t}</span>;<span class="cstat-no" title="statement not covered" >C</span>.round=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>return I(new t(e),e.e+1,t.rounding)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.sine=C.sin=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+Math.max(r.e,r.sd())+O,n.rounding=1,r=Al(n,ho(n,r)),n.precision=e,n.rounding=t,I(ve&gt;2?r.neg():r,e,t,!0)):new n(NaN)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.squareRoot=C.sqrt=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r,n,i,o,s=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >s.d,</span>l=<span class="cstat-no" title="statement not covered" >s.e,</span>d=<span class="cstat-no" title="statement not covered" >s.s,</span>g=<span class="cstat-no" title="statement not covered" >s.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(d!==1||!a||!a[0])<span class="cstat-no" title="statement not covered" >return new g(!d||d&lt;0&amp;&amp;(!a||a[0])?NaN:a?s:1/0);<span class="cstat-no" title="statement not covered" >f</span></span>or(_=!1,d=Math.sqrt(+s),d==0||d==1/0?(t=K(a),(t.length+l)%2==0&amp;&amp;(t+="0"),d=Math.sqrt(t),l=Z((l+1)/2)-(l&lt;0||l%2),d==1/0?t="5e"+l:(t=d.toExponential(),t=t.slice(0,t.indexOf("e")+1)+l),n=new g(t)):n=new g(d.toString()),r=(l=g.precision)+3;;)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o=n,n=o.plus(q(s,o,r+2,1)).times(.5),K(o.d).slice(0,r)===(t=K(n.d)).slice(0,r))<span class="cstat-no" title="statement not covered" >if(t=t.slice(r-3,r+1),t=="9999"||!i&amp;&amp;t=="4999"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!i&amp;&amp;(I(o,l+1,0),o.times(o).eq(s))){<span class="cstat-no" title="statement not covered" >n=o;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span>+=4,i=1}</span>else{(<span class="cstat-no" title="statement not covered" >!+t||!+t.slice(1)&amp;&amp;t.charAt(0)=="5")&amp;&amp;(I(n,l+1,1),e=!n.times(n).eq(s));<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn _=!0,I(n,l,g.rounding,e)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.tangent=C.tan=<span class="fstat-no" title="function not covered" >function(){v</span>ar e,t,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r.isFinite()?r.isZero()?new n(r):(e=n.precision,t=n.rounding,n.precision=e+10,n.rounding=1,r=r.sin(),r.s=1,r=q(r,new n(1).minus(r.times(r)).sqrt(),e+10,0),n.precision=e,n.rounding=t,I(ve==2||ve==4?r.neg():r,e,t,!0)):new n(NaN)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.times=C.mul=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r,n,i,o,s,a,l,d,g=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >g.constructor,</span>v=<span class="cstat-no" title="statement not covered" >g.d,</span>S=<span class="cstat-no" title="statement not covered" >(e=new h(e)).d;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e.s*=g.s,!v||!v[0]||!S||!S[0])<span class="cstat-no" title="statement not covered" >return new h(!e.s||v&amp;&amp;!v[0]&amp;&amp;!S||S&amp;&amp;!S[0]&amp;&amp;!v?NaN:!v||!S?e.s/0:e.s*0);<span class="cstat-no" title="statement not covered" >f</span></span>or(r=Z(g.e/O)+Z(e.e/O),l=v.length,d=S.length,l&lt;d&amp;&amp;(o=v,v=S,S=o,s=l,l=d,d=s),o=[],s=l+d,n=s;n--;)<span class="cstat-no" title="statement not covered" >o.push(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(n=d;--n&gt;=0;){<span class="cstat-no" title="statement not covered" >for(t=0,i=l+n;i&gt;n;)<span class="cstat-no" title="statement not covered" >a=o[i]+S[n]*v[i-n-1]+t,o[i--]=a%ce|0,t=a/ce|0;<span class="cstat-no" title="statement not covered" >o</span></span>[i]=(o[i]+t)%ce|0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;!o[--s];)<span class="cstat-no" title="statement not covered" >o.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn t?++r:o.shift(),e.d=o,e.e=xr(o,r),_?I(e,h.precision,h.rounding):e}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toBinary=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return xn(this,2,e,t)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toDecimalPlaces=C.toDP=<span class="fstat-no" title="function not covered" >function(e</span>,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r=new n(r),e===void 0?r:(re(e,0,Oe),t===void 0?t=n.rounding:re(t,0,8),I(r,e+r.e+1,t))}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toExponential=<span class="fstat-no" title="function not covered" >function(e</span>,t){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?r=ge(n,!0):(re(e,0,Oe),t===void 0?t=i.rounding:re(t,0,8),n=I(new i(n),e+1,t),r=ge(n,!0,e+1)),n.isNeg()&amp;&amp;!n.isZero()?"-"+r:r}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toFixed=<span class="fstat-no" title="function not covered" >function(e</span>,t){var r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?r=ge(i):(re(e,0,Oe),t===void 0?t=o.rounding:re(t,0,8),n=I(new o(i),e+i.e+1,t),r=ge(n,!1,e+n.e+1)),i.isNeg()&amp;&amp;!i.isZero()?"-"+r:r}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toFraction=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r,n,i,o,s,a,l,d,g,h,v,S=<span class="cstat-no" title="statement not covered" >this,</span>A=<span class="cstat-no" title="statement not covered" >S.d,</span>R=<span class="cstat-no" title="statement not covered" >S.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!A)<span class="cstat-no" title="statement not covered" >return new R(S);<span class="cstat-no" title="statement not covered" >i</span></span>f(d=r=new R(1),n=l=new R(0),t=new R(n),o=t.e=po(A)-S.e-1,s=o%O,t.d[0]=J(10,s&lt;0?O+s:s),e==null)<span class="cstat-no" title="statement not covered" >e=o&gt;0?t:d;else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(a=new R(e),!a.isInt()||a.lt(d))<span class="cstat-no" title="statement not covered" >throw Error(Ie+a);<span class="cstat-no" title="statement not covered" >e</span></span>=a.gt(t)?o&gt;0?t:d:a}<span class="cstat-no" title="statement not covered" ></span>f</span>or(_=!1,a=new R(K(A)),g=R.precision,R.precision=o=A.length*O*2;h=q(a,t,0,1,1),i=r.plus(h.times(n)),i.cmp(e)!=1;)<span class="cstat-no" title="statement not covered" >r=n,n=i,i=d,d=l.plus(h.times(i)),l=i,i=t,t=a.minus(h.times(i)),a=i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i=q(e.minus(r),n,0,1,1),l=l.plus(i.times(d)),r=r.plus(i.times(n)),l.s=d.s=S.s,v=q(d,n,o,1).minus(S).abs().cmp(q(l,r,o,1).minus(S).abs())&lt;1?[d,n]:[l,r],R.precision=g,_=!0,v}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toHexadecimal=C.toHex=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return xn(this,16,e,t)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toNearest=<span class="fstat-no" title="function not covered" >function(e</span>,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>if(r=new n(r),e==null){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!r.d)<span class="cstat-no" title="statement not covered" >return r;<span class="cstat-no" title="statement not covered" >e</span></span>=new n(1),t=n.rounding}else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e=new n(e),t===void 0?t=n.rounding:re(t,0,8),!r.d)<span class="cstat-no" title="statement not covered" >return e.s?r:e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!e.d)<span class="cstat-no" title="statement not covered" >return e.s&amp;&amp;(e.s=r.s),e}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e.d[0]?(_=!1,r=q(r,e,0,t,1).times(e),_=!0,I(r)):(e.s=r.s,r=e),r}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toNumber=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn+this};<span class="cstat-no" title="statement not covered" >C</span></span>.toOctal=<span class="fstat-no" title="function not covered" >function(e</span>,t){<span class="cstat-no" title="statement not covered" >return xn(this,8,e,t)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toPower=C.pow=<span class="fstat-no" title="function not covered" >function(e</span>){var t,r,n,i,o,s,a=<span class="cstat-no" title="statement not covered" >this,</span>l=<span class="cstat-no" title="statement not covered" >a.constructor,</span>d=<span class="cstat-no" title="statement not covered" >+(e=new l(e));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!a.d||!e.d||!a.d[0]||!e.d[0])<span class="cstat-no" title="statement not covered" >return new l(J(+a,d));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(a=new l(a),a.eq(1))<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n=l.precision,o=l.rounding,e.eq(1))<span class="cstat-no" title="statement not covered" >return I(a,n,o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t=Z(e.e/O),t&gt;=e.d.length-1&amp;&amp;(r=d&lt;0?-d:d)&lt;=Pl)<span class="cstat-no" title="statement not covered" >return i=mo(l,a,r,n),e.s&lt;0?new l(1).div(i):I(i,n,o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(s=a.s,s&lt;0){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&lt;e.d.length-1)<span class="cstat-no" title="statement not covered" >return new l(NaN);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f((e.d[t]&amp;1)==0&amp;&amp;(s=1),a.e==0&amp;&amp;a.d[0]==1&amp;&amp;a.d.length==1)<span class="cstat-no" title="statement not covered" >return a.s=s,a}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r=J(+a,d),t=r==0||!isFinite(r)?Z(d*(Math.log("0."+K(a.d))/Math.LN10+a.e+1)):new l(r+"").e,t&gt;l.maxE+1||t&lt;l.minE-1?new l(t&gt;0?s/0:0):(_=!1,l.rounding=a.s=1,r=Math.min(12,(t+"").length),i=bn(e.times(ke(a,n+r)),n),i.d&amp;&amp;(i=I(i,n+5,1),Tt(i.d,n,o)&amp;&amp;(t=n+10,i=I(bn(e.times(ke(a,t+r)),t),t+5,1),+K(i.d).slice(n+1,n+15)+1==1e14&amp;&amp;(i=I(i,n+1,0)))),i.s=s,_=!0,l.rounding=o,I(i,n,o))}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toPrecision=<span class="fstat-no" title="function not covered" >function(e</span>,t){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?r=ge(n,n.e&lt;=i.toExpNeg||n.e&gt;=i.toExpPos):(re(e,1,Oe),t===void 0?t=i.rounding:re(t,0,8),n=I(new i(n),e,t),r=ge(n,e&lt;=n.e||n.e&lt;=i.toExpNeg,e)),n.isNeg()&amp;&amp;!n.isZero()?"-"+r:r}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toSignificantDigits=C.toSD=<span class="fstat-no" title="function not covered" >function(e</span>,t){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return e===void 0?(e=n.precision,t=n.rounding):(re(e,1,Oe),t===void 0?t=n.rounding:re(t,0,8)),I(new n(r),e,t)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.toString=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor,</span>r=<span class="cstat-no" title="statement not covered" >ge(e,e.e&lt;=t.toExpNeg||e.e&gt;=t.toExpPos);<span class="cstat-no" title="statement not covered" >r</span>eturn e.isNeg()&amp;&amp;!e.isZero()?"-"+r:r}</span>;<span class="cstat-no" title="statement not covered" >C</span>.truncated=C.trunc=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn I(new this.constructor(this),this.e+1,1)}</span>;<span class="cstat-no" title="statement not covered" >C</span>.valueOf=C.toJSON=<span class="fstat-no" title="function not covered" >function(){v</span>ar e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >e.constructor,</span>r=<span class="cstat-no" title="statement not covered" >ge(e,e.e&lt;=t.toExpNeg||e.e&gt;=t.toExpPos);<span class="cstat-no" title="statement not covered" >r</span>eturn e.isNeg()?"-"+r:r}</span>;f</span>unction <span class="fstat-no" title="function not covered" >K(e</span>){var t,r,n,i=<span class="cstat-no" title="statement not covered" >e.length-1,o</span>=<span class="cstat-no" title="statement not covered" >"",s</span>=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>if(i&gt;0){<span class="cstat-no" title="statement not covered" >for(o+=s,t=1;t&lt;i;t++)<span class="cstat-no" title="statement not covered" >n=e[t]+"",r=O-n.length,r&amp;&amp;(o+=Se(r)),o+=n;<span class="cstat-no" title="statement not covered" >s</span></span>=e[t],n=s+"",r=O-n.length,r&amp;&amp;(o+=Se(r))}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s===0)<span class="cstat-no" title="statement not covered" >return"0";<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;s%10===0;)<span class="cstat-no" title="statement not covered" >s/=10;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o+s}</span>function <span class="fstat-no" title="function not covered" >re(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e!==~~e||e&lt;t||e&gt;r)<span class="cstat-no" title="statement not covered" >throw Error(Ie+e)}</span></span>function <span class="fstat-no" title="function not covered" >Tt(e</span>,t,r,n){var i,o,s,a;<span class="cstat-no" title="statement not covered" >for(o=e[0];o&gt;=10;o/=10)<span class="cstat-no" title="statement not covered" >--t;<span class="cstat-no" title="statement not covered" >r</span></span>eturn--t&lt;0?(t+=O,i=0):(i=Math.ceil((t+1)/O),t%=O),o=J(10,O-t),a=e[i]%o|0,n==null?t&lt;3?(t==0?a=a/100|0:t==1&amp;&amp;(a=a/10|0),s=r&lt;4&amp;&amp;a==99999||r&gt;3&amp;&amp;a==49999||a==5e4||a==0):s=(r&lt;4&amp;&amp;a+1==o||r&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/100|0)==J(10,t-2)-1||(a==o/2||a==0)&amp;&amp;(e[i+1]/o/100|0)==0:t&lt;4?(t==0?a=a/1e3|0:t==1?a=a/100|0:t==2&amp;&amp;(a=a/10|0),s=(n||r&lt;4)&amp;&amp;a==9999||!n&amp;&amp;r&gt;3&amp;&amp;a==4999):s=((n||r&lt;4)&amp;&amp;a+1==o||!n&amp;&amp;r&gt;3&amp;&amp;a+1==o/2)&amp;&amp;(e[i+1]/o/1e3|0)==J(10,t-3)-1,s}</span>function <span class="fstat-no" title="function not covered" >gr(e</span>,t,r){<span class="cstat-no" title="statement not covered" >for(var n,i=<span class="cstat-no" title="statement not covered" >[0],o</span>,s=<span class="cstat-no" title="statement not covered" >0,a</span>=<span class="cstat-no" title="statement not covered" >e.length;</span>s&lt;a;){<span class="cstat-no" title="statement not covered" >for(o=i.length;o--;)<span class="cstat-no" title="statement not covered" >i[o]*=t;<span class="cstat-no" title="statement not covered" >f</span></span>or(i[0]+=yn.indexOf(e.charAt(s++)),n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >i[n]&gt;r-1&amp;&amp;(i[n+1]===void 0&amp;&amp;(i[n+1]=0),i[n+1]+=i[n]/r|0,i[n]%=r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn i.reverse()}</span>function <span class="fstat-no" title="function not covered" >Tl(e</span>,t){var r,n,i;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.isZero())<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >n</span></span>=t.d.length,n&lt;32?(r=Math.ceil(n/3),i=(1/Pr(4,r)).toString()):(r=16,i="2.3283064365386962890625e-10"),e.precision+=r,t=et(e,1,t.times(i),new e(1));<span class="cstat-no" title="statement not covered" >f</span>or(var o=<span class="cstat-no" title="statement not covered" >r;o</span>--;){var s=<span class="cstat-no" title="statement not covered" >t.times(t);<span class="cstat-no" title="statement not covered" >t</span>=s.times(s).minus(s).times(8).plus(1)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.precision-=r,t}</span>var q=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(){f</span>unction <span class="fstat-no" title="function not covered" >e(n</span>,i,o){var s,a=<span class="cstat-no" title="statement not covered" >0,l</span>=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>for(n=n.slice();l--;)<span class="cstat-no" title="statement not covered" >s=n[l]*i+a,n[l]=s%o|0,a=s/o|0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn a&amp;&amp;n.unshift(a),n}</span>function <span class="fstat-no" title="function not covered" >t(n</span>,i,o,s){var a,l;<span class="cstat-no" title="statement not covered" >if(o!=s)<span class="cstat-no" title="statement not covered" >l=o&gt;s?1:-1;else <span class="cstat-no" title="statement not covered" >f</span>or(a=l=0;a&lt;o;a++)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n[a]!=i[a]){<span class="cstat-no" title="statement not covered" >l=n[a]&gt;i[a]?1:-1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn l}</span>function <span class="fstat-no" title="function not covered" >r(n</span>,i,o,s){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >0;o</span>--;)<span class="cstat-no" title="statement not covered" >n[o]-=a,a=n[o]&lt;i[o]?1:0,n[o]=a*s+n[o]-i[o];<span class="cstat-no" title="statement not covered" >f</span></span>or(;!n[0]&amp;&amp;n.length&gt;1;)<span class="cstat-no" title="statement not covered" >n.shift()}<span class="cstat-no" title="statement not covered" ></span></span>return <span class="fstat-no" title="function not covered" >function(n</span>,i,o,s,a,l){var d,g,h,v,S,A,R,D,M,B,k,F,ie,G,Zr,rr,Et,Xr,ue,nr,ir=<span class="cstat-no" title="statement not covered" >n.constructor,</span>en=<span class="cstat-no" title="statement not covered" >n.s==i.s?1:-1,z</span>=<span class="cstat-no" title="statement not covered" >n.d,</span>$=<span class="cstat-no" title="statement not covered" >i.d;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!z||!z[0]||!$||!$[0])<span class="cstat-no" title="statement not covered" >return new ir(!n.s||!i.s||(z?$&amp;&amp;z[0]==$[0]:!$)?NaN:z&amp;&amp;z[0]==0||!$?en*0:en/0);<span class="cstat-no" title="statement not covered" >f</span></span>or(l?(S=1,g=n.e-i.e):(l=ce,S=O,g=Z(n.e/S)-Z(i.e/S)),ue=$.length,Et=z.length,M=new ir(en),B=M.d=[],h=0;$[h]==(z[h]||0);h++);<span class="cstat-no" title="statement not covered" >i</span>f($[h]&gt;(z[h]||0)&amp;&amp;g--,o==null?(G=o=ir.precision,s=ir.rounding):a?G=o+(n.e-i.e)+1:G=o,G&lt;0)<span class="cstat-no" title="statement not covered" >B.push(1),A=!0;else{<span class="cstat-no" title="statement not covered" ></span>if(G=G/S+2|0,h=0,ue==1){<span class="cstat-no" title="statement not covered" >for(v=0,$=$[0],G++;(h&lt;Et||v)&amp;&amp;G--;h++)<span class="cstat-no" title="statement not covered" >Zr=v*l+(z[h]||0),B[h]=Zr/$|0,v=Zr%$|0;<span class="cstat-no" title="statement not covered" >A</span></span>=v||h&lt;Et}</span>else{<span class="cstat-no" title="statement not covered" >for(v=l/($[0]+1)|0,v&gt;1&amp;&amp;($=e($,v,l),z=e(z,v,l),ue=$.length,Et=z.length),rr=ue,k=z.slice(0,ue),F=k.length;F&lt;ue;)<span class="cstat-no" title="statement not covered" >k[F++]=0;<span class="cstat-no" title="statement not covered" >n</span></span>r=$.slice(),nr.unshift(0),Xr=$[0],$[1]&gt;=l/2&amp;&amp;++Xr;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >v=0,d=t($,k,ue,F),d&lt;0?(ie=k[0],ue!=F&amp;&amp;(ie=ie*l+(k[1]||0)),v=ie/Xr|0,v&gt;1?(v&gt;=l&amp;&amp;(v=l-1),R=e($,v,l),D=R.length,F=k.length,d=t(R,k,D,F),d==1&amp;&amp;(v--,r(R,ue&lt;D?nr:$,D,l))):(v==0&amp;&amp;(d=v=1),R=$.slice()),D=R.length,D&lt;F&amp;&amp;R.unshift(0),r(k,R,F,l),d==-1&amp;&amp;(F=k.length,d=t($,k,ue,F),d&lt;1&amp;&amp;(v++,r(k,ue&lt;F?nr:$,F,l))),F=k.length):d===0&amp;&amp;(v++,k=[0]),B[h++]=v,d&amp;&amp;k[0]?k[F++]=z[rr]||0:(k=[z[rr]],F=1);while((</span>rr++&lt;Et||k[0]!==void 0)&amp;&amp;G--);<span class="cstat-no" title="statement not covered" >A</span>=k[0]!==void 0}<span class="cstat-no" title="statement not covered" ></span>B</span>[0]||B.shift()}<span class="cstat-no" title="statement not covered" ></span>i</span>f(S==1)<span class="cstat-no" title="statement not covered" >M.e=g,so=A;else{<span class="cstat-no" title="statement not covered" ></span>for(h=1,v=B[0];v&gt;=10;v/=10)<span class="cstat-no" title="statement not covered" >h++;<span class="cstat-no" title="statement not covered" >M</span></span>.e=h+g*S-1,I(M,a?o+M.e+1:o,s,A)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn M}</span>}</span>();f</span>unction <span class="fstat-no" title="function not covered" >I(e</span>,t,r,n){var i,o,s,a,l,d,g,h,v,S=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>e:<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t!=null){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(h=e.d,!h)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=1,a=h[0];a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >i</span></span>f(o=t-i,o&lt;0)<span class="cstat-no" title="statement not covered" >o+=O,s=t,g=h[v=0],l=g/J(10,i-s-1)%10|0;else <span class="cstat-no" title="statement not covered" >i</span>f(v=Math.ceil((o+1)/O),a=h.length,v&gt;=a)<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" >for(;a++&lt;=v;)<span class="cstat-no" title="statement not covered" >h.push(0);<span class="cstat-no" title="statement not covered" >g</span></span>=l=0,i=1,o%=O,s=o-O+1}</span>else <span class="cstat-no" title="statement not covered" >break e;else{<span class="cstat-no" title="statement not covered" ></span></span>for(g=a=h[v],i=1;a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >i++;<span class="cstat-no" title="statement not covered" >o</span></span>%=O,s=o-O+i,l=s&lt;0?0:g/J(10,i-s-1)%10|0}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span></span>f(n=n||t&lt;0||h[v+1]!==void 0||(s&lt;0?g:g%J(10,i-s-1)),d=r&lt;4?(l||n)&amp;&amp;(r==0||r==(e.s&lt;0?3:2)):l&gt;5||l==5&amp;&amp;(r==4||n||r==6&amp;&amp;(o&gt;0?s&gt;0?g/J(10,i-s):0:h[v-1])%10&amp;1||r==(e.s&lt;0?8:7)),t&lt;1||!h[0])<span class="cstat-no" title="statement not covered" >return h.length=0,d?(t-=e.e+1,h[0]=J(10,(O-t%O)%O),e.e=-t||0):h[0]=e.e=0,e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(o==0?(h.length=v,a=1,v--):(h.length=v+1,a=J(10,O-o),h[v]=s&gt;0?(g/J(10,i-s)%J(10,s)|0)*a:0),d)<span class="cstat-no" title="statement not covered" >for(;;)<span class="cstat-no" title="statement not covered" >if(v==0){<span class="cstat-no" title="statement not covered" >for(o=1,s=h[0];s&gt;=10;s/=10)<span class="cstat-no" title="statement not covered" >o++;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=h[0]+=a,a=1;s&gt;=10;s/=10)<span class="cstat-no" title="statement not covered" >a++;<span class="cstat-no" title="statement not covered" >o</span></span>!=a&amp;&amp;(e.e++,h[0]==ce&amp;&amp;(h[0]=1));<span class="cstat-no" title="statement not covered" >b</span>reak}</span>else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(h[v]+=a,h[v]!=ce)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >h</span></span>[v--]=0,a=1}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(o=h.length;h[--o]===0;)<span class="cstat-no" title="statement not covered" >h.pop()}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn _&amp;&amp;(e.e&gt;S.maxE?(e.d=null,e.e=NaN):e.e&lt;S.minE&amp;&amp;(e.e=0,e.d=[0])),e}</span>function <span class="fstat-no" title="function not covered" >ge(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e.isFinite())<span class="cstat-no" title="statement not covered" >return go(e);v</span></span>ar n,i=<span class="cstat-no" title="statement not covered" >e.e,</span>o=<span class="cstat-no" title="statement not covered" >K(e.d),s</span>=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ></span>return t?(r&amp;&amp;(n=r-s)&gt;0?o=o.charAt(0)+"."+o.slice(1)+Se(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(e.e&lt;0?"e":"e+")+e.e):i&lt;0?(o="0."+Se(-i-1)+o,r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(o+=Se(n))):i&gt;=s?(o+=Se(i+1-s),r&amp;&amp;(n=r-i-1)&gt;0&amp;&amp;(o=o+"."+Se(n))):((n=i+1)&lt;s&amp;&amp;(o=o.slice(0,n)+"."+o.slice(n)),r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=Se(n))),o}</span>function <span class="fstat-no" title="function not covered" >xr(e</span>,t){var r=<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>for(t*=O;r&gt;=10;r/=10)<span class="cstat-no" title="statement not covered" >t++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Er(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&gt;vl)<span class="cstat-no" title="statement not covered" >throw _=!0,r&amp;&amp;(e.precision=r),Error(ao);<span class="cstat-no" title="statement not covered" >r</span></span>eturn I(new e(yr),t,1,!0)}</span>function <span class="fstat-no" title="function not covered" >de(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&gt;En)<span class="cstat-no" title="statement not covered" >throw Error(ao);<span class="cstat-no" title="statement not covered" >r</span></span>eturn I(new e(wr),t,r,!0)}</span>function <span class="fstat-no" title="function not covered" >po(e</span>){var t=<span class="cstat-no" title="statement not covered" >e.length-1,r</span>=<span class="cstat-no" title="statement not covered" >t*O+1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t=e[t],t){<span class="cstat-no" title="statement not covered" >for(;t%10==0;t/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >f</span></span>or(t=e[0];t&gt;=10;t/=10)<span class="cstat-no" title="statement not covered" >r++}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Se(e</span>){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >"";e</span>--;)<span class="cstat-no" title="statement not covered" >t+="0";<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >mo(e</span>,t,r,n){var i,o=<span class="cstat-no" title="statement not covered" >new e(1),s</span>=<span class="cstat-no" title="statement not covered" >Math.ceil(n/O+4);<span class="cstat-no" title="statement not covered" >f</span>or(_=!1;;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r%2&amp;&amp;(o=o.times(t),io(o.d,s)&amp;&amp;(i=!0)),r=Z(r/2),r===0){<span class="cstat-no" title="statement not covered" >r=o.d.length-1,i&amp;&amp;o.d[r]===0&amp;&amp;++o.d[r];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>t</span>=t.times(t),io(t.d,s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _=!0,o}</span>function <span class="fstat-no" title="function not covered" >no(e</span>){<span class="cstat-no" title="statement not covered" >return e.d[e.d.length-1]&amp;1}</span>function <span class="fstat-no" title="function not covered" >fo(e</span>,t,r){<span class="cstat-no" title="statement not covered" >for(var n,i,o=<span class="cstat-no" title="statement not covered" >new e(t[0]),s</span>=<span class="cstat-no" title="statement not covered" >0;+</span>+s&lt;t.length;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i=new e(t[s]),!i.s){<span class="cstat-no" title="statement not covered" >o=i;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>n</span>=o.cmp(i),(n===r||n===0&amp;&amp;o.s===r)&amp;&amp;(o=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >bn(e</span>,t){var r,n,i,o,s,a,l,d=<span class="cstat-no" title="statement not covered" >0,g</span>=<span class="cstat-no" title="statement not covered" >0,h</span>=<span class="cstat-no" title="statement not covered" >0,v</span>=<span class="cstat-no" title="statement not covered" >e.constructor,</span>S=<span class="cstat-no" title="statement not covered" >v.rounding,</span>A=<span class="cstat-no" title="statement not covered" >v.precision;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!e.d||!e.d[0]||e.e&gt;17)<span class="cstat-no" title="statement not covered" >return new v(e.d?e.d[0]?e.s&lt;0?0:1/0:1:e.s?e.s&lt;0?0:e:NaN);<span class="cstat-no" title="statement not covered" >f</span></span>or(t==null?(_=!1,l=A):l=t,a=new v(.03125);e.e&gt;-2;)<span class="cstat-no" title="statement not covered" >e=e.times(a),h+=5;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=Math.log(J(2,h))/Math.LN10*2+5|0,l+=n,r=o=s=new v(1),v.precision=l;;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o=I(o.times(e),l,1),r=r.times(++g),a=s.plus(q(o,r,l,1)),K(a.d).slice(0,l)===K(s.d).slice(0,l)){<span class="cstat-no" title="statement not covered" >for(i=h;i--;)<span class="cstat-no" title="statement not covered" >s=I(s.times(s),l,1);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==null)<span class="cstat-no" title="statement not covered" >if(d&lt;3&amp;&amp;Tt(s.d,l-n,S,d))<span class="cstat-no" title="statement not covered" >v.precision=l+=10,r=o=a=new v(1),g=0,d++;else <span class="cstat-no" title="statement not covered" >r</span>eturn I(s,v.precision=A,S,_=!0);else <span class="cstat-no" title="statement not covered" >r</span></span>eturn v.precision=A,s}<span class="cstat-no" title="statement not covered" ></span></span>s</span>=a}</span>}</span>function <span class="fstat-no" title="function not covered" >ke(e</span>,t){var r,n,i,o,s,a,l,d,g,h,v,S=<span class="cstat-no" title="statement not covered" >1,A</span>=<span class="cstat-no" title="statement not covered" >10,R</span>=<span class="cstat-no" title="statement not covered" >e,D</span>=<span class="cstat-no" title="statement not covered" >R.d,</span>M=<span class="cstat-no" title="statement not covered" >R.constructor,</span>B=<span class="cstat-no" title="statement not covered" >M.rounding,</span>k=<span class="cstat-no" title="statement not covered" >M.precision;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(R.s&lt;0||!D||!D[0]||!R.e&amp;&amp;D[0]==1&amp;&amp;D.length==1)<span class="cstat-no" title="statement not covered" >return new M(D&amp;&amp;!D[0]?-1/0:R.s!=1?NaN:D?0:R);<span class="cstat-no" title="statement not covered" >i</span></span>f(t==null?(_=!1,g=k):g=t,M.precision=g+=A,r=K(D),n=r.charAt(0),Math.abs(o=R.e)&lt;15e14){<span class="cstat-no" title="statement not covered" >for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;r.charAt(1)&gt;3;)<span class="cstat-no" title="statement not covered" >R=R.times(e),r=K(R.d),n=r.charAt(0),S++;<span class="cstat-no" title="statement not covered" >o</span></span>=R.e,n&gt;1?(R=new M("0."+r),o++):R=new M(n+"."+r.slice(1))}</span>else <span class="cstat-no" title="statement not covered" >return d=Er(M,g+2,k).times(o+""),R=ke(new M(n+"."+r.slice(1)),g-A).plus(d),M.precision=k,t==null?I(R,k,B,_=!0):R;<span class="cstat-no" title="statement not covered" >f</span></span>or(h=R,l=s=R=q(R.minus(1),R.plus(1),g,1),v=I(R.times(R),g,1),i=3;;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s=I(s.times(v),g,1),d=l.plus(q(s,new M(i),g,1)),K(d.d).slice(0,g)===K(l.d).slice(0,g))<span class="cstat-no" title="statement not covered" >if(l=l.times(2),o!==0&amp;&amp;(l=l.plus(Er(M,g+2,k).times(o+""))),l=q(l,new M(S),g,1),t==null)<span class="cstat-no" title="statement not covered" >if(Tt(l.d,g-A,B,a))<span class="cstat-no" title="statement not covered" >M.precision=g+=A,d=s=R=q(h.minus(1),h.plus(1),g,1),v=I(R.times(R),g,1),i=a=1;else <span class="cstat-no" title="statement not covered" >r</span>eturn I(l,M.precision=k,B,_=!0);else <span class="cstat-no" title="statement not covered" >r</span></span>eturn M.precision=k,l;<span class="cstat-no" title="statement not covered" >l</span></span></span>=d,i+=2}</span>}</span>function <span class="fstat-no" title="function not covered" >go(e</span>){<span class="cstat-no" title="statement not covered" >return String(e.s*e.s/0)}</span>function <span class="fstat-no" title="function not covered" >hr(e</span>,t){var r,n,i;<span class="cstat-no" title="statement not covered" >for((r=t.indexOf("."))&gt;-1&amp;&amp;(t=t.replace(".","")),(n=t.search(/e/i))&gt;0?(r&lt;0&amp;&amp;(r=n),r+=+t.slice(n+1),t=t.substring(0,n)):r&lt;0&amp;&amp;(r=t.length),n=0;t.charCodeAt(n)===48;n++);<span class="cstat-no" title="statement not covered" >f</span>or(i=t.length;t.charCodeAt(i-1)===48;--i);<span class="cstat-no" title="statement not covered" >i</span>f(t=t.slice(n,i),t){<span class="cstat-no" title="statement not covered" >if(i-=n,e.e=r=r-n-1,e.d=[],n=(r+1)%O,r&lt;0&amp;&amp;(n+=O),n&lt;i){<span class="cstat-no" title="statement not covered" >for(n&amp;&amp;e.d.push(+t.slice(0,n)),i-=O;n&lt;i;)<span class="cstat-no" title="statement not covered" >e.d.push(+t.slice(n,n+=O));<span class="cstat-no" title="statement not covered" >t</span></span>=t.slice(n),n=O-t.length}else <span class="cstat-no" title="statement not covered" >n</span>-=i;<span class="cstat-no" title="statement not covered" >f</span></span>or(;n--;)<span class="cstat-no" title="statement not covered" >t+="0";<span class="cstat-no" title="statement not covered" >e</span></span>.d.push(+t),_&amp;&amp;(e.e&gt;e.constructor.maxE?(e.d=null,e.e=NaN):e.e&lt;e.constructor.minE&amp;&amp;(e.e=0,e.d=[0]))}</span>else <span class="cstat-no" title="statement not covered" >e.e=0,e.d=[0];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Cl(e</span>,t){var r,n,i,o,s,a,l,d,g;<span class="cstat-no" title="statement not covered" >if(t.indexOf("_")&gt;-1){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t=t.replace(/(\d)_(?=\d)/g,"$1"),co.test(t))<span class="cstat-no" title="statement not covered" >return hr(e,t)}</span></span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t==="Infinity"||t==="NaN")<span class="cstat-no" title="statement not covered" >return+t||(e.s=NaN),e.e=NaN,e.d=null,e;<span class="cstat-no" title="statement not covered" >i</span></span></span>f(bl.test(t))<span class="cstat-no" title="statement not covered" >r=16,t=t.toLowerCase();else <span class="cstat-no" title="statement not covered" >i</span>f(El.test(t))<span class="cstat-no" title="statement not covered" >r=2;else <span class="cstat-no" title="statement not covered" >i</span>f(xl.test(t))<span class="cstat-no" title="statement not covered" >r=8;else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(Ie+t);<span class="cstat-no" title="statement not covered" >f</span></span></span></span>or(o=t.search(/p/i),o&gt;0?(l=+t.slice(o+1),t=t.substring(2,o)):t=t.slice(2),o=t.indexOf("."),s=o&gt;=0,n=e.constructor,s&amp;&amp;(t=t.replace(".",""),a=t.length,o=a-o,i=mo(n,new n(r),o,o*2)),d=gr(t,r,ce),g=d.length-1,o=g;d[o]===0;--o)<span class="cstat-no" title="statement not covered" >d.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn o&lt;0?new n(e.s*0):(e.e=xr(d,g),e.d=d,_=!1,s&amp;&amp;(e=q(e,i,a*4)),l&amp;&amp;(e=e.times(Math.abs(l)&lt;54?J(2,l):Be.pow(2,l))),_=!0,e)}</span>function <span class="fstat-no" title="function not covered" >Al(e</span>,t){var r,n=<span class="cstat-no" title="statement not covered" >t.d.length;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(n&lt;3)<span class="cstat-no" title="statement not covered" >return t.isZero()?t:et(e,2,t,t);<span class="cstat-no" title="statement not covered" >r</span></span>=1.4*Math.sqrt(n),r=r&gt;16?16:r|0,t=t.times(1/Pr(5,r)),t=et(e,2,t,t);<span class="cstat-no" title="statement not covered" >f</span>or(var i,o=<span class="cstat-no" title="statement not covered" >new e(5),s</span>=<span class="cstat-no" title="statement not covered" >new e(16),a</span>=<span class="cstat-no" title="statement not covered" >new e(20);r</span>--;)<span class="cstat-no" title="statement not covered" >i=t.times(t),t=t.times(o.plus(i.times(s.times(i).minus(a))));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >et(e</span>,t,r,n,i){var o,s,a,l,d=<span class="cstat-no" title="statement not covered" >1,g</span>=<span class="cstat-no" title="statement not covered" >e.precision,</span>h=<span class="cstat-no" title="statement not covered" >Math.ceil(g/O);<span class="cstat-no" title="statement not covered" >f</span>or(_=!1,l=r.times(r),a=new e(n);;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s=q(a.times(l),new e(t++*t++),g,1),a=i?n.plus(s):n.minus(s),n=q(s.times(l),new e(t++*t++),g,1),s=a.plus(n),s.d[h]!==void 0){<span class="cstat-no" title="statement not covered" >for(o=h;s.d[o]===a.d[o]&amp;&amp;o--;);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o==-1)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>o</span>=a,a=n,n=s,s=o,d++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn _=!0,s.d.length=h+1,s}</span>function <span class="fstat-no" title="function not covered" >Pr(e</span>,t){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >e;-</span>-t;)<span class="cstat-no" title="statement not covered" >r*=e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >ho(e</span>,t){var r,n=<span class="cstat-no" title="statement not covered" >t.s&lt;0,i</span>=<span class="cstat-no" title="statement not covered" >de(e,e.precision,1),o</span>=<span class="cstat-no" title="statement not covered" >i.times(.5);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t=t.abs(),t.lte(o))<span class="cstat-no" title="statement not covered" >return ve=n?4:1,t;<span class="cstat-no" title="statement not covered" >i</span></span>f(r=t.divToInt(i),r.isZero())<span class="cstat-no" title="statement not covered" >ve=n?3:2;else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(t=t.minus(r.times(i)),t.lte(o))<span class="cstat-no" title="statement not covered" >return ve=no(r)?n?2:3:n?4:1,t;<span class="cstat-no" title="statement not covered" >v</span></span>e=no(r)?n?1:4:n?3:2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t.minus(i).abs()}</span>function <span class="fstat-no" title="function not covered" >xn(e</span>,t,r,n){var i,o,s,a,l,d,g,h,v,S=<span class="cstat-no" title="statement not covered" >e.constructor,</span>A=<span class="cstat-no" title="statement not covered" >r!==void 0;<span class="cstat-no" title="statement not covered" >i</span>f(A?(re(r,1,Oe),n===void 0?n=S.rounding:re(n,0,8)):(r=S.precision,n=S.rounding),!e.isFinite())<span class="cstat-no" title="statement not covered" >g=go(e);else{<span class="cstat-no" title="statement not covered" ></span>for(g=ge(e),s=g.indexOf("."),A?(i=2,t==16?r=r*4-3:t==8&amp;&amp;(r=r*3-2)):i=t,s&gt;=0&amp;&amp;(g=g.replace(".",""),v=new S(1),v.e=g.length-s,v.d=gr(ge(v),10,i),v.e=v.d.length),h=gr(g,10,i),o=l=h.length;h[--l]==0;)<span class="cstat-no" title="statement not covered" >h.pop();<span class="cstat-no" title="statement not covered" >i</span></span>f(!h[0])<span class="cstat-no" title="statement not covered" >g=A?"0p+0":"0";else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(s&lt;0?o--:(e=new S(e),e.d=h,e.e=o,e=q(e,v,r,n,0,i),h=e.d,o=e.e,d=so),s=h[r],a=i/2,d=d||h[r+1]!==void 0,d=n&lt;4?(s!==void 0||d)&amp;&amp;(n===0||n===(e.s&lt;0?3:2)):s&gt;a||s===a&amp;&amp;(n===4||d||n===6&amp;&amp;h[r-1]&amp;1||n===(e.s&lt;0?8:7)),h.length=r,d)<span class="cstat-no" title="statement not covered" >for(;++h[--r]&gt;i-1;)<span class="cstat-no" title="statement not covered" >h[r]=0,r||(++o,h.unshift(1));<span class="cstat-no" title="statement not covered" >f</span></span></span>or(l=h.length;!h[l-1];--l);<span class="cstat-no" title="statement not covered" >f</span>or(s=0,g="";s&lt;l;s++)<span class="cstat-no" title="statement not covered" >g+=yn.charAt(h[s]);<span class="cstat-no" title="statement not covered" >i</span></span>f(A){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(l&gt;1)<span class="cstat-no" title="statement not covered" >if(t==16||t==8){<span class="cstat-no" title="statement not covered" >for(s=t==16?4:3,--l;l%s;l++)<span class="cstat-no" title="statement not covered" >g+="0";<span class="cstat-no" title="statement not covered" >f</span></span>or(h=gr(g,i,t),l=h.length;!h[l-1];--l);<span class="cstat-no" title="statement not covered" >f</span>or(s=1,g="1.";s&lt;l;s++)<span class="cstat-no" title="statement not covered" >g+=yn.charAt(h[s])}</span></span>else <span class="cstat-no" title="statement not covered" >g=g.charAt(0)+"."+g.slice(1);<span class="cstat-no" title="statement not covered" >g</span></span></span>=g+(o&lt;0?"p":"p+")+o}</span>else <span class="cstat-no" title="statement not covered" >if(o&lt;0){<span class="cstat-no" title="statement not covered" >for(;++o;)<span class="cstat-no" title="statement not covered" >g="0"+g;<span class="cstat-no" title="statement not covered" >g</span></span>="0."+g}</span>else <span class="cstat-no" title="statement not covered" >if(++o&gt;l)<span class="cstat-no" title="statement not covered" >for(o-=l;o--;)<span class="cstat-no" title="statement not covered" >g+="0";else <span class="cstat-no" title="statement not covered" >o</span></span>&lt;l&amp;&amp;(g=g.slice(0,o)+"."+g.slice(o))}<span class="cstat-no" title="statement not covered" ></span></span></span></span>g</span>=(t==16?"0x":t==2?"0b":t==8?"0o":"")+g}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e.s&lt;0?"-"+g:g}</span>function <span class="fstat-no" title="function not covered" >io(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length&gt;t)<span class="cstat-no" title="statement not covered" >return e.length=t,!0}</span></span>function <span class="fstat-no" title="function not covered" >Rl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).abs()}</span>function <span class="fstat-no" title="function not covered" >Sl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).acos()}</span>function <span class="fstat-no" title="function not covered" >kl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).acosh()}</span>function <span class="fstat-no" title="function not covered" >Il(e</span>,t){<span class="cstat-no" title="statement not covered" >return new this(e).plus(t)}</span>function <span class="fstat-no" title="function not covered" >Ol(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).asin()}</span>function <span class="fstat-no" title="function not covered" >Dl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).asinh()}</span>function <span class="fstat-no" title="function not covered" >Ml(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).atan()}</span>function <span class="fstat-no" title="function not covered" >_l(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).atanh()}</span>function <span class="fstat-no" title="function not covered" >Nl(e</span>,t){<span class="cstat-no" title="statement not covered" >e=new this(e),t=new this(t);v</span>ar r,n=<span class="cstat-no" title="statement not covered" >this.precision,</span>i=<span class="cstat-no" title="statement not covered" >this.rounding,</span>o=<span class="cstat-no" title="statement not covered" >n+4;<span class="cstat-no" title="statement not covered" >r</span>eturn!e.s||!t.s?r=new this(NaN):!e.d&amp;&amp;!t.d?(r=de(this,o,1).times(t.s&gt;0?.25:.75),r.s=e.s):!t.d||e.isZero()?(r=t.s&lt;0?de(this,n,i):new this(0),r.s=e.s):!e.d||t.isZero()?(r=de(this,o,1).times(.5),r.s=e.s):t.s&lt;0?(this.precision=o,this.rounding=1,r=this.atan(q(e,t,o,1)),t=de(this,o,1),this.precision=n,this.rounding=i,r=e.s&lt;0?r.minus(t):r.plus(t)):r=this.atan(q(e,t,o,1)),r}</span>function <span class="fstat-no" title="function not covered" >Fl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).cbrt()}</span>function <span class="fstat-no" title="function not covered" >Ll(e</span>){<span class="cstat-no" title="statement not covered" >return I(e=new this(e),e.e+1,2)}</span>function <span class="fstat-no" title="function not covered" >Bl(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return new this(e).clamp(t,r)}</span>function <span class="fstat-no" title="function not covered" >Ul(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e||typeof e!="object")<span class="cstat-no" title="statement not covered" >throw Error(br+"Object expected");v</span></span>ar t,r,n,i=<span class="cstat-no" title="statement not covered" >e.defaults===!0,o</span>=<span class="cstat-no" title="statement not covered" >["precision",1,Oe,"rounding",0,8,"toExpNeg",-Xe,0,"toExpPos",0,Xe,"maxE",0,Xe,"minE",-Xe,0,"modulo",0,9];<span class="cstat-no" title="statement not covered" >f</span>or(t=0;t&lt;o.length;t+=3)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r=o[t],i&amp;&amp;(this[r]=wn[r]),(n=e[r])!==void 0)<span class="cstat-no" title="statement not covered" >if(Z(n)===n&amp;&amp;n&gt;=o[t+1]&amp;&amp;n&lt;=o[t+2])<span class="cstat-no" title="statement not covered" >this[r]=n;else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(Ie+r+": "+n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span></span>f(r="crypto",i&amp;&amp;(this[r]=wn[r]),(n=e[r])!==void 0)<span class="cstat-no" title="statement not covered" >if(n===!0||n===!1||n===0||n===1)<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >if(typeof crypto&lt;"u"&amp;&amp;crypto&amp;&amp;(crypto.getRandomValues||crypto.randomBytes))<span class="cstat-no" title="statement not covered" >this[r]=!0;else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(lo);else <span class="cstat-no" title="statement not covered" >t</span></span>his[r]=!1;else <span class="cstat-no" title="statement not covered" >t</span></span>hrow Error(Ie+r+": "+n);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}f</span>unction <span class="fstat-no" title="function not covered" >ql(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).cos()}</span>function <span class="fstat-no" title="function not covered" >$l(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).cosh()}</span>function <span class="fstat-no" title="function not covered" >yo(e</span>){var t,r,n;function <span class="fstat-no" title="function not covered" >i(o</span>){var s,a,l,d=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!(d instanceof i))<span class="cstat-no" title="statement not covered" >return new i(o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(d.constructor=i,oo(o)){<span class="cstat-no" title="statement not covered" >d.s=o.s,_?!o.d||o.e&gt;i.maxE?(d.e=NaN,d.d=null):o.e&lt;i.minE?(d.e=0,d.d=[0]):(d.e=o.e,d.d=o.d.slice()):(d.e=o.e,d.d=o.d?o.d.slice():o.d</span>);<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(l=typeof o,l==="number"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o===0){<span class="cstat-no" title="statement not covered" >d.s=1/o&lt;0?-1:1,d.e=0,d.d=[0];<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(o&lt;0?(o=-o,d.s=-1):d.s=1,o===~~o&amp;&amp;o&lt;1e7){<span class="cstat-no" title="statement not covered" >for(s=0,a=o;a&gt;=10;a/=10)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >_</span></span>?s&gt;i.maxE?(d.e=NaN,d.d=null):s&lt;i.minE?(d.e=0,d.d=[0]):(d.e=s,d.d=[o]):(d.e=s,d.d=[o]</span>);<span class="cstat-no" title="statement not covered" >return}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(o*0!==0){<span class="cstat-no" title="statement not covered" >o||(d.s=NaN),d.e=NaN,d.d=null;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn hr(d,o.toString())}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(l==="string")<span class="cstat-no" title="statement not covered" >return(a=o.charCodeAt(0))===45?(o=o.slice(1),d.s=-1):(a===43&amp;&amp;(o=o.slice(1)),d.s=1),co.test(o)?hr(d,o):Cl(d,o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(l==="bigint")<span class="cstat-no" title="statement not covered" >return o&lt;0?(o=-o,d.s=-1):d.s=1,hr(d,o.toString());<span class="cstat-no" title="statement not covered" >t</span></span>hrow Error(Ie+o)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(i.prototype=C,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.EUCLID=9,i.config=i.set=Ul,i.clone=yo,i.isDecimal=oo,i.abs=Rl,i.acos=Sl,i.acosh=kl,i.add=Il,i.asin=Ol,i.asinh=Dl,i.atan=Ml,i.atanh=_l,i.atan2=Nl,i.cbrt=Fl,i.ceil=Ll,i.clamp=Bl,i.cos=ql,i.cosh=$l,i.div=jl,i.exp=Vl,i.floor=Gl,i.hypot=Ql,i.ln=Jl,i.log=Wl,i.log10=Kl,i.log2=Hl,i.max=zl,i.min=Yl,i.mod=Zl,i.mul=Xl,i.pow=eu,i.random=tu,i.round=ru,i.sign=nu,i.sin=iu,i.sinh=ou,i.sqrt=su,i.sub=au,i.sum=lu,i.tan=uu,i.tanh=cu,i.trunc=pu,e===void 0&amp;&amp;(e={}),e&amp;&amp;e.defaults!==!0)<span class="cstat-no" title="statement not covered" >for(n=["precision","rounding","toExpNeg","toExpPos","maxE","minE","modulo","crypto"],t=0;t&lt;n.length;)<span class="cstat-no" title="statement not covered" >e.hasOwnProperty(r=n[t++])||(e[r]=this[r]</span></span></span>);<span class="cstat-no" title="statement not covered" >return i.config(e),i}</span>function <span class="fstat-no" title="function not covered" >jl(e</span>,t){<span class="cstat-no" title="statement not covered" >return new this(e).div(t)}</span>function <span class="fstat-no" title="function not covered" >Vl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).exp()}</span>function <span class="fstat-no" title="function not covered" >Gl(e</span>){<span class="cstat-no" title="statement not covered" >return I(e=new this(e),e.e+1,3)}</span>function <span class="fstat-no" title="function not covered" >Ql(){v</span>ar e,t,r=<span class="cstat-no" title="statement not covered" >new this(0);<span class="cstat-no" title="statement not covered" >f</span>or(_=!1,e=0;e&lt;arguments.length;)<span class="cstat-no" title="statement not covered" >if(t=new this(arguments[e++]),t.d)<span class="cstat-no" title="statement not covered" >r.d&amp;&amp;(r=r.plus(t.times(t)));else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(t.s)<span class="cstat-no" title="statement not covered" >return _=!0,new this(1/0);<span class="cstat-no" title="statement not covered" >r</span></span>=t}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn _=!0,r.sqrt()}</span>function <span class="fstat-no" title="function not covered" >oo(e</span>){<span class="cstat-no" title="statement not covered" >return e instanceof Be||e&amp;&amp;e.toStringTag===uo||!1}</span>function <span class="fstat-no" title="function not covered" >Jl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).ln()}</span>function <span class="fstat-no" title="function not covered" >Wl(e</span>,t){<span class="cstat-no" title="statement not covered" >return new this(e).log(t)}</span>function <span class="fstat-no" title="function not covered" >Hl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).log(2)}</span>function <span class="fstat-no" title="function not covered" >Kl(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).log(10)}</span>function <span class="fstat-no" title="function not covered" >zl(){<span class="cstat-no" title="statement not covered" >r</span>eturn fo(this,arguments,-1)}</span>function <span class="fstat-no" title="function not covered" >Yl(){<span class="cstat-no" title="statement not covered" >r</span>eturn fo(this,arguments,1)}</span>function <span class="fstat-no" title="function not covered" >Zl(e</span>,t){<span class="cstat-no" title="statement not covered" >return new this(e).mod(t)}</span>function <span class="fstat-no" title="function not covered" >Xl(e</span>,t){<span class="cstat-no" title="statement not covered" >return new this(e).mul(t)}</span>function <span class="fstat-no" title="function not covered" >eu(e</span>,t){<span class="cstat-no" title="statement not covered" >return new this(e).pow(t)}</span>function <span class="fstat-no" title="function not covered" >tu(e</span>){var t,r,n,i,o=<span class="cstat-no" title="statement not covered" >0,s</span>=<span class="cstat-no" title="statement not covered" >new this(1),a</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e===void 0?e=this.precision:re(e,1,Oe),n=Math.ceil(e/O),this.crypto)<span class="cstat-no" title="statement not covered" >if(crypto.getRandomValues)<span class="cstat-no" title="statement not covered" >for(t=crypto.getRandomValues(new Uint32Array(n));o&lt;n;)<span class="cstat-no" title="statement not covered" >i=t[o],i&gt;=429e7?t[o]=crypto.getRandomValues(new Uint32Array(1))[0]:a[o++]=i%1e7;else <span class="cstat-no" title="statement not covered" >i</span></span>f(crypto.randomBytes){<span class="cstat-no" title="statement not covered" >for(t=crypto.randomBytes(n*=4);o&lt;n;)<span class="cstat-no" title="statement not covered" >i=t[o]+(t[o+1]&lt;&lt;8)+(t[o+2]&lt;&lt;16)+((t[o+3]&amp;127)&lt;&lt;24),i&gt;=214e7?crypto.randomBytes(4).copy(t,o):(a.push(i%1e7),o+=4);<span class="cstat-no" title="statement not covered" >o</span></span>=n/4}</span>else <span class="cstat-no" title="statement not covered" >throw Error(lo);else <span class="cstat-no" title="statement not covered" >f</span></span></span>or(;o&lt;n;)<span class="cstat-no" title="statement not covered" >a[o++]=Math.random()*1e7|0;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(n=a[--o],e%=O,n&amp;&amp;e&amp;&amp;(i=J(10,O-e),a[o]=(n/i|0)*i);a[o]===0;o--)<span class="cstat-no" title="statement not covered" >a.pop();<span class="cstat-no" title="statement not covered" >i</span></span>f(o&lt;0)<span class="cstat-no" title="statement not covered" >r=0,a=[0];else{<span class="cstat-no" title="statement not covered" ></span>for(r=-1;a[0]===0;r-=O)<span class="cstat-no" title="statement not covered" >a.shift();<span class="cstat-no" title="statement not covered" >f</span></span>or(n=1,i=a[0];i&gt;=10;i/=10)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >n</span></span>&lt;O&amp;&amp;(r-=O-n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.e=r,s.d=a,s}</span>function <span class="fstat-no" title="function not covered" >ru(e</span>){<span class="cstat-no" title="statement not covered" >return I(e=new this(e),e.e+1,this.rounding)}</span>function <span class="fstat-no" title="function not covered" >nu(e</span>){<span class="cstat-no" title="statement not covered" >return e=new this(e),e.d?e.d[0]?e.s:0*e.s:e.s||NaN}</span>function <span class="fstat-no" title="function not covered" >iu(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).sin()}</span>function <span class="fstat-no" title="function not covered" >ou(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).sinh()}</span>function <span class="fstat-no" title="function not covered" >su(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).sqrt()}</span>function <span class="fstat-no" title="function not covered" >au(e</span>,t){<span class="cstat-no" title="statement not covered" >return new this(e).sub(t)}</span>function <span class="fstat-no" title="function not covered" >lu(){v</span>ar e=<span class="cstat-no" title="statement not covered" >0,t</span>=<span class="cstat-no" title="statement not covered" >arguments,r</span>=<span class="cstat-no" title="statement not covered" >new this(t[e]);<span class="cstat-no" title="statement not covered" >f</span>or(_=!1;r.s&amp;&amp;++e&lt;t.length;)<span class="cstat-no" title="statement not covered" >r=r.plus(t[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn _=!0,I(r,this.precision,this.rounding)}</span>function <span class="fstat-no" title="function not covered" >uu(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).tan()}</span>function <span class="fstat-no" title="function not covered" >cu(e</span>){<span class="cstat-no" title="statement not covered" >return new this(e).tanh()}</span>function <span class="fstat-no" title="function not covered" >pu(e</span>){<span class="cstat-no" title="statement not covered" >return I(e=new this(e),e.e+1,1)}<span class="cstat-no" title="statement not covered" ></span>C[Symbol.for("nodejs.util.inspect.custom")]=C.toString;<span class="cstat-no" title="statement not covered" >C</span>[Symbol.toStringTag]="Decimal";v</span>ar Be=<span class="cstat-no" title="statement not covered" >C.constructor=yo(wn);<span class="cstat-no" title="statement not covered" >y</span>r=new Be(yr);<span class="cstat-no" title="statement not covered" >w</span>r=new Be(wr);v</span>ar he=<span class="cstat-no" title="statement not covered" >Be;f</span>unction <span class="fstat-no" title="function not covered" >Ct(e</span>){<span class="cstat-no" title="statement not covered" >return e===null?e:Array.isArray(e)?e.map(Ct):typeof e=="object"?mu(e)?fu(e):typeof e=="bigint"||e instanceof Date||e instanceof Uint8Array||e instanceof he?e:Ze(e,Ct):e}</span>function <span class="fstat-no" title="function not covered" >mu(e</span>){<span class="cstat-no" title="statement not covered" >return e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.$type=="string"}</span>function <span class="fstat-no" title="function not covered" >fu({</span>$type:e,value:t}){<span class="cstat-no" title="statement not covered" >switch(e){case"BigInt":<span class="cstat-no" title="statement not covered" >return BigInt(t);c</span>ase"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >w.Buffer.from(t,"base64");<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(r,n,i)}</span>case"DateTime":<span class="cstat-no" title="statement not covered" >return new Date(t);c</span>ase"Decimal":<span class="cstat-no" title="statement not covered" >return new he(t);c</span>ase"Json":<span class="cstat-no" title="statement not covered" >return JSON.parse(t);d</span>efault:<span class="cstat-no" title="statement not covered" >Pe(t,"Unknown tagged value")}</span>}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar ye=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >_map=new Map;<span class="fstat-no" title="function not covered" >g</span>et(t</span>){<span class="cstat-no" title="statement not covered" >return this._map.get(t)?.value}<span class="fstat-no" title="function not covered" ></span>set(t</span>,r){<span class="cstat-no" title="statement not covered" >this._map.set(t,{value:r})}<span class="fstat-no" title="function not covered" ></span>getOrCreate(t</span>,r){let n=<span class="cstat-no" title="statement not covered" >this._map.get(t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n)<span class="cstat-no" title="statement not covered" >return n.value;l</span></span>et i=<span class="cstat-no" title="statement not covered" >r();<span class="cstat-no" title="statement not covered" >r</span>eturn this.set(t,i),i}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >De(e</span>){<span class="cstat-no" title="statement not covered" >return e.substring(0,1).toLowerCase()+e.substring(1)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >wo(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let n of e){let i=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>r[i]=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >At(e</span>){let t;<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >get(){<span class="cstat-no" title="statement not covered" >r</span>eturn t||(t={value:e()}),t.value}}</span>}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >du(e</span>){<span class="cstat-no" title="statement not covered" >return{models:Pn(e.models),enums:Pn(e.enums),types:Pn(e.types)}}</span>function <span class="fstat-no" title="function not covered" >Pn(e</span>){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let{name:r,...n}of e)<span class="cstat-no" title="statement not covered" >t[r]=n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >tt(e</span>){<span class="cstat-no" title="statement not covered" >return e instanceof Date||Object.prototype.toString.call(e)==="[object Date]"}</span>function <span class="fstat-no" title="function not covered" >vr(e</span>){<span class="cstat-no" title="statement not covered" >return e.toString()!=="Invalid Date"}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >rt(e</span>){<span class="cstat-no" title="statement not covered" >return Be.isDecimal(e)?!0:e!==null&amp;&amp;typeof e=="object"&amp;&amp;typeof e.s=="number"&amp;&amp;typeof e.e=="number"&amp;&amp;typeof e.toFixed=="function"&amp;&amp;Array.isArray(e.d)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Tr=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >o</span>r(Tr,{ModelAction:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >R</span>t,d</span>atamodelEnumToSchemaEnum:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>u}</span>);<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >gu(e</span>){<span class="cstat-no" title="statement not covered" >return{name:e.name,values:e.values.map(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.name)</span>}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Rt=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >k=&gt;(<span class="cstat-no" title="statement not covered" >k</span>.findUnique="findUnique",k.findUniqueOrThrow="findUniqueOrThrow",k.findFirst="findFirst",k.findFirstOrThrow="findFirstOrThrow",k.findMany="findMany",k.create="create",k.createMany="createMany",k.createManyAndReturn="createManyAndReturn",k.update="update",k.updateMany="updateMany",k.updateManyAndReturn="updateManyAndReturn",k.upsert="upsert",k.delete="delete",k.deleteMany="deleteMany",k.groupBy="groupBy",k.count="count",k.aggregate="aggregate",k.findRaw="findRaw",k.aggregateRaw="aggregateRaw",k)</span>)(Rt||{});v</span>ar hu=<span class="cstat-no" title="statement not covered" >Qe(Ki());v</span>ar yu=<span class="cstat-no" title="statement not covered" >{red:ze,gray:Ni,dim:ur,bold:lr,underline:Ii,highlightSource:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.highlight()}</span>,w</span>u=<span class="cstat-no" title="statement not covered" >{red:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,g</span>ray:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,d</span>im:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,b</span>old:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,u</span>nderline:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,h</span>ighlightSource:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>}</span>;f</span>unction <span class="fstat-no" title="function not covered" >Eu({</span>message:e,originalMethod:t,isPanic:r,callArguments:n}){<span class="cstat-no" title="statement not covered" >return{functionName:`prisma.${t}()`,message:e,isPanic:r??!1,callArguments:n}}</span>function <span class="fstat-no" title="function not covered" >bu({</span>functionName:e,location:t,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=<span class="cstat-no" title="statement not covered" >[""],l</span>=<span class="cstat-no" title="statement not covered" >t?" in":":";<span class="cstat-no" title="statement not covered" >i</span>f(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))):a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)),t&amp;&amp;a.push(s.underline(xu(t))),i){<span class="cstat-no" title="statement not covered" >a.push("");l</span>et d=<span class="cstat-no" title="statement not covered" >[i.toString()];<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;(d.push(o),d.push(s.dim(")"))),a.push(d.join("")),o&amp;&amp;a.push("")}</span>else <span class="cstat-no" title="statement not covered" >a.push(""),o&amp;&amp;a.push(o),a.push("");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.push(r),a.join(`</span>
`)}function <span class="fstat-no" title="function not covered" >xu(e</span>){let t=<span class="cstat-no" title="statement not covered" >[e.fileName];<span class="cstat-no" title="statement not covered" >r</span>eturn e.lineNumber&amp;&amp;t.push(String(e.lineNumber)),e.columnNumber&amp;&amp;t.push(String(e.columnNumber)),t.join(":")}</span>function <span class="fstat-no" title="function not covered" >Cr(e</span>){let t=<span class="cstat-no" title="statement not covered" >e.showColors?yu:wu,r</span>;<span class="cstat-no" title="statement not covered" >return typeof $getTemplateParameters&lt;"u"?r=$getTemplateParameters(e,t):r=Eu(e),bu(r,t)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Ro=<span class="cstat-no" title="statement not covered" >Qe(vn());<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Po(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >vo(e),i</span>=<span class="cstat-no" title="statement not covered" >Pu(n),o</span>=<span class="cstat-no" title="statement not covered" >Tu(i);<span class="cstat-no" title="statement not covered" >o</span>?Ar(o,t,r):t.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Unknown error")}</span></span>function <span class="fstat-no" title="function not covered" >vo(e</span>){<span class="cstat-no" title="statement not covered" >return e.errors.flatMap(<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.kind==="Union"?vo(t):[t])}</span></span>function <span class="fstat-no" title="function not covered" >Pu(e</span>){let t=<span class="cstat-no" title="statement not covered" >new Map,r</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n of e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.kind!=="InvalidArgumentType"){<span class="cstat-no" title="statement not covered" >r.push(n);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,</span>o=<span class="cstat-no" title="statement not covered" >t.get(i);<span class="cstat-no" title="statement not covered" >o</span>?t.set(i,{...n,argument:{...n.argument,typeNames:vu(o.argument.typeNames,n.argument.typeNames)}}):t.set(i,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.push(...t.values()),r}</span>function <span class="fstat-no" title="function not covered" >vu(e</span>,t){<span class="cstat-no" title="statement not covered" >return[...new Set(e.concat(t))]}f</span>unction <span class="fstat-no" title="function not covered" >Tu(e</span>){<span class="cstat-no" title="statement not covered" >return hn(e,<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >bo(t),i</span>=<span class="cstat-no" title="statement not covered" >bo(r);<span class="cstat-no" title="statement not covered" >r</span>eturn n!==i?n-i:xo(t)-xo(r)}</span>)}</span>function <span class="fstat-no" title="function not covered" >bo(e</span>){let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >r</span>eturn Array.isArray(e.selectionPath)&amp;&amp;(t+=e.selectionPath.length),Array.isArray(e.argumentPath)&amp;&amp;(t+=e.argumentPath.length),t}</span>function <span class="fstat-no" title="function not covered" >xo(e</span>){<span class="cstat-no" title="statement not covered" >switch(e.kind){case"InvalidArgumentValue":case"ValueTooLarge":<span class="cstat-no" title="statement not covered" >return 20;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >return 10;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >return-10;d</span>efault:<span class="cstat-no" title="statement not covered" >return 0}</span>}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar ae=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.value=r}<span class="cstat-no" title="statement not covered" ></span>isRequired=!1;<span class="fstat-no" title="function not covered" >m</span>akeRequired(){<span class="cstat-no" title="statement not covered" ></span>return this.isRequired=!0,this}<span class="fstat-no" title="function not covered" >w</span>rite(t</span>){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.addMarginSymbol(r(this.isRequired?"+":"?")),t.write(r(this.name)),this.isRequired||t.write(r("?")),t.write(r(": ")),typeof this.value=="string"?t.write(r(this.value)):t.write(this.value)}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >C</span>o();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar nt=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r){<span class="cstat-no" title="statement not covered" >this.context=r;<span class="cstat-no" title="statement not covered" >t</span>his.currentIndent=t}<span class="cstat-no" title="statement not covered" ></span>lines=[];<span class="cstat-no" title="statement not covered" >c</span>urrentLine="";<span class="cstat-no" title="statement not covered" >c</span>urrentIndent=0;marginSymbol;afterNextNewLineCallback;<span class="fstat-no" title="function not covered" >w</span>rite(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t=="string"?this.currentLine+=t:t.write(this),this}<span class="fstat-no" title="function not covered" >w</span>riteJoined(t</span>,r,n=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >o.write(i))</span></span>{let i=<span class="cstat-no" title="statement not covered" >r.length-1;<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;r.length;o++)<span class="cstat-no" title="statement not covered" >n(r[o],this),o!==i&amp;&amp;this.write(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" >w</span>riteLine(t</span>){<span class="cstat-no" title="statement not covered" >return this.write(t).newLine()}<span class="fstat-no" title="function not covered" ></span>newLine(){<span class="cstat-no" title="statement not covered" ></span>this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;l</span>et t=<span class="cstat-no" title="statement not covered" >this.afterNextNewLineCallback;<span class="cstat-no" title="statement not covered" ></span>return this.afterNextNewLineCallback=void 0,t?.(),this}<span class="fstat-no" title="function not covered" >w</span>ithIndent(t</span>){<span class="cstat-no" title="statement not covered" >return this.indent(),t(this),this.unindent(),this}<span class="fstat-no" title="function not covered" >a</span>fterNextNewline(t</span>){<span class="cstat-no" title="statement not covered" >return this.afterNextNewLineCallback=t,this}<span class="fstat-no" title="function not covered" >i</span>ndent(){<span class="cstat-no" title="statement not covered" ></span>return this.currentIndent++,this}<span class="fstat-no" title="function not covered" >u</span>nindent(){<span class="cstat-no" title="statement not covered" ></span>return this.currentIndent&gt;0&amp;&amp;this.currentIndent--,this}<span class="fstat-no" title="function not covered" >a</span>ddMarginSymbol(t</span>){<span class="cstat-no" title="statement not covered" >return this.marginSymbol=t,this}<span class="fstat-no" title="function not covered" >t</span>oString(){<span class="cstat-no" title="statement not covered" ></span>return this.lines.concat(this.indentedCurrentLine()).join(`</span></span>
`)}<span class="fstat-no" title="function not covered" >getCurrentLineLength(){<span class="cstat-no" title="statement not covered" ></span>return this.currentLine.length}<span class="fstat-no" title="function not covered" >i</span>ndentedCurrentLine(){</span>let t=<span class="cstat-no" title="statement not covered" >this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);<span class="cstat-no" title="statement not covered" >r</span>eturn this.marginSymbol?this.marginSymbol+t.slice(1):t}</span>};<span class="cstat-no" title="statement not covered" >To();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Rr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >this.value=t}<span class="fstat-no" title="function not covered" ></span>write(t</span>){<span class="cstat-no" title="statement not covered" >t.write(this.value)}<span class="fstat-no" title="function not covered" ></span>markAsError(){<span class="cstat-no" title="statement not covered" ></span>this.value.markAsError()}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Sr=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,k</span></span>r=<span class="cstat-no" title="statement not covered" >{bold:Sr,red:Sr,green:Sr,dim:Sr,enabled:!1},A</span>o=<span class="cstat-no" title="statement not covered" >{bold:lr,red:ze,green:Oi,dim:ur,enabled:!0},i</span>t=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >write(e</span>){<span class="cstat-no" title="statement not covered" >e.writeLine(",")}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar we=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >this.contents=t}<span class="cstat-no" title="statement not covered" ></span>isUnderlined=!1;<span class="cstat-no" title="statement not covered" >c</span>olor=<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>;<span class="fstat-no" title="function not covered" >u</span></span>nderline(){<span class="cstat-no" title="statement not covered" ></span>return this.isUnderlined=!0,this}<span class="fstat-no" title="function not covered" >s</span>etColor(t</span>){<span class="cstat-no" title="statement not covered" >return this.color=t,this}<span class="fstat-no" title="function not covered" >w</span>rite(t</span>){let r=<span class="cstat-no" title="statement not covered" >t.getCurrentLineLength();<span class="cstat-no" title="statement not covered" >t</span>.write(this.color(this.contents)),this.isUnderlined&amp;&amp;t.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))}</span>)}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Me=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >hasError=!1;<span class="fstat-no" title="function not covered" >m</span>arkAsError(){<span class="cstat-no" title="statement not covered" ></span>return this.hasError=!0,this}}</span>;v</span>ar ot=<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" >class extends Me{items=[];<span class="fstat-no" title="function not covered" >a</span>ddItem(t</span>){<span class="cstat-no" title="statement not covered" >return this.items.push(new Rr(t)),this}<span class="fstat-no" title="function not covered" >g</span>etField(t</span>){<span class="cstat-no" title="statement not covered" >return this.items[t]}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.items.length===0?2:Math.max(...this.items.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.value.getPrintWidth()))+2</span>}<span class="fstat-no" title="function not covered" ></span>write(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(this.items.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithItems(t)}<span class="fstat-no" title="function not covered" ></span>writeEmpty(t</span>){let r=<span class="cstat-no" title="statement not covered" >new we("[]");<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;r.setColor(t.context.colors.red).underline(),t.write(r)}<span class="fstat-no" title="function not covered" ></span>writeWithItems(t</span>){let{colors:r}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.writeLine("[").withIndent(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>.writeJoined(it,this.items).newLine()).w</span>rite("]"),this.hasError&amp;&amp;t.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.writeLine(r.red("~".repeat(this.getPrintWidth())))}</span>)}<span class="fstat-no" title="function not covered" ></span>asObject(){</span>}};v</span>ar st=<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" >class e extends Me{fields={};suggestions=[];<span class="fstat-no" title="function not covered" >a</span>ddField(t</span>){<span class="cstat-no" title="statement not covered" >this.fields[t.name]=t}<span class="fstat-no" title="function not covered" ></span>addSuggestion(t</span>){<span class="cstat-no" title="statement not covered" >this.suggestions.push(t)}<span class="fstat-no" title="function not covered" ></span>getField(t</span>){<span class="cstat-no" title="statement not covered" >return this.fields[t]}<span class="fstat-no" title="function not covered" >g</span>etDeepField(t</span>){let[r,...n]=<span class="cstat-no" title="statement not covered" >t,i</span>=<span class="cstat-no" title="statement not covered" >this.getField(r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!i)<span class="cstat-no" title="statement not covered" >return;l</span></span>et o=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" >f</span>or(let s of n){let a;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o.value instanceof e?a=o.value.getField(s):o.value instanceof ot&amp;&amp;(a=o.value.getField(Number(s))),!a)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >o</span></span>=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}<span class="fstat-no" title="function not covered" ></span>getDeepFieldValue(t</span>){<span class="cstat-no" title="statement not covered" >return t.length===0?this:this.getDeepField(t)?.value}<span class="fstat-no" title="function not covered" ></span>hasField(t</span>){<span class="cstat-no" title="statement not covered" >return!!this.getField(t)}<span class="fstat-no" title="function not covered" ></span>removeAllFields(){<span class="cstat-no" title="statement not covered" ></span>this.fields={}}<span class="fstat-no" title="function not covered" ></span>removeField(t</span>){<span class="cstat-no" title="statement not covered" >delete this.fields[t]}<span class="fstat-no" title="function not covered" >g</span>etFields(){<span class="cstat-no" title="statement not covered" ></span>return this.fields}<span class="fstat-no" title="function not covered" >i</span>sEmpty(){<span class="cstat-no" title="statement not covered" ></span>return Object.keys(this.fields).length===0}<span class="fstat-no" title="function not covered" ></span>getFieldValue(t</span>){<span class="cstat-no" title="statement not covered" >return this.getField(t)?.value}<span class="fstat-no" title="function not covered" ></span>getDeepSubSelectionValue(t</span>){let r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(let n of t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!(r instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >r.getSubSelectionValue(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="fstat-no" title="function not covered" ></span>getDeepSelectionParent(t</span>){let r=<span class="cstat-no" title="statement not covered" >this.getSelectionParent();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!r)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >f</span>or(let i of t){let o=<span class="cstat-no" title="statement not covered" >n.value.getFieldValue(i);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o||!(o instanceof e))<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >o.getSelectionParent();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>getSelectionParent(){</span>let t=<span class="cstat-no" title="statement not covered" >this.getField("select")?.value.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t)<span class="cstat-no" title="statement not covered" >return{kind:"select",value:t};l</span></span>et r=<span class="cstat-no" title="statement not covered" >this.getField("include")?.value.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r)<span class="cstat-no" title="statement not covered" >return{kind:"include",value:r}}<span class="fstat-no" title="function not covered" ></span></span>getSubSelectionValue(t</span>){<span class="cstat-no" title="statement not covered" >return this.getSelectionParent()?.value.fields[t].value}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){</span>let t=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" >r</span>eturn t.length==0?2:Math.max(...t.map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.getPrintWidth()))+2</span>}<span class="fstat-no" title="function not covered" ></span>write(t</span>){let r=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r.length===0&amp;&amp;this.suggestions.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithContents(t,r)}<span class="fstat-no" title="function not covered" ></span>asObject(){<span class="cstat-no" title="statement not covered" ></span>return this}<span class="fstat-no" title="function not covered" >w</span>riteEmpty(t</span>){let r=<span class="cstat-no" title="statement not covered" >new we("{}");<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;r.setColor(t.context.colors.red).underline(),t.write(r)}<span class="fstat-no" title="function not covered" ></span>writeWithContents(t</span>,r){<span class="cstat-no" title="statement not covered" >t.writeLine("{").withIndent(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.writeJoined(it,[...r,...this.suggestions]).newLine()}</span>),t.write("}"),this.hasError&amp;&amp;t.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.writeLine(t.context.colors.red("~".repeat(this.getPrintWidth())))}</span>)}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar H=<span class="cstat-no" title="statement not covered" >class extends Me{<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.text=r}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.text.length}<span class="fstat-no" title="function not covered" >w</span>rite(r</span>){let n=<span class="cstat-no" title="statement not covered" >new we(this.text);<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;n.underline().setColor(r.context.colors.red),r.write(n)}<span class="fstat-no" title="function not covered" ></span>asObject(){</span>}};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar St=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >fields=[];<span class="fstat-no" title="function not covered" >a</span>ddField(t</span>,r){<span class="cstat-no" title="statement not covered" >return this.fields.push({<span class="fstat-no" title="function not covered" >write(n</span>){let{green:i,dim:o}=<span class="cstat-no" title="statement not covered" >n.context.colors;<span class="cstat-no" title="statement not covered" ></span>n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")))}</span>}),this}<span class="fstat-no" title="function not covered" >w</span>rite(t</span>){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >t.context;<span class="cstat-no" title="statement not covered" ></span>t.writeLine(r("{")).withIndent(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>.writeJoined(it,this.fields).newLine()}</span>).write(r("}")).addMarginSymbol(r("+"))}</span>};f</span>unction <span class="fstat-no" title="function not covered" >Ar(e</span>,t,r){<span class="cstat-no" title="statement not covered" >switch(e.kind){case"MutuallyExclusiveFields":<span class="cstat-no" title="statement not covered" >Cu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"IncludeOnScalar":<span class="cstat-no" title="statement not covered" >Au(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"EmptySelection":<span class="cstat-no" title="statement not covered" >Ru(e,t,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownSelectionField":<span class="cstat-no" title="statement not covered" >Ou(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidSelectionValue":<span class="cstat-no" title="statement not covered" >Du(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownArgument":<span class="cstat-no" title="statement not covered" >Mu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownInputField":<span class="cstat-no" title="statement not covered" >_u(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >Nu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >Fu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentValue":<span class="cstat-no" title="statement not covered" >Lu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ValueTooLarge":<span class="cstat-no" title="statement not covered" >Bu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SomeFieldsMissing":<span class="cstat-no" title="statement not covered" >Uu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"TooManyFieldsGiven":<span class="cstat-no" title="statement not covered" >qu(e,t);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Union":<span class="cstat-no" title="statement not covered" >Po(e,t,r);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("not implemented: "+e.kind)}</span>}</span>function <span class="fstat-no" title="function not covered" >Cu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >r</span>&amp;&amp;(r.getField(e.firstField)?.markAsError(),r.getField(e.secondField)?.markAsError()),t.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>Please ${n.bold("either")} use ${n.green(`\`${e.firstField}\``)} or ${n.green(`\`${e.secondField}\``)}, but ${n.red("not both")} at the same time.`)</span>}</span>function <span class="fstat-no" title="function not covered" >Au(e</span>,t){let[r,n]=<span class="cstat-no" title="statement not covered" >kt(e.selectionPath),i</span>=<span class="cstat-no" title="statement not covered" >e.outputType,</span>o=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(r)?.value;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o&amp;&amp;(o.getField(n)?.markAsError(),i))<span class="cstat-no" title="statement not covered" >for(let s of i.fields)<span class="cstat-no" title="statement not covered" >s.isRelation&amp;&amp;o.addSuggestion(new ae(s.name,"true"));<span class="cstat-no" title="statement not covered" >t</span></span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >s=&gt;{l</span>et a=<span class="cstat-no" title="statement not covered" >`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;<span class="cstat-no" title="statement not covered" ></span>return i?a+=` on model ${s.bold(i.name)}. ${It(s)}`:a+=".",a+=`</span></span>
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function <span class="fstat-no" title="function not covered" >Ru(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >n.getField("omit")?.value.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i){<span class="cstat-no" title="statement not covered" >Su(e,t,i);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(n.hasField("select")){<span class="cstat-no" title="statement not covered" >ku(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(r?.[De(e.outputType.name)]){<span class="cstat-no" title="statement not covered" >Iu(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Unknown field at "${e.selectionPath.join(".")} selection"`)</span>}</span>function <span class="fstat-no" title="function not covered" >Su(e</span>,t,r){<span class="cstat-no" title="statement not covered" >r.removeAllFields();<span class="cstat-no" title="statement not covered" >f</span>or(let n of e.outputType.fields)<span class="cstat-no" title="statement not covered" >r.addSuggestion(new ae(n.name,"false"));<span class="cstat-no" title="statement not covered" >t</span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>The ${n.red("omit")} statement includes every field of the model ${n.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >ku(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.outputType,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(e.selectionPath)?.value,i</span>=<span class="cstat-no" title="statement not covered" >n?.isEmpty()??!1;<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(n.removeAllFields(),Io(n,r)),t.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >i</span>?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${It(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)</span>}</span>function <span class="fstat-no" title="function not covered" >Iu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >new St;<span class="cstat-no" title="statement not covered" >f</span>or(let i of e.outputType.fields)<span class="cstat-no" title="statement not covered" >i.isRelation||r.addField(i.name,"false");l</span></span>et n=<span class="cstat-no" title="statement not covered" >new ae("omit",r).makeRequired();<span class="cstat-no" title="statement not covered" >i</span>f(e.selectionPath.length===0)<span class="cstat-no" title="statement not covered" >t.arguments.addSuggestion(n);else{</span>let[i,o]=<span class="cstat-no" title="statement not covered" >kt(e.selectionPath),a</span>=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a){let l=<span class="cstat-no" title="statement not covered" >a?.value.asObject()??new st;<span class="cstat-no" title="statement not covered" >l</span>.addSuggestion(n),a.value=l}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >`</span>The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >Ou(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >Oo(e.selectionPath,t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r.parentKind!=="unknown"){<span class="cstat-no" title="statement not covered" >r.field.markAsError();l</span>et n=<span class="cstat-no" title="statement not covered" >r.parent;<span class="cstat-no" title="statement not covered" ></span>switch(r.parentKind){case"select":<span class="cstat-no" title="statement not covered" >Io(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"include":<span class="cstat-no" title="statement not covered" >$u(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"omit":<span class="cstat-no" title="statement not covered" >ju(n,e.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;{l</span>et i=<span class="cstat-no" title="statement not covered" >[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];<span class="cstat-no" title="statement not covered" >r</span>eturn r.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${e.outputType.name}\``)}.`),i.push(It(n)),i.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Du(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >Oo(e.selectionPath,t);<span class="cstat-no" title="statement not covered" >r</span>.parentKind!=="unknown"&amp;&amp;r.field.value.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>Invalid value for selection field \`${n.red(r.fieldName)}\`: ${e.underlyingError}`)</span>}</span>function <span class="fstat-no" title="function not covered" >Mu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[0],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(n.getField(r)?.markAsError(),Vu(n,e.arguments)),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >S</span>o(i,r,e.arguments.map(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >o</span>.name)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >_u(e</span>,t){let[r,n]=<span class="cstat-no" title="statement not covered" >kt(e.argumentPath),i</span>=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i){<span class="cstat-no" title="statement not covered" >i.getDeepField(e.argumentPath)?.markAsError();l</span>et o=<span class="cstat-no" title="statement not covered" >i.getDeepFieldValue(r)?.asObject();<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;Do(o,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >S</span>o(o,n,e.inputType.fields.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >s</span>.name)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >So(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >[`Unknown argument \`${e.red(t)}\`.`],i</span>=<span class="cstat-no" title="statement not covered" >Qu(t,r);<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;n.push(`Did you mean \`${e.green(i)}\`?`),r.length&gt;0&amp;&amp;n.push(It(e)),n.join(" ")}</span>function <span class="fstat-no" title="function not covered" >Nu(e</span>,t){let r;<span class="cstat-no" title="statement not covered" >t.addErrorMessage(<span class="fstat-no" title="function not covered" >l=&gt;<span class="cstat-no" title="statement not covered" >r</span>?.value instanceof H&amp;&amp;r.value.text==="null"?`Argument \`${l.green(o)}\` must not be ${l.red("null")}.`:`Argument \`${l.green(o)}\` is missing.`)</span>;l</span>et n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!n)<span class="cstat-no" title="statement not covered" >return;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >kt(e.argumentPath),s</span>=<span class="cstat-no" title="statement not covered" >new St,a</span>=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(i)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a)<span class="cstat-no" title="statement not covered" >if(r=a.getField(o),r&amp;&amp;a.removeField(o),e.inputTypes.length===1&amp;&amp;e.inputTypes[0].kind==="object"){<span class="cstat-no" title="statement not covered" >for(let l of e.inputTypes[0].fields)<span class="cstat-no" title="statement not covered" >s.addField(l.name,l.typeNames.join(" | "));<span class="cstat-no" title="statement not covered" >a</span></span>.addSuggestion(new ae(o,s).makeRequired())}</span>else{let l=<span class="cstat-no" title="statement not covered" >e.inputTypes.map(ko).join(" | ");<span class="cstat-no" title="statement not covered" >a</span>.addSuggestion(new ae(o,l).makeRequired())}</span>}</span></span>function <span class="fstat-no" title="function not covered" >ko(e</span>){<span class="cstat-no" title="statement not covered" >return e.kind==="list"?`${ko(e.elementType)}[]`:e.name}f</span>unction <span class="fstat-no" title="function not covered" >Fu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >Ir("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >i</span>.green(s)));<span class="cstat-no" title="statement not covered" >r</span></span>eturn`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`})}</span></span>function <span class="fstat-no" title="function not covered" >Lu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;n.getDeepFieldValue(e.argumentPath)?.markAsError(),t.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >[`Invalid value for argument \`${i.bold(r)}\``];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e.underlyingError&amp;&amp;o.push(`: ${e.underlyingError}`),o.push("."),e.argument.typeNames.length&gt;0){let s=<span class="cstat-no" title="statement not covered" >Ir("or",e.argument.typeNames.map(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >i</span>.green(a)));<span class="cstat-no" title="statement not covered" >o</span></span>.push(` Expected ${s}.`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.join("")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Bu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i</span>;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n){let s=<span class="cstat-no" title="statement not covered" >n.getDeepField(e.argumentPath)?.value;<span class="cstat-no" title="statement not covered" >s</span>?.markAsError(),s instanceof H&amp;&amp;(i=s.text</span>)}<span class="cstat-no" title="statement not covered" >t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;{l</span>et s=<span class="cstat-no" title="statement not covered" >["Unable to fit value"];<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Uu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" >i</span>&amp;&amp;Do(i,e.inputType)}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >[`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" >r</span>eturn e.constraints.minFieldCount===1?e.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Ir("or",e.constraints.requiredFields.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >`</span>\`${i.bold(s)}\``)</span>)} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`),o.push(It(i)),o.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >qu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.argumentPath[e.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(e.selectionPath)?.asObject(),i</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(n){let o=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(e.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}<span class="cstat-no" title="statement not covered" ></span>t</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;{l</span>et s=<span class="cstat-no" title="statement not covered" >[`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" >r</span>eturn e.constraints.minFieldCount===1&amp;&amp;e.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):e.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Ir("and",i.map(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >o</span>.red(a)))}.</span> Please choose`),e.constraints.maxFieldCount===1?s.push("one."):s.push(`${e.constraints.maxFieldCount}.`),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >Io(e</span>,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new ae(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >$u(e</span>,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >r.isRelation&amp;&amp;!e.hasField(r.name)&amp;&amp;e.addSuggestion(new ae(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >ju(e</span>,t){<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >!e.hasField(r.name)&amp;&amp;!r.isRelation&amp;&amp;e.addSuggestion(new ae(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Vu(e</span>,t){<span class="cstat-no" title="statement not covered" >for(let r of t)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new ae(r.name,r.typeNames.join(" | ")))}</span></span>function <span class="fstat-no" title="function not covered" >Oo(e</span>,t){let[r,n]=<span class="cstat-no" title="statement not covered" >kt(e),i</span>=<span class="cstat-no" title="statement not covered" >t.arguments.getDeepSubSelectionValue(r)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!i)<span class="cstat-no" title="statement not covered" >return{parentKind:"unknown",fieldName:n};l</span></span>et o=<span class="cstat-no" title="statement not covered" >i.getFieldValue("select")?.asObject(),s</span>=<span class="cstat-no" title="statement not covered" >i.getFieldValue("include")?.asObject(),a</span>=<span class="cstat-no" title="statement not covered" >i.getFieldValue("omit")?.asObject(),l</span>=<span class="cstat-no" title="statement not covered" >o?.getField(n);<span class="cstat-no" title="statement not covered" >r</span>eturn o&amp;&amp;l?{parentKind:"select",parent:o,field:l,fieldName:n}:(l=s?.getField(n),s&amp;&amp;l?{parentKind:"include",field:l,parent:s,fieldName:n}:(l=a?.getField(n),a&amp;&amp;l?{parentKind:"omit",field:l,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}</span>function <span class="fstat-no" title="function not covered" >Do(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.kind==="object")<span class="cstat-no" title="statement not covered" >for(let r of t.fields)<span class="cstat-no" title="statement not covered" >e.hasField(r.name)||e.addSuggestion(new ae(r.name,r.typeNames.join(" | ")))}</span></span></span>function <span class="fstat-no" title="function not covered" >kt(e</span>){let t=<span class="cstat-no" title="statement not covered" >[...e],r</span>=<span class="cstat-no" title="statement not covered" >t.pop();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!r)<span class="cstat-no" title="statement not covered" >throw new Error("unexpected empty path");<span class="cstat-no" title="statement not covered" >r</span></span>eturn[t,r]}f</span>unction <span class="fstat-no" title="function not covered" >It({</span>green:e,enabled:t}){<span class="cstat-no" title="statement not covered" >return"Available options are "+(t?`listed in ${e("green")}`:"marked with ?")+"."}</span>function <span class="fstat-no" title="function not covered" >Ir(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.length===1)<span class="cstat-no" title="statement not covered" >return t[0];l</span></span>et r=<span class="cstat-no" title="statement not covered" >[...t],n</span>=<span class="cstat-no" title="statement not covered" >r.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn`${r.join(", ")} ${e} ${n}`}v</span>ar Gu=<span class="cstat-no" title="statement not covered" >3;f</span>unction <span class="fstat-no" title="function not covered" >Qu(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >1/0,n</span>;<span class="cstat-no" title="statement not covered" >for(let i of t){let o=<span class="cstat-no" title="statement not covered" >(0,Ro.default)(e,i);<span class="cstat-no" title="statement not covered" >o</span>&gt;Gu||o&lt;r&amp;&amp;(r=o,n=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Ot=<span class="cstat-no" title="statement not covered" >class{modelName;name;typeName;isList;isEnum;<span class="fstat-no" title="function not covered" >constructor(t</span>,r,n,i,o){<span class="cstat-no" title="statement not covered" >this.modelName=t,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}<span class="fstat-no" title="function not covered" ></span>_toGraphQLInputType(){</span>let t=<span class="cstat-no" title="statement not covered" >this.isList?"List":"",r</span>=<span class="cstat-no" title="statement not covered" >this.isEnum?"Enum":"";<span class="cstat-no" title="statement not covered" >r</span>eturn`${t}${r}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}}</span>;f</span>unction <span class="fstat-no" title="function not covered" >at(e</span>){<span class="cstat-no" title="statement not covered" >return e instanceof Ot}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Or=<span class="cstat-no" title="statement not covered" >Symbol(),C</span>n=<span class="cstat-no" title="statement not covered" >new WeakMap,T</span>e=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >t===Or?Cn.set(this,`Prisma.${this._getName()}`):Cn.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}<span class="fstat-no" title="function not covered" ></span>_getName(){<span class="cstat-no" title="statement not covered" ></span>return this.constructor.name}<span class="fstat-no" title="function not covered" >t</span>oString(){<span class="cstat-no" title="statement not covered" ></span>return Cn.get(this)}</span>},D</span>t=<span class="cstat-no" title="statement not covered" >class extends Te{<span class="fstat-no" title="function not covered" >_getNamespace(){<span class="cstat-no" title="statement not covered" ></span>return"NullTypes"}</span>},M</span>t=<span class="cstat-no" title="statement not covered" >class extends Dt{#e};<span class="cstat-no" title="statement not covered" >R</span>n(Mt,"DbNull");v</span>ar _t=<span class="cstat-no" title="statement not covered" >class extends Dt{#e};<span class="cstat-no" title="statement not covered" >R</span>n(_t,"JsonNull");v</span>ar Nt=<span class="cstat-no" title="statement not covered" >class extends Dt{#e};<span class="cstat-no" title="statement not covered" >R</span>n(Nt,"AnyNull");v</span>ar An=<span class="cstat-no" title="statement not covered" >{classes:{DbNull:Mt,JsonNull:_t,AnyNull:Nt},instances:{DbNull:new Mt(Or),JsonNull:new _t(Or),AnyNull:new Nt(Or)}};f</span>unction <span class="fstat-no" title="function not covered" >Rn(e</span>,t){<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,"name",{value:t,configurable:!0})}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Mo=<span class="cstat-no" title="statement not covered" >": ",D</span>r=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >this.name=t;<span class="cstat-no" title="statement not covered" >t</span>his.value=r}<span class="cstat-no" title="statement not covered" ></span>hasError=!1;<span class="fstat-no" title="function not covered" >m</span>arkAsError(){<span class="cstat-no" title="statement not covered" ></span>this.hasError=!0}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.name.length+this.value.getPrintWidth()+Mo.length}<span class="fstat-no" title="function not covered" >w</span>rite(t</span>){let r=<span class="cstat-no" title="statement not covered" >new we(this.name);<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;r.underline().setColor(t.context.colors.red),t.write(r).write(Mo).write(this.value)}</span>};v</span>ar Sn=<span class="cstat-no" title="statement not covered" >class{arguments;<span class="cstat-no" title="statement not covered" >errorMessages=[];<span class="fstat-no" title="function not covered" >c</span>onstructor(t</span>){<span class="cstat-no" title="statement not covered" >this.arguments=t}<span class="fstat-no" title="function not covered" ></span>write(t</span>){<span class="cstat-no" title="statement not covered" >t.write(this.arguments)}<span class="fstat-no" title="function not covered" ></span>addErrorMessage(t</span>){<span class="cstat-no" title="statement not covered" >this.errorMessages.push(t)}<span class="fstat-no" title="function not covered" ></span>renderAllMessages(t</span>){<span class="cstat-no" title="statement not covered" >return this.errorMessages.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>(t)).j</span>oin(`</span></span>
`)}};function <span class="fstat-no" title="function not covered" >lt(e</span>){<span class="cstat-no" title="statement not covered" >return new Sn(_o(e))}</span>function <span class="fstat-no" title="function not covered" >_o(e</span>){let t=<span class="cstat-no" title="statement not covered" >new st;<span class="cstat-no" title="statement not covered" >f</span>or(let[r,n]of Object.entries(e)){let i=<span class="cstat-no" title="statement not covered" >new Dr(r,No(n));<span class="cstat-no" title="statement not covered" >t</span>.addField(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >No(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="string")<span class="cstat-no" title="statement not covered" >return new H(JSON.stringify(e));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="number"||typeof e=="boolean")<span class="cstat-no" title="statement not covered" >return new H(String(e));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return new H(`${e}n`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >return new H("null");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e===void 0)<span class="cstat-no" title="statement not covered" >return new H("undefined");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(rt(e))<span class="cstat-no" title="statement not covered" >return new H(`new Prisma.Decimal("${e.toFixed()}")`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return w.Buffer.isBuffer(e)?new H(`Buffer.alloc(${e.byteLength})`):new H(`new Uint8Array(${e.byteLength})`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e instanceof Date){let t=<span class="cstat-no" title="statement not covered" >vr(e)?e.toISOString():"Invalid Date";<span class="cstat-no" title="statement not covered" >r</span>eturn new H(`new Date("${t}")`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e instanceof Te?new H(`Prisma.${e._getName()}`):at(e)?new H(`prisma.${De(e.modelName)}.$fields.${e.name}`):Array.isArray(e)?Ju(e):typeof e=="object"?_o(e):new H(Object.prototype.toString.call(e))}</span>function <span class="fstat-no" title="function not covered" >Ju(e</span>){let t=<span class="cstat-no" title="statement not covered" >new ot;<span class="cstat-no" title="statement not covered" >f</span>or(let r of e)<span class="cstat-no" title="statement not covered" >t.addItem(No(r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Mr(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >t==="pretty"?Ao:kr,n</span>=<span class="cstat-no" title="statement not covered" >e.renderAllMessages(r),i</span>=<span class="cstat-no" title="statement not covered" >new nt(0,{colors:r}).write(e).toString();<span class="cstat-no" title="statement not covered" >r</span>eturn{message:n,args:i}}</span>function <span class="fstat-no" title="function not covered" >_r({</span>args:e,errors:t,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=<span class="cstat-no" title="statement not covered" >lt(e);<span class="cstat-no" title="statement not covered" >f</span>or(let h of t)<span class="cstat-no" title="statement not covered" >Ar(h,a,s);l</span></span>et{message:l,args:d}=<span class="cstat-no" title="statement not covered" >Mr(a,r),g</span>=<span class="cstat-no" title="statement not covered" >Cr({message:l,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:d});<span class="cstat-no" title="statement not covered" >t</span>hrow new X(g,{clientVersion:o})}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ee(e</span>){<span class="cstat-no" title="statement not covered" >return e.replace(/^./,<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.toLowerCase())}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Lo(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >Ee(r);<span class="cstat-no" title="statement not covered" >r</span>eturn!t.result||!(t.result.$allModels||t.result[n])?e:Wu({...e,...Fo(t.name,e,t.result.$allModels),...Fo(t.name,e,t.result[n])})}</span>function <span class="fstat-no" title="function not covered" >Wu(e</span>){let t=<span class="cstat-no" title="statement not covered" >new ye,r</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t.getOrCreate(n,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>.has(n)?[n]:(i.add(n),e[n]?e[n].needs.flatMap(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >r</span>(o,i)):[</span>n]</span></span></span>));<span class="cstat-no" title="statement not covered" >return Ze(e,<span class="fstat-no" title="function not covered" >n=&gt;(<span class="cstat-no" title="statement not covered" >{</span>...n,needs:r(n.name,new Set)}))}</span></span>function <span class="fstat-no" title="function not covered" >Fo(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return r?Ze(r,<span class="fstat-no" title="function not covered" >({</span>needs:n,compute:i},o)=&gt;(<span class="cstat-no" title="statement not covered" >{name:o,needs:n?Object.keys(n).filter(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >n</span>[s])</span>:[],compute:Hu(t,o,i)})):{</span>}}</span>function <span class="fstat-no" title="function not covered" >Hu(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >e?.[t]?.compute;<span class="cstat-no" title="statement not covered" >r</span>eturn n?<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >r</span>({...i,[t]:n(i)}):r</span>}</span>function <span class="fstat-no" title="function not covered" >Bo(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.values(t))<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >r[i]=!0;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Uo(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{...e};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.values(t))<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >delete r[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>var Nr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >this.extension=t;<span class="cstat-no" title="statement not covered" >t</span>his.previous=r}<span class="cstat-no" title="statement not covered" ></span>computedFieldsCache=new ye;<span class="cstat-no" title="statement not covered" >m</span>odelExtensionsCache=new ye;<span class="cstat-no" title="statement not covered" >q</span>ueryCallbacksCache=new ye;<span class="cstat-no" title="statement not covered" >c</span>lientExtensions=At(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());<span class="cstat-no" title="statement not covered" >b</span></span>atchCallbacks=At(<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >this.previous?.getAllBatchQueryCallbacks()??[],</span>r=<span class="cstat-no" title="statement not covered" >this.extension.query?.$__internalBatch;<span class="cstat-no" title="statement not covered" >r</span>eturn r?t.concat(r):t}</span>);<span class="fstat-no" title="function not covered" >g</span>etAllComputedFields(t</span>){<span class="cstat-no" title="statement not covered" >return this.computedFieldsCache.getOrCreate(t,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >L</span>o(this.previous?.getAllComputedFields(t),this.extension,t))}<span class="fstat-no" title="function not covered" ></span></span>getAllClientExtensions(){<span class="cstat-no" title="statement not covered" ></span>return this.clientExtensions.get()}<span class="fstat-no" title="function not covered" ></span>getAllModelExtensions(t</span>){<span class="cstat-no" title="statement not covered" >return this.modelExtensionsCache.getOrCreate(t,<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >Ee(t);<span class="cstat-no" title="statement not covered" >r</span>eturn!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(t):{...this.previous?.getAllModelExtensions(t),...this.extension.model.$allModels,...this.extension.model[r]}}</span>)}<span class="fstat-no" title="function not covered" ></span>getAllQueryCallbacks(t</span>,r){<span class="cstat-no" title="statement not covered" >return this.queryCallbacksCache.getOrCreate(`${t}:${r}`,<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >this.previous?.getAllQueryCallbacks(t,r)??[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >this.extension.query;<span class="cstat-no" title="statement not covered" ></span>return!o||!(o[t]||o.$allModels||o[r]||o.$allOperations)?n:(o[t]!==void 0&amp;&amp;(o[t][r]!==void 0&amp;&amp;i.push(o[t][r]),o[t].$allOperations!==void 0&amp;&amp;i.push(o[t].$allOperations)),t!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[r]!==void 0&amp;&amp;i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[r]!==void 0&amp;&amp;i.push(o[r]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))}</span>)}<span class="fstat-no" title="function not covered" ></span>getAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" ></span>return this.batchCallbacks.get()}</span>},u</span>t=<span class="cstat-no" title="statement not covered" >class e{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >this.head=t}<span class="fstat-no" title="function not covered" ></span>static e</span>mpty(){<span class="cstat-no" title="statement not covered" >return new e}<span class="fstat-no" title="function not covered" ></span>static s</span>ingle(t){<span class="cstat-no" title="statement not covered" >return new e(new Nr(t))}<span class="fstat-no" title="function not covered" ></span>isEmpty(){<span class="cstat-no" title="statement not covered" ></span>return this.head===void 0}<span class="fstat-no" title="function not covered" ></span>append(t</span>){<span class="cstat-no" title="statement not covered" >return new e(new Nr(t,this.head))}<span class="fstat-no" title="function not covered" ></span>getAllComputedFields(t</span>){<span class="cstat-no" title="statement not covered" >return this.head?.getAllComputedFields(t)}<span class="fstat-no" title="function not covered" ></span>getAllClientExtensions(){<span class="cstat-no" title="statement not covered" ></span>return this.head?.getAllClientExtensions()}<span class="fstat-no" title="function not covered" ></span>getAllModelExtensions(t</span>){<span class="cstat-no" title="statement not covered" >return this.head?.getAllModelExtensions(t)}<span class="fstat-no" title="function not covered" ></span>getAllQueryCallbacks(t</span>,r){<span class="cstat-no" title="statement not covered" >return this.head?.getAllQueryCallbacks(t,r)??[]}<span class="fstat-no" title="function not covered" >g</span>etAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" ></span>return this.head?.getAllBatchQueryCallbacks()??[]}}</span>;<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Fr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >this.name=t}</span>};f</span>unction <span class="fstat-no" title="function not covered" >qo(e</span>){<span class="cstat-no" title="statement not covered" >return e instanceof Fr}</span>function <span class="fstat-no" title="function not covered" >Ku(e</span>){<span class="cstat-no" title="statement not covered" >return new Fr(e)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar $o=<span class="cstat-no" title="statement not covered" >Symbol(),F</span>t=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t!==$o)<span class="cstat-no" title="statement not covered" >throw new Error("Skip instance can not be constructed directly")}<span class="fstat-no" title="function not covered" ></span></span>ifUndefined(t</span>){<span class="cstat-no" title="statement not covered" >return t===void 0?kn:t}</span>},k</span>n=<span class="cstat-no" title="statement not covered" >new Ft($o);f</span>unction <span class="fstat-no" title="function not covered" >be(e</span>){<span class="cstat-no" title="statement not covered" >return e instanceof Ft}</span>var zu=<span class="cstat-no" title="statement not covered" >{findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},j</span>o=<span class="cstat-no" title="statement not covered" >"explicitly `undefined` values are not allowed";f</span>unction <span class="fstat-no" title="function not covered" >On({</span>modelName:e,action:t,args:r,runtimeDataModel:n,extensions:i=<span class="branch-0 cbranch-no" title="branch not covered" >ut.empty(),</span>callsite:o,clientMethod:s,errorFormat:a,clientVersion:l,previewFeatures:d,globalOmit:g}){let h=<span class="cstat-no" title="statement not covered" >new In({runtimeDataModel:n,modelName:e,action:t,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:l,previewFeatures:d,globalOmit:g});<span class="cstat-no" title="statement not covered" >r</span>eturn{modelName:e,action:zu[t],query:Lt(r,h)}}</span>function <span class="fstat-no" title="function not covered" >Lt({</span>select:e,include:t,...r}=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>n){let i=<span class="cstat-no" title="statement not covered" >r.omit;<span class="cstat-no" title="statement not covered" ></span>return delete r.omit,{arguments:Go(r,n),selection:Yu(e,t,i,n)}}</span>function <span class="fstat-no" title="function not covered" >Yu(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" >return e?(t?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&amp;&amp;n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),tc(e,n)):Zu(n,t,r)}</span>function <span class="fstat-no" title="function not covered" >Zu(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>eturn e.modelOrType&amp;&amp;!e.isRawAction()&amp;&amp;(n.$composites=!0,n.$scalars=!0),t&amp;&amp;Xu(n,t,e),ec(n,r,e),n}</span>function <span class="fstat-no" title="function not covered" >Xu(e</span>,t,r){<span class="cstat-no" title="statement not covered" >for(let[n,i]of Object.entries(t)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(be(i))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et o=<span class="cstat-no" title="statement not covered" >r.nestSelection(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(Dn(i,o),i===!1||i===void 0){<span class="cstat-no" title="statement not covered" >e[n]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et s=<span class="cstat-no" title="statement not covered" >r.findField(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(s&amp;&amp;s.kind!=="object"&amp;&amp;r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){<span class="cstat-no" title="statement not covered" >e[n]=Lt(i===!0?{}:i,o);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(i===!0){<span class="cstat-no" title="statement not covered" >e[n]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>e</span>[n]=Lt(i,o)}</span>}</span>function <span class="fstat-no" title="function not covered" >ec(e</span>,t,r){let n=<span class="cstat-no" title="statement not covered" >r.getComputedFields(),i</span>=<span class="cstat-no" title="statement not covered" >{...r.getGlobalOmit(),...t},o</span>=<span class="cstat-no" title="statement not covered" >Uo(i,n);<span class="cstat-no" title="statement not covered" >f</span>or(let[s,a]of Object.entries(o)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(be(a))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >D</span></span>n(a,r.nestSelection(s));l</span>et l=<span class="cstat-no" title="statement not covered" >r.findField(s);<span class="cstat-no" title="statement not covered" >n</span>?.[s]&amp;&amp;!l||(e[s]=!a)}</span>}</span>function <span class="fstat-no" title="function not covered" >tc(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >{},n</span>=<span class="cstat-no" title="statement not covered" >t.getComputedFields(),i</span>=<span class="cstat-no" title="statement not covered" >Bo(e,n);<span class="cstat-no" title="statement not covered" >f</span>or(let[o,s]of Object.entries(i)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(be(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et a=<span class="cstat-no" title="statement not covered" >t.nestSelection(o);<span class="cstat-no" title="statement not covered" >D</span>n(s,a);l</span>et l=<span class="cstat-no" title="statement not covered" >t.findField(o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!(n?.[o]&amp;&amp;!l)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s===!1||s===void 0||be(s)){<span class="cstat-no" title="statement not covered" >r[o]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(s===!0){<span class="cstat-no" title="statement not covered" >l?.kind==="object"?r[o]=Lt({},a):r[o]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>[o]=Lt(s,a)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Vo(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e===null)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="string"||typeof e=="number"||typeof e=="boolean")<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{$type:"BigInt",value:String(e)};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(tt(e)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(vr(e))<span class="cstat-no" title="statement not covered" >return{$type:"DateTime",value:e.toISOString()};<span class="cstat-no" title="statement not covered" >t</span></span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(qo(e))<span class="cstat-no" title="statement not covered" >return{$type:"Param",value:e.name};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(at(e))<span class="cstat-no" title="statement not covered" >return{$type:"FieldRef",value:{_ref:e.name,_container:e.modelName}};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return rc(e,t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn{$type:"Bytes",value:w.Buffer.from(r,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(nc(e))<span class="cstat-no" title="statement not covered" >return e.values;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(rt(e))<span class="cstat-no" title="statement not covered" >return{$type:"Decimal",value:e.toFixed()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e instanceof Te){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e!==An.instances[e._getName()])<span class="cstat-no" title="statement not covered" >throw new Error("Invalid ObjectEnumValue");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Enum",value:e._getName()}}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(ic(e))<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="object")<span class="cstat-no" title="statement not covered" >return Go(e,t);<span class="cstat-no" title="statement not covered" >t</span></span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:t.getSelectionPath(),argumentPath:t.getArgumentPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}</span>function <span class="fstat-no" title="function not covered" >Go(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.$type)<span class="cstat-no" title="statement not covered" >return{$type:"Raw",value:e};l</span></span>et r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let n in e){let i=<span class="cstat-no" title="statement not covered" >e[n],</span>o=<span class="cstat-no" title="statement not covered" >t.nestArgument(n);<span class="cstat-no" title="statement not covered" >b</span>e(i)||(i!==void 0?r[n]=Vo(i,o):t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:t.getSelectionPath(),argument:{name:t.getArgumentName(),typeNames:[]},underlyingError:jo}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >rc(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;n</span>&lt;e.length;n++){let i=<span class="cstat-no" title="statement not covered" >t.nestArgument(String(n)),o</span>=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(o===void 0||be(o)){let s=<span class="cstat-no" title="statement not covered" >o===void 0?"undefined":"Prisma.skip";<span class="cstat-no" title="statement not covered" >t</span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${t.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}<span class="cstat-no" title="statement not covered" ></span>r</span>.push(Vo(o,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >nc(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="object"&amp;&amp;e!==null&amp;&amp;e.__prismaRawParameters__===!0}</span>function <span class="fstat-no" title="function not covered" >ic(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="object"&amp;&amp;e!==null&amp;&amp;typeof e.toJSON=="function"}</span>function <span class="fstat-no" title="function not covered" >Dn(e</span>,t){<span class="cstat-no" title="statement not covered" >e===void 0&amp;&amp;t.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;t.throwValidationError({kind:"InvalidSelectionValue",selectionPath:t.getSelectionPath(),underlyingError:jo})}</span>var In=<span class="cstat-no" title="statement not covered" >class e{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >this.params=t;<span class="cstat-no" title="statement not covered" >t</span>his.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName]</span>)}modelOrType;<span class="fstat-no" title="function not covered" >throwValidationError(t</span>){<span class="cstat-no" title="statement not covered" >_r({errors:[t],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}<span class="fstat-no" title="function not covered" ></span>getSelectionPath(){<span class="cstat-no" title="statement not covered" ></span>return this.params.selectionPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentPath(){<span class="cstat-no" title="statement not covered" ></span>return this.params.argumentPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentName(){<span class="cstat-no" title="statement not covered" ></span>return this.params.argumentPath[this.params.argumentPath.length-1]}<span class="fstat-no" title="function not covered" >g</span>etOutputTypeDescription(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!(!this.params.modelName||!this.modelOrType))<span class="cstat-no" title="statement not covered" >return{name:this.params.modelName,fields:this.modelOrType.fields.map(<span class="fstat-no" title="function not covered" >t=&gt;(<span class="cstat-no" title="statement not covered" >{</span>name:t.name,typeName:"boolean",isRelation:t.kind==="object"}))}</span>}<span class="fstat-no" title="function not covered" ></span></span>isRawAction(){<span class="cstat-no" title="statement not covered" ></span>return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}<span class="fstat-no" title="function not covered" ></span>isPreviewFeatureOn(t</span>){<span class="cstat-no" title="statement not covered" >return this.params.previewFeatures.includes(t)}<span class="fstat-no" title="function not covered" ></span>getComputedFields(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(this.params.modelName)<span class="cstat-no" title="statement not covered" >return this.params.extensions.getAllComputedFields(this.params.modelName)}<span class="fstat-no" title="function not covered" ></span></span>findField(t</span>){<span class="cstat-no" title="statement not covered" >return this.modelOrType?.fields.find(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.name===t)}<span class="fstat-no" title="function not covered" ></span></span>nestSelection(t</span>){let r=<span class="cstat-no" title="statement not covered" >this.findField(t),n</span>=<span class="cstat-no" title="statement not covered" >r?.kind==="object"?r.type:void 0;<span class="cstat-no" title="statement not covered" >r</span>eturn new e({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(t)})}<span class="fstat-no" title="function not covered" ></span>getGlobalOmit(){<span class="cstat-no" title="statement not covered" ></span>return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit?.[De(this.params.modelName)]??{}:{}}<span class="fstat-no" title="function not covered" ></span>shouldApplyGlobalOmit(){<span class="cstat-no" title="statement not covered" ></span>switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":<span class="cstat-no" title="statement not covered" >return!0;c</span>ase"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":<span class="cstat-no" title="statement not covered" >return!1;d</span>efault:<span class="cstat-no" title="statement not covered" >Pe(this.params.action,"Unknown action")}</span>}<span class="fstat-no" title="function not covered" ></span>nestArgument(t</span>){<span class="cstat-no" title="statement not covered" >return new e({...this.params,argumentPath:this.params.argumentPath.concat(t)})}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Qo(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e._hasPreviewFlag("metrics"))<span class="cstat-no" title="statement not covered" >throw new X("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:e._clientVersion})}</span></span>var Bt=<span class="cstat-no" title="statement not covered" >class{_client;<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >this._client=t}<span class="fstat-no" title="function not covered" ></span>prometheus(t</span>){<span class="cstat-no" title="statement not covered" >return Qo(this._client),this._client._engine.metrics({format:"prometheus",...t})}<span class="fstat-no" title="function not covered" ></span>json(t</span>){<span class="cstat-no" title="statement not covered" >return Qo(this._client),this._client._engine.metrics({format:"json",...t})}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >oc(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >At(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >s</span>c(t));<span class="cstat-no" title="statement not covered" >O</span></span>bject.defineProperty(e,"dmmf",{get:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >r</span>.get()}</span>)}</span>function <span class="fstat-no" title="function not covered" >sc(e</span>){<span class="cstat-no" title="statement not covered" >return{datamodel:{models:Mn(e.models),enums:Mn(e.enums),types:Mn(e.types)}}}</span>function <span class="fstat-no" title="function not covered" >Mn(e</span>){<span class="cstat-no" title="statement not covered" >return Object.entries(e).map(<span class="fstat-no" title="function not covered" >([</span>t,r])=&gt;(<span class="cstat-no" title="statement not covered" >{name:t,...r}))}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar _n=<span class="cstat-no" title="statement not covered" >new WeakMap,L</span>r=<span class="cstat-no" title="statement not covered" >"$$PrismaTypedSql",U</span>t=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >_n.set(this,{sql:t,values:r}),Object.defineProperty(this,Lr,{value:Lr})}<span class="fstat-no" title="function not covered" ></span>get s</span>ql(){<span class="cstat-no" title="statement not covered" >return _n.get(this).sql}<span class="fstat-no" title="function not covered" >g</span>et v</span>alues(){<span class="cstat-no" title="statement not covered" >return _n.get(this).values}}</span>;f</span>unction <span class="fstat-no" title="function not covered" >ac(e</span>){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;<span class="cstat-no" title="statement not covered" >new Ut(e,t)}</span></span>function <span class="fstat-no" title="function not covered" >Br(e</span>){<span class="cstat-no" title="statement not covered" >return e!=null&amp;&amp;e[Lr]===Lr}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar sa=<span class="cstat-no" title="statement not covered" >Qe(Jo());<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >W</span>o();<span class="cstat-no" title="statement not covered" >$</span>i();<span class="cstat-no" title="statement not covered" >Q</span>i();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar le=<span class="cstat-no" title="statement not covered" >class e{<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.length-1!==r.length)<span class="cstat-no" title="statement not covered" >throw t.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${t.length} strings to have ${t.length-1} values`);l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.reduce(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >s+(a instanceof e?a.values.length:1),0</span>);<span class="cstat-no" title="statement not covered" >t</span>his.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=t[0];l</span>et i=<span class="cstat-no" title="statement not covered" >0,o</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;i&lt;r.length;){let s=<span class="cstat-no" title="statement not covered" >r[i++],</span>a=<span class="cstat-no" title="statement not covered" >t[i];<span class="cstat-no" title="statement not covered" ></span>if(s instanceof e){<span class="cstat-no" title="statement not covered" >this.strings[o]+=s.strings[0];l</span>et l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;l&lt;s.values.length;)<span class="cstat-no" title="statement not covered" >this.values[o++]=s.values[l++],this.strings[o]=s.strings[l];<span class="cstat-no" title="statement not covered" >t</span></span>his.strings[o]+=a}</span>else <span class="cstat-no" title="statement not covered" >this.values[o++]=s,this.strings[o]=a}</span></span>}<span class="fstat-no" title="function not covered" ></span>get s</span>ql(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`?${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>get s</span>tatement(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`:${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>get t</span>ext(){let t=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;t;)<span class="cstat-no" title="statement not covered" >n+=`$${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>inspect(){<span class="cstat-no" title="statement not covered" ></span>return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}</span>};f</span>unction <span class="fstat-no" title="function not covered" >uc(e</span>,t=<span class="branch-0 cbranch-no" title="branch not covered" >",",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"")</span>{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===0)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new le([r,...Array(e.length-1).fill(t),n],e)}</span>function <span class="fstat-no" title="function not covered" >Ho(e</span>){<span class="cstat-no" title="statement not covered" >return new le([e],[])}</span>var cc=<span class="cstat-no" title="statement not covered" >Ho("");f</span>unction <span class="fstat-no" title="function not covered" >Ko(e</span>,...t){<span class="cstat-no" title="statement not covered" >return new le(e,t)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >qt(e</span>){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn Object.keys(e)}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(t</span>){<span class="cstat-no" title="statement not covered" >return e[t]}}</span>}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >ee(e</span>,t){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn[e]},<span class="fstat-no" title="function not covered" >g</span>etPropertyValue(){<span class="cstat-no" title="statement not covered" >r</span>eturn t()}</span>}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ue(e</span>){let t=<span class="cstat-no" title="statement not covered" >new ye;<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn e.getKeys()}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(r</span>){<span class="cstat-no" title="statement not covered" >return t.getOrCreate(r,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>.getPropertyValue(r))}</span></span>,<span class="fstat-no" title="function not covered" >getPropertyDescriptor(r</span>){<span class="cstat-no" title="statement not covered" >return e.getPropertyDescriptor?.(r)}</span>}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar qr=<span class="cstat-no" title="statement not covered" >{enumerable:!0,configurable:!0,writable:!0};f</span>unction <span class="fstat-no" title="function not covered" >$r(e</span>){let t=<span class="cstat-no" title="statement not covered" >new Set(e);<span class="cstat-no" title="statement not covered" >r</span>eturn{getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>bject.prototype,</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >q</span>r,h</span>as:<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >t.has(n),s</span>et:<span class="fstat-no" title="function not covered" >(r</span>,n,i)=&gt;<span class="cstat-no" title="statement not covered" >t.add(n)&amp;&amp;Reflect.set(r,n,i),o</span>wnKeys:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >[</span>...t]}}</span></span>var zo=<span class="cstat-no" title="statement not covered" >Symbol.for("nodejs.util.inspect.custom");f</span>unction <span class="fstat-no" title="function not covered" >pe(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >pc(t),n</span>=<span class="cstat-no" title="statement not covered" >new Set,i</span>=<span class="cstat-no" title="statement not covered" >new Proxy(e,{<span class="fstat-no" title="function not covered" >get(o</span>,s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.has(s))<span class="cstat-no" title="statement not covered" >return o[s];l</span></span>et a=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" >r</span>eturn a?a.getPropertyValue(s):o[s]},<span class="fstat-no" title="function not covered" >h</span>as(o</span>,s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.has(s))<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et a=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" >r</span>eturn a?a.has?.(s)??!0:Reflect.has(o,s)}</span>,<span class="fstat-no" title="function not covered" >ownKeys(o</span>){let s=<span class="cstat-no" title="statement not covered" >Yo(Reflect.ownKeys(o),r),a</span>=<span class="cstat-no" title="statement not covered" >Yo(Array.from(r.keys()),r);<span class="cstat-no" title="statement not covered" >r</span>eturn[...new Set([...s,...a,...n])]},<span class="fstat-no" title="function not covered" >s</span>et(o</span>,s,a){<span class="cstat-no" title="statement not covered" >return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))}</span>,<span class="fstat-no" title="function not covered" >getOwnPropertyDescriptor(o</span>,s){let a=<span class="cstat-no" title="statement not covered" >Reflect.getOwnPropertyDescriptor(o,s);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a&amp;&amp;!a.configurable)<span class="cstat-no" title="statement not covered" >return a;l</span></span>et l=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" >r</span>eturn l?l.getPropertyDescriptor?{...qr,...l?.getPropertyDescriptor(s)}:qr:a}</span>,<span class="fstat-no" title="function not covered" >defineProperty(o</span>,s,a){<span class="cstat-no" title="statement not covered" >return n.add(s),Reflect.defineProperty(o,s,a)}</span>,getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>bject.prototype}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn i[zo]=<span class="fstat-no" title="function not covered" >function(){l</span>et o=<span class="cstat-no" title="statement not covered" >{...this};<span class="cstat-no" title="statement not covered" >r</span>eturn delete o[zo],o}</span>,i}</span>function <span class="fstat-no" title="function not covered" >pc(e</span>){let t=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" >f</span>or(let r of e){let n=<span class="cstat-no" title="statement not covered" >r.getKeys();<span class="cstat-no" title="statement not covered" >f</span>or(let i of n)<span class="cstat-no" title="statement not covered" >t.set(i,r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Yo(e</span>,t){<span class="cstat-no" title="statement not covered" >return e.filter(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >t</span>.get(r)?.has?.(r)??!0)}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >ct(e</span>){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn e}</span>,<span class="fstat-no" title="function not covered" >has(){<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(){}</span>}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >jr(e</span>,t){<span class="cstat-no" title="statement not covered" >return{batch:e,transaction:t?.kind==="batch"?{isolationLevel:t.options.isolationLevel}:void 0}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Zo(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e===void 0)<span class="cstat-no" title="statement not covered" >return"";l</span></span>et t=<span class="cstat-no" title="statement not covered" >lt(e);<span class="cstat-no" title="statement not covered" >r</span>eturn new nt(0,{colors:kr}).write(t).toString()}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar mc=<span class="cstat-no" title="statement not covered" >"P2037";f</span>unction <span class="fstat-no" title="function not covered" >Vr({</span>error:e,user_facing_error:t},r,n){<span class="cstat-no" title="statement not covered" >return t.error_code?new oe(fc(t,n),{code:t.error_code,clientVersion:r,meta:t.meta,batchRequestIdx:t.batch_request_idx}):new se(e,{clientVersion:r,batchRequestIdx:t.batch_request_idx})}</span>function <span class="fstat-no" title="function not covered" >fc(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e.message;<span class="cstat-no" title="statement not covered" ></span>return(t==="postgresql"||t==="postgres"||t==="mysql")&amp;&amp;e.error_code===mc&amp;&amp;(r+=`</span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Nn=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >getLocation(){<span class="cstat-no" title="statement not covered" ></span>return null}</span>};f</span>unction <span class="fstat-no" title="function not covered" >_e(e</span>){<span class="cstat-no" title="statement not covered" >return typeof $EnabledCallSite=="function"&amp;&amp;e!=="minimal"?new $EnabledCallSite:new Nn}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Xo=<span class="cstat-no" title="statement not covered" >{_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};f</span>unction <span class="fstat-no" title="function not covered" >pt(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let t=<span class="cstat-no" title="statement not covered" >gc(e);<span class="cstat-no" title="statement not covered" >r</span>eturn Object.entries(t).reduce(<span class="fstat-no" title="function not covered" >(n</span>,[i,o])=&gt;(<span class="cstat-no" title="statement not covered" >Xo[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{</span>select:{}})}</span>function <span class="fstat-no" title="function not covered" >gc(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof e._count=="boolean"?{...e,_count:{_all:e._count}}:e}</span>function <span class="fstat-no" title="function not covered" >Gr(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=&gt;(<span class="cstat-no" title="statement not covered" >t</span>ypeof e._count=="boolean"&amp;&amp;(t._count=t._count._all),t)}</span></span>function <span class="fstat-no" title="function not covered" >es(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >Gr(e);<span class="cstat-no" title="statement not covered" >r</span>eturn t({action:"aggregate",unpacker:r,argsMapper:pt})(e)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >hc(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let{select:t,...r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn typeof t=="object"?pt({...r,_count:t}):pt({...r,_count:{_all:!0}})}</span>function <span class="fstat-no" title="function not covered" >yc(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof e.select=="object"?<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >G</span>r(e)(t)._count:<span class="fstat-no" title="function not covered" ></span>t=&gt;<span class="cstat-no" title="statement not covered" >G</span>r(e)(t)._count._all}</span>f</span>unction <span class="fstat-no" title="function not covered" >ts(e</span>,t){<span class="cstat-no" title="statement not covered" >return t({action:"count",unpacker:yc(e),argsMapper:hc})(e)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >wc(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let t=<span class="cstat-no" title="statement not covered" >pt(e);<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(t.by))<span class="cstat-no" title="statement not covered" >for(let r of t.by)<span class="cstat-no" title="statement not covered" >typeof r=="string"&amp;&amp;(t.select[r]=!0);else <span class="cstat-no" title="statement not covered" >t</span></span>ypeof t.by=="string"&amp;&amp;(t.select[t.by]=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Ec(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=&gt;(<span class="cstat-no" title="statement not covered" >t</span>ypeof e?._count=="boolean"&amp;&amp;t.forEach(<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >r</span>._count=r._count._all}),t</span>)}</span></span>function <span class="fstat-no" title="function not covered" >rs(e</span>,t){<span class="cstat-no" title="statement not covered" >return t({action:"groupBy",unpacker:Ec(e),argsMapper:wc})(e)}</span>function <span class="fstat-no" title="function not covered" >ns(e</span>,t,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t==="aggregate")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >e</span>s(n,r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(t==="count")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >t</span>s(n,r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(t==="groupBy")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >r</span>s(n,r)}<span class="cstat-no" title="statement not covered" ></span></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >is(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >t.fields.filter(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >!</span>i.relationName)</span>,n</span>=<span class="cstat-no" title="statement not covered" >wo(r,"name");<span class="cstat-no" title="statement not covered" >r</span>eturn new Proxy({},{<span class="fstat-no" title="function not covered" >get(i</span>,o){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o in i||typeof o=="symbol")<span class="cstat-no" title="statement not covered" >return i[o];l</span></span>et s=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(s)<span class="cstat-no" title="statement not covered" >return new Ot(e,o,s.type,s.isList,s.kind==="enum")}</span></span>,...$r(Object.keys(n))})}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar os=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >A</span>rray.isArray(e)?e:e.split("."),F</span></span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;<span class="cstat-no" title="statement not covered" >os(t).reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[n],</span>e),s</span></span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,t,r)=&gt;<span class="cstat-no" title="statement not covered" >os(t).reduceRight(<span class="fstat-no" title="function not covered" >(n</span>,i,o,s)=&gt;<span class="cstat-no" title="statement not covered" >Object.assign({},Fn(e,s.slice(0,o)),{[i]:n}),r</span>);f</span></span>unction <span class="fstat-no" title="function not covered" >bc(e</span>,t){<span class="cstat-no" title="statement not covered" >return e===void 0||t===void 0?[]:[...t,"select",e]}f</span>unction <span class="fstat-no" title="function not covered" >xc(e</span>,t,r){<span class="cstat-no" title="statement not covered" >return t===void 0?e??{}:ss(t,r,e||!0)}</span>function <span class="fstat-no" title="function not covered" >Ln(e</span>,t,r,n,i,o){let a=<span class="cstat-no" title="statement not covered" >e._runtimeDataModel.models[t].fields.reduce(<span class="fstat-no" title="function not covered" >(l</span>,d)=&gt;(<span class="cstat-no" title="statement not covered" >{...l,[d.name]:d}),{</span>});<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >l=&gt;{l</span>et d=<span class="cstat-no" title="statement not covered" >_e(e._errorFormat),g</span>=<span class="cstat-no" title="statement not covered" >bc(n,i),h</span>=<span class="cstat-no" title="statement not covered" >xc(l,o,g),v</span>=<span class="cstat-no" title="statement not covered" >r({dataPath:g,callsite:d})(h),S</span>=<span class="cstat-no" title="statement not covered" >Pc(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn new Proxy(v,{<span class="fstat-no" title="function not covered" >get(A</span>,R){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!S.includes(R))<span class="cstat-no" title="statement not covered" >return A[R];l</span></span>et M=<span class="cstat-no" title="statement not covered" >[a[R].type,r,R],B</span>=<span class="cstat-no" title="statement not covered" >[g,h];<span class="cstat-no" title="statement not covered" >r</span>eturn Ln(e,...M,...B)}</span>,...$r([...S,...Object.getOwnPropertyNames(v)])})}</span>}</span>function <span class="fstat-no" title="function not covered" >Pc(e</span>,t){<span class="cstat-no" title="statement not covered" >return e._runtimeDataModel.models[t].fields.filter(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.kind==="object").m</span>ap(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.name)</span>}</span>var vc=<span class="cstat-no" title="statement not covered" >["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],T</span>c=<span class="cstat-no" title="statement not covered" >["aggregate","count","groupBy"];f</span>unction <span class="fstat-no" title="function not covered" >Bn(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >e._extensions.getAllModelExtensions(t)??{},n</span>=<span class="cstat-no" title="statement not covered" >[Cc(e,t),Rc(e,t),qt(r),ee("name",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>),e</span>e("$name",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>),e</span>e("$parent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>._appliedParent)</span>];<span class="cstat-no" title="statement not covered" >r</span>eturn pe({},n)}</span>function <span class="fstat-no" title="function not covered" >Cc(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >Ee(t),n</span>=<span class="cstat-no" title="statement not covered" >Object.keys(Rt).concat("count");<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(i</span>){let o=<span class="cstat-no" title="statement not covered" >i,s</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >l</span>=&gt;{l</span>et d=<span class="cstat-no" title="statement not covered" >_e(e._errorFormat);<span class="cstat-no" title="statement not covered" >r</span>eturn e._createPrismaPromise(<span class="fstat-no" title="function not covered" >g=&gt;{l</span>et h=<span class="cstat-no" title="statement not covered" >{args:l,dataPath:[],action:o,model:t,clientMethod:`${r}.${i}`,jsModelName:r,transaction:g,callsite:d};<span class="cstat-no" title="statement not covered" >r</span>eturn e._request({...h,...a})}</span>,{action:o,args:l,model:t})}</span>;<span class="cstat-no" title="statement not covered" >r</span></span>eturn vc.includes(o)?Ln(e,t,s):Ac(i)?ns(e,i,s):s({})}</span>}}</span>function <span class="fstat-no" title="function not covered" >Ac(e</span>){<span class="cstat-no" title="statement not covered" >return Tc.includes(e)}</span>function <span class="fstat-no" title="function not covered" >Rc(e</span>,t){<span class="cstat-no" title="statement not covered" >return Ue(ee("fields",<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >e._runtimeDataModel.models[t];<span class="cstat-no" title="statement not covered" ></span>return is(t,r)}</span>))}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >as(e</span>){<span class="cstat-no" title="statement not covered" >return e.replace(/^./,<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.toUpperCase())}</span></span>var Un=<span class="cstat-no" title="statement not covered" >Symbol();f</span>unction <span class="fstat-no" title="function not covered" >$t(e</span>){let t=<span class="cstat-no" title="statement not covered" >[Sc(e),kc(e),ee(Un,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>),e</span>e("$parent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>._appliedParent)</span>],r</span>=<span class="cstat-no" title="statement not covered" >e._extensions.getAllClientExtensions();<span class="cstat-no" title="statement not covered" >r</span>eturn r&amp;&amp;t.push(qt(r)),pe(e,t)}</span>function <span class="fstat-no" title="function not covered" >Sc(e</span>){let t=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(e._originalClient),r</span>=<span class="cstat-no" title="statement not covered" >[...new Set(Object.getOwnPropertyNames(t))];<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(n</span>){<span class="cstat-no" title="statement not covered" >return e[n]}}</span>}</span>function <span class="fstat-no" title="function not covered" >kc(e</span>){let t=<span class="cstat-no" title="statement not covered" >Object.keys(e._runtimeDataModel.models),r</span>=<span class="cstat-no" title="statement not covered" >t.map(Ee),n</span>=<span class="cstat-no" title="statement not covered" >[...new Set(t.concat(r))];<span class="cstat-no" title="statement not covered" >r</span>eturn Ue({<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(i</span>){let o=<span class="cstat-no" title="statement not covered" >as(i);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e._runtimeDataModel.models[o]!==void 0)<span class="cstat-no" title="statement not covered" >return Bn(e,o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e._runtimeDataModel.models[i]!==void 0)<span class="cstat-no" title="statement not covered" >return Bn(e,i)}</span></span>,<span class="fstat-no" title="function not covered" >getPropertyDescriptor(i</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!r.includes(i))<span class="cstat-no" title="statement not covered" >return{enumerable:!1}}</span></span>})}</span>function <span class="fstat-no" title="function not covered" >ls(e</span>){<span class="cstat-no" title="statement not covered" >return e[Un]?e[Un]:e}</span>function <span class="fstat-no" title="function not covered" >us(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="function")<span class="cstat-no" title="statement not covered" >return e(this);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.client?.__AccelerateEngine){let r=<span class="cstat-no" title="statement not covered" >e.client.__AccelerateEngine;<span class="cstat-no" title="statement not covered" ></span>this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >Object.create(this._originalClient,{_extensions:{value:this._extensions.append(e)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});<span class="cstat-no" title="statement not covered" >r</span>eturn $t(t)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >cs({</span>result:e,modelName:t,select:r,omit:n,extensions:i}){let o=<span class="cstat-no" title="statement not covered" >i.getAllComputedFields(t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o)<span class="cstat-no" title="statement not covered" >return e;l</span></span>et s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let l of Object.values(o)){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n[l.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et d=<span class="cstat-no" title="statement not covered" >l.needs.filter(<span class="fstat-no" title="function not covered" >g=&gt;<span class="cstat-no" title="statement not covered" >n</span>[g])</span>;<span class="cstat-no" title="statement not covered" >d</span>.length&gt;0&amp;&amp;a.push(ct(d))}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!r[l.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et d=<span class="cstat-no" title="statement not covered" >l.needs.filter(<span class="fstat-no" title="function not covered" >g=&gt;<span class="cstat-no" title="statement not covered" >!</span>r[g])</span>;<span class="cstat-no" title="statement not covered" >d</span>.length&gt;0&amp;&amp;a.push(ct(d))}<span class="cstat-no" title="statement not covered" ></span>I</span></span>c(e,l.needs)&amp;&amp;s.push(Oc(l,pe(e,s)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.length&gt;0||a.length&gt;0?pe(e,[...s,...a]):e}</span>function <span class="fstat-no" title="function not covered" >Ic(e</span>,t){<span class="cstat-no" title="statement not covered" >return t.every(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >g</span>n(e,r))}</span></span>function <span class="fstat-no" title="function not covered" >Oc(e</span>,t){<span class="cstat-no" title="statement not covered" >return Ue(ee(e.name,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>.compute(t)))}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Qr({</span>visitor:e,result:t,args:r,runtimeDataModel:n,modelName:i}){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(Array.isArray(t)){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;t.length;s++)<span class="cstat-no" title="statement not covered" >t[s]=Qr({result:t[s],args:r,modelName:i,runtimeDataModel:n,visitor:e});<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >e(t,i,r)??t;<span class="cstat-no" title="statement not covered" >r</span>eturn r.include&amp;&amp;ps({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),r.select&amp;&amp;ps({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:e}),o}</span>function <span class="fstat-no" title="function not covered" >ps({</span>includeOrSelect:e,result:t,parentModelName:r,runtimeDataModel:n,visitor:i}){<span class="cstat-no" title="statement not covered" >for(let[o,s]of Object.entries(e)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!s||t[o]==null||be(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et l=<span class="cstat-no" title="statement not covered" >n.models[r].fields.find(<span class="fstat-no" title="function not covered" >g=&gt;<span class="cstat-no" title="statement not covered" >g</span>.name===o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!l||l.kind!=="object"||!l.relationName)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et d=<span class="cstat-no" title="statement not covered" >typeof s=="object"?s:{};<span class="cstat-no" title="statement not covered" >t</span>[o]=Qr({visitor:i,result:t[o],args:d,modelName:l.type,runtimeDataModel:n})}</span>}</span>function <span class="fstat-no" title="function not covered" >ms({</span>result:e,modelName:t,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){<span class="cstat-no" title="statement not covered" >return n.isEmpty()||e==null||typeof e!="object"||!i.models[t]?e:Qr({result:e,args:r??{},modelName:t,runtimeDataModel:i,visitor:<span class="fstat-no" title="function not covered" >(a</span>,l,d)=&gt;{let g=<span class="cstat-no" title="statement not covered" >Ee(l);<span class="cstat-no" title="statement not covered" >r</span>eturn cs({result:a,modelName:g,select:d.select,omit:d.select?void 0:{...o?.[g],...d.omit},extensions:n})}</span>})}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Dc=<span class="cstat-no" title="statement not covered" >["$connect","$disconnect","$on","$transaction","$use","$extends"],f</span>s=<span class="cstat-no" title="statement not covered" >Dc;f</span>unction <span class="fstat-no" title="function not covered" >ds(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e instanceof le)<span class="cstat-no" title="statement not covered" >return Mc(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Br(e))<span class="cstat-no" title="statement not covered" >return _c(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(e)){let r=<span class="cstat-no" title="statement not covered" >[e[0]];<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >1;n</span>&lt;e.length;n++)<span class="cstat-no" title="statement not covered" >r[n]=jt(e[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>l</span>et t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r in e)<span class="cstat-no" title="statement not covered" >t[r]=jt(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Mc(e</span>){<span class="cstat-no" title="statement not covered" >return new le(e.strings,e.values)}</span>function <span class="fstat-no" title="function not covered" >_c(e</span>){<span class="cstat-no" title="statement not covered" >return new Ut(e.sql,e.values)}</span>function <span class="fstat-no" title="function not covered" >jt(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="object"||e==null||e instanceof Te||at(e))<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(rt(e))<span class="cstat-no" title="statement not covered" >return new he(e.toFixed());<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(tt(e))<span class="cstat-no" title="statement not covered" >return new Date(+e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(e))<span class="cstat-no" title="statement not covered" >return e.slice(0);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(e)){let t=<span class="cstat-no" title="statement not covered" >e.length,</span>r;<span class="cstat-no" title="statement not covered" >for(r=Array(t);t--;)<span class="cstat-no" title="statement not covered" >r[t]=jt(e[t]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(typeof e=="object"){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r in e)<span class="cstat-no" title="statement not covered" >r==="__proto__"?Object.defineProperty(t,r,{value:jt(e[r]),configurable:!0,enumerable:!0,writable:!0}):t[r]=jt(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="cstat-no" title="statement not covered" ></span>P</span>e(e,"Unknown value")}</span>function <span class="fstat-no" title="function not covered" >hs(e</span>,t,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return e._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >t.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return"transaction"in t&amp;&amp;i!==void 0&amp;&amp;(t.transaction?.kind==="batch"&amp;&amp;t.transaction.lock.then(),t.transaction=i),n===r.length?e._executeRequest(t):r[n]({model:t.model,operation:t.model?t.action:t.clientMethod,args:ds(t.args??{}),__internalParams:t,query:<span class="fstat-no" title="function not covered" >(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >t)</span>=&gt;{let l=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=bs(o,l),a.args=s,hs(e,a,r,n+1)}</span>})}</span>)}</span>function <span class="fstat-no" title="function not covered" >ys(e</span>,t){let{jsModelName:r,action:n,clientMethod:i}=<span class="cstat-no" title="statement not covered" >t,o</span>=<span class="cstat-no" title="statement not covered" >r?n:i;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e._extensions.isEmpty())<span class="cstat-no" title="statement not covered" >return e._executeRequest(t);l</span></span>et s=<span class="cstat-no" title="statement not covered" >e._extensions.getAllQueryCallbacks(r??"$none",o);<span class="cstat-no" title="statement not covered" >r</span>eturn hs(e,t,s)}</span>function <span class="fstat-no" title="function not covered" >ws(e</span>){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >t=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >{requests:t},n</span>=<span class="cstat-no" title="statement not covered" >t[0].extensions.getAllBatchQueryCallbacks();<span class="cstat-no" title="statement not covered" >r</span>eturn n.length?Es(r,n,0,e):e(r)}</span>}</span>function <span class="fstat-no" title="function not covered" >Es(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r===t.length)<span class="cstat-no" title="statement not covered" >return n(e);l</span></span>et i=<span class="cstat-no" title="statement not covered" >e.customDataProxyFetch,</span>o=<span class="cstat-no" title="statement not covered" >e.requests[0].transaction;<span class="cstat-no" title="statement not covered" ></span>return t[r]({args:{queries:e.requests.map(<span class="fstat-no" title="function not covered" >s=&gt;(<span class="cstat-no" title="statement not covered" >{</span>model:s.modelName,operation:s.action,args:s.args})),t</span>ransaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:e,<span class="fstat-no" title="function not covered" >query(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{let l=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=bs(i,l),Es(a,t,r+1,n)}</span>})}</span>var gs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>;f</span></span>unction <span class="fstat-no" title="function not covered" >bs(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >gs,</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >gs)</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >e</span>(t(r))}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar xs=<span class="cstat-no" title="statement not covered" >Y("prisma:client"),P</span>s=<span class="cstat-no" title="statement not covered" >{Vercel:"vercel","Netlify CI":"netlify"};f</span>unction <span class="fstat-no" title="function not covered" >vs({</span>postinstall:e,ciName:t,clientVersion:r}){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(xs("checkPlatformCaching:postinstall",e),xs("checkPlatformCaching:ciName",t),e===!0&amp;&amp;t&amp;&amp;t in Ps){let n=<span class="cstat-no" title="statement not covered" >`Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span></span>
&nbsp;
Learn how: https://pris.ly/d/${Ps[t]}-build`;<span class="cstat-no" title="statement not covered" >throw console.error(n),new Q(n,r)}</span>}<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ts(e</span>,t){<span class="cstat-no" title="statement not covered" >return e?e.datasources?e.datasources:e.datasourceUrl?{[t[0]]:{url:e.datasourceUrl}}:{}:{}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Nc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>lobalThis.process?.release?.name==="node",F</span></span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>!globalThis.Bun||!!globalThis.process?.versions?.bun,L</span></span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>!globalThis.Deno,</span></span>Bc=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis.Netlify=="object",U</span></span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis.EdgeRuntime=="object",q</span></span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>lobalThis.navigator?.userAgent==="Cloudflare-Workers";f</span></span>unction <span class="fstat-no" title="function not covered" >$c(){<span class="cstat-no" title="statement not covered" >r</span>eturn[[Bc,"netlify"],[Uc,"edge-light"],[qc,"workerd"],[Lc,"deno"],[Fc,"bun"],[Nc,"node"]].flatMap(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>[0]()?[r[1]]:[])</span>.at(0)??""}</span>var jc=<span class="cstat-no" title="statement not covered" >{node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};f</span>unction <span class="fstat-no" title="function not covered" >qn(){l</span>et e=<span class="cstat-no" title="statement not covered" >$c();<span class="cstat-no" title="statement not covered" >r</span>eturn{id:e,prettyName:jc[e]||e,isEdge:["workerd","deno","netlify","edge-light"].includes(e)}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Cs=<span class="cstat-no" title="statement not covered" >"6.8.2";<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >mt({</span>inlineDatasources:e,overrideDatasources:t,env:r,clientVersion:n}){let i,o=<span class="cstat-no" title="statement not covered" >Object.keys(e)[0],</span>s=<span class="cstat-no" title="statement not covered" >e[o]?.url,a</span>=<span class="cstat-no" title="statement not covered" >t[o]?.url;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&amp;&amp;(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&amp;&amp;i===void 0)<span class="cstat-no" title="statement not covered" >throw qn().id==="workerd"?new Q(`error: Environment variable not found: ${s.fromEnvVar}.</span></span>
&nbsp;
In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`,n):new Q(`error: Environment variable not found: ${s.fromEnvVar}.`,n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i===void 0)<span class="cstat-no" title="statement not covered" >throw new Q("error: Missing URL environment variable, value, or override.",n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Jr=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;cause;<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super(t),this.clientVersion=r.clientVersion,this.cause=r.cause}<span class="fstat-no" title="function not covered" >g</span>et[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return this.name}}</span>;v</span>ar ne=<span class="cstat-no" title="statement not covered" >class extends Jr{isRetryable;<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super(t,r),this.isRetryable=r.isRetryable??!0}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >L(e</span>,t){<span class="cstat-no" title="statement not covered" >return{...e,isRetryable:t}}</span>var ft=<span class="cstat-no" title="statement not covered" >class extends ne{name="ForcedRetryError";code="P5001";<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super("This request must be retried",L(t,!0))}};<span class="cstat-no" title="statement not covered" >N</span>(ft,"ForcedRetryError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar qe=<span class="cstat-no" title="statement not covered" >class extends ne{name="InvalidDatasourceError";code="P6001";<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super(t,L(r,!1))}};<span class="cstat-no" title="statement not covered" >N</span>(qe,"InvalidDatasourceError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar $e=<span class="cstat-no" title="statement not covered" >class extends ne{name="NotImplementedYetError";code="P5004";<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super(t,L(r,!1))}};<span class="cstat-no" title="statement not covered" >N</span>($e,"NotImplementedYetError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar V=<span class="cstat-no" title="statement not covered" >class extends ne{response;<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super(t,r),this.response=r.response;l</span>et n=<span class="cstat-no" title="statement not covered" >this.response.headers.get("prisma-request-id");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >`(The request id was: ${n})`;<span class="cstat-no" title="statement not covered" ></span>this.message=this.message+" "+i}</span>}</span>};v</span>ar je=<span class="cstat-no" title="statement not covered" >class extends V{name="SchemaMissingError";code="P5005";<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super("Schema needs to be uploaded",L(t,!0))}};<span class="cstat-no" title="statement not covered" >N</span>(je,"SchemaMissingError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar $n=<span class="cstat-no" title="statement not covered" >"This request could not be understood by the server",V</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="BadRequestError";code="P5000";<span class="fstat-no" title="function not covered" >constructor(t</span>,r,n){<span class="cstat-no" title="statement not covered" >super(r||$n,L(t,!1)),n&amp;&amp;(this.code=n)}</span>};<span class="cstat-no" title="statement not covered" >N</span>(Vt,"BadRequestError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Gt=<span class="cstat-no" title="statement not covered" >class extends V{name="HealthcheckTimeoutError";code="P5013";logs;<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super("Engine not started: healthcheck timeout",L(t,!0)),this.logs=r}</span>};<span class="cstat-no" title="statement not covered" >N</span>(Gt,"HealthcheckTimeoutError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Qt=<span class="cstat-no" title="statement not covered" >class extends V{name="EngineStartupError";code="P5014";logs;<span class="fstat-no" title="function not covered" >constructor(t</span>,r,n){<span class="cstat-no" title="statement not covered" >super(r,L(t,!0)),this.logs=n}</span>};<span class="cstat-no" title="statement not covered" >N</span>(Qt,"EngineStartupError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Jt=<span class="cstat-no" title="statement not covered" >class extends V{name="EngineVersionNotSupportedError";code="P5012";<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super("Engine version is not supported",L(t,!1))}};<span class="cstat-no" title="statement not covered" >N</span>(Jt,"EngineVersionNotSupportedError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar jn=<span class="cstat-no" title="statement not covered" >"Request timed out",W</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="GatewayTimeoutError";code="P5009";<span class="fstat-no" title="function not covered" >constructor(t</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >jn)</span>{<span class="cstat-no" title="statement not covered" >super(r,L(t,!1))}};<span class="cstat-no" title="statement not covered" >N</span>(Wt,"GatewayTimeoutError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Gc=<span class="cstat-no" title="statement not covered" >"Interactive transaction error",H</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="InteractiveTransactionError";code="P5015";<span class="fstat-no" title="function not covered" >constructor(t</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >Gc)</span>{<span class="cstat-no" title="statement not covered" >super(r,L(t,!1))}};<span class="cstat-no" title="statement not covered" >N</span>(Ht,"InteractiveTransactionError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Qc=<span class="cstat-no" title="statement not covered" >"Request parameters are invalid",K</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="InvalidRequestError";code="P5011";<span class="fstat-no" title="function not covered" >constructor(t</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >Qc)</span>{<span class="cstat-no" title="statement not covered" >super(r,L(t,!1))}};<span class="cstat-no" title="statement not covered" >N</span>(Kt,"InvalidRequestError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Vn=<span class="cstat-no" title="statement not covered" >"Requested resource does not exist",z</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="NotFoundError";code="P5003";<span class="fstat-no" title="function not covered" >constructor(t</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >Vn)</span>{<span class="cstat-no" title="statement not covered" >super(r,L(t,!1))}};<span class="cstat-no" title="statement not covered" >N</span>(zt,"NotFoundError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Gn=<span class="cstat-no" title="statement not covered" >"Unknown server error",d</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="ServerError";code="P5006";logs;<span class="fstat-no" title="function not covered" >constructor(t</span>,r,n){<span class="cstat-no" title="statement not covered" >super(r||Gn,L(t,!0)),this.logs=n}</span>};<span class="cstat-no" title="statement not covered" >N</span>(dt,"ServerError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Qn=<span class="cstat-no" title="statement not covered" >"Unauthorized, check your connection string",Y</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="UnauthorizedError";code="P5007";<span class="fstat-no" title="function not covered" >constructor(t</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >Qn)</span>{<span class="cstat-no" title="statement not covered" >super(r,L(t,!1))}};<span class="cstat-no" title="statement not covered" >N</span>(Yt,"UnauthorizedError");<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Jn=<span class="cstat-no" title="statement not covered" >"Usage exceeded, retry again later",Z</span>t=<span class="cstat-no" title="statement not covered" >class extends V{name="UsageExceededError";code="P5008";<span class="fstat-no" title="function not covered" >constructor(t</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >Jn)</span>{<span class="cstat-no" title="statement not covered" >super(r,L(t,!0))}};<span class="cstat-no" title="statement not covered" >N</span>(Zt,"UsageExceededError");a</span>sync function <span class="fstat-no" title="function not covered" >Jc(e</span>){let t;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=await e.text()}</span>catch{<span class="cstat-no" title="statement not covered" >return{type:"EmptyError"}}<span class="cstat-no" title="statement not covered" ></span>t</span>ry{let r=<span class="cstat-no" title="statement not covered" >JSON.parse(t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(typeof r=="string")<span class="cstat-no" title="statement not covered" >switch(r){case"InternalDataProxyError":<span class="cstat-no" title="statement not covered" >return{type:"DataProxyError",body:r};d</span>efault:<span class="cstat-no" title="statement not covered" >return{type:"UnknownTextError",body:r}}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span></span>f(typeof r=="object"&amp;&amp;r!==null){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if("is_panic"in r&amp;&amp;"message"in r&amp;&amp;"error_code"in r)<span class="cstat-no" title="statement not covered" >return{type:"QueryEngineError",body:r};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f("EngineNotStarted"in r||"InteractiveTransactionMisrouted"in r||"InvalidRequestError"in r){let n=<span class="cstat-no" title="statement not covered" >Object.values(r)[0].reason;<span class="cstat-no" title="statement not covered" ></span>return typeof n=="string"&amp;&amp;!["SchemaMissing","EngineVersionNotSupported"].includes(n)?{type:"UnknownJsonError",body:r}:{type:"DataProxyError",body:r}}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{type:"UnknownJsonError",body:r}}</span>catch{<span class="cstat-no" title="statement not covered" >return t===""?{type:"EmptyError"}:{type:"UnknownTextError",body:t}}</span>}</span>async function <span class="fstat-no" title="function not covered" >Xt(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.ok)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{clientVersion:t,response:e},n</span>=<span class="cstat-no" title="statement not covered" >await Jc(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n.type==="QueryEngineError")<span class="cstat-no" title="statement not covered" >throw new oe(n.body.message,{code:n.body.error_code,clientVersion:t});<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n.type==="DataProxyError"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.body==="InternalDataProxyError")<span class="cstat-no" title="statement not covered" >throw new dt(r,"Internal Data Proxy error");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f("EngineNotStarted"in n.body){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.body.EngineNotStarted.reason==="SchemaMissing")<span class="cstat-no" title="statement not covered" >return new je(r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n.body.EngineNotStarted.reason==="EngineVersionNotSupported")<span class="cstat-no" title="statement not covered" >throw new Jt(r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f("EngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,logs:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.EngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new Qt(r,i,o)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f("KnownEngineStartupError"in n.body.EngineNotStarted.reason){let{msg:i,error_code:o}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.KnownEngineStartupError;<span class="cstat-no" title="statement not covered" ></span>throw new Q(i,t,o)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f("HealthcheckTimeout"in n.body.EngineNotStarted.reason){let{logs:i}=<span class="cstat-no" title="statement not covered" >n.body.EngineNotStarted.reason.HealthcheckTimeout;<span class="cstat-no" title="statement not covered" ></span>throw new Gt(r,i)}</span>}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f("InteractiveTransactionMisrouted"in n.body){let i=<span class="cstat-no" title="statement not covered" >{IDParseError:"Could not parse interactive transaction ID",NoQueryEngineFoundError:"Could not find Query Engine for the specified host and transaction ID",TransactionStartError:"Could not start interactive transaction"};<span class="cstat-no" title="statement not covered" >t</span>hrow new Ht(r,i[n.body.InteractiveTransactionMisrouted.reason])}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f("InvalidRequestError"in n.body)<span class="cstat-no" title="statement not covered" >throw new Kt(r,n.body.InvalidRequestError.reason)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span></span>i</span>f(e.status===401||e.status===403)<span class="cstat-no" title="statement not covered" >throw new Yt(r,gt(Qn,n));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.status===404)<span class="cstat-no" title="statement not covered" >return new zt(r,gt(Vn,n));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.status===429)<span class="cstat-no" title="statement not covered" >throw new Zt(r,gt(Jn,n));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.status===504)<span class="cstat-no" title="statement not covered" >throw new Wt(r,gt(jn,n));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.status&gt;=500)<span class="cstat-no" title="statement not covered" >throw new dt(r,gt(Gn,n));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.status&gt;=400)<span class="cstat-no" title="statement not covered" >throw new Vt(r,gt($n,n))}</span></span>function <span class="fstat-no" title="function not covered" >gt(e</span>,t){<span class="cstat-no" title="statement not covered" >return t.type==="EmptyError"?e:`${e}: ${JSON.stringify(t)}`}<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >As(e</span>){let t=<span class="cstat-no" title="statement not covered" >Math.pow(2,e)*50,r</span>=<span class="cstat-no" title="statement not covered" >Math.ceil(Math.random()*t)-Math.ceil(t/2),n</span>=<span class="cstat-no" title="statement not covered" >t+r;<span class="cstat-no" title="statement not covered" >r</span>eturn new Promise(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >s</span>etTimeout(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>(n),n</span>))}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Ce=<span class="cstat-no" title="statement not covered" >"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";f</span>unction <span class="fstat-no" title="function not covered" >Rs(e</span>){let t=<span class="cstat-no" title="statement not covered" >new TextEncoder().encode(e),r</span>=<span class="cstat-no" title="statement not covered" >"",n</span>=<span class="cstat-no" title="statement not covered" >t.byteLength,</span>i=<span class="cstat-no" title="statement not covered" >n%3,o</span>=<span class="cstat-no" title="statement not covered" >n-i,s</span>,a,l,d,g;<span class="cstat-no" title="statement not covered" >for(let h=<span class="cstat-no" title="statement not covered" >0;h</span>&lt;o;h=h+3)<span class="cstat-no" title="statement not covered" >g=t[h]&lt;&lt;16|t[h+1]&lt;&lt;8|t[h+2],s=(g&amp;16515072)&gt;&gt;18,a=(g&amp;258048)&gt;&gt;12,l=(g&amp;4032)&gt;&gt;6,d=g&amp;63,r+=Ce[s]+Ce[a]+Ce[l]+Ce[d];<span class="cstat-no" title="statement not covered" >r</span></span>eturn i==1?(g=t[o],s=(g&amp;252)&gt;&gt;2,a=(g&amp;3)&lt;&lt;4,r+=Ce[s]+Ce[a]+"=="):i==2&amp;&amp;(g=t[o]&lt;&lt;8|t[o+1],s=(g&amp;64512)&gt;&gt;10,a=(g&amp;1008)&gt;&gt;4,l=(g&amp;15)&lt;&lt;2,r+=Ce[s]+Ce[a]+Ce[l]+"="),r}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ss(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!!e.generator?.previewFeatures.some(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.toLowerCase().includes("metrics")))<span class="cstat-no" title="statement not covered" >t</span>hrow new Q("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate",e.clientVersion)}<span class="cstat-no" title="statement not covered" ></span></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Wc(e</span>){<span class="cstat-no" title="statement not covered" >return e[0]*1e3+e[1]/1e6}</span>function <span class="fstat-no" title="function not covered" >Wn(e</span>){<span class="cstat-no" title="statement not covered" >return new Date(Wc(e))}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar ks=<span class="cstat-no" title="statement not covered" >{"@prisma/debug":"workspace:*","@prisma/engines-version":"6.8.0-43.2060c79ba17c6bb9f5823312b6f6b7f4a845738e","@prisma/fetch-engine":"workspace:*","@prisma/get-platform":"workspace:*"};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar er=<span class="cstat-no" title="statement not covered" >class extends ne{name="RequestError";code="P5010";<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >super(`Cannot fetch data from service:</span></span></span></span></span></span></span></span></span></span></span></span></span>
${t}`,L(r,!0))}};<span class="cstat-no" title="statement not covered" >N(er,"RequestError");a</span>sync function <span class="fstat-no" title="function not covered" >Ve(e</span>,t,r=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>)</span></span>{let{clientVersion:n,...i}=<span class="cstat-no" title="statement not covered" >t,o</span>=<span class="cstat-no" title="statement not covered" >r(fetch);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return await o(e,i)}</span>catch(s){let a=<span class="cstat-no" title="statement not covered" >s.message??"Unknown error";<span class="cstat-no" title="statement not covered" >t</span>hrow new er(a,{clientVersion:n,cause:s})}</span>}</span>var Kc=<span class="cstat-no" title="statement not covered" >/^[1-9][0-9]*\.[0-9]+\.[0-9]+$/,I</span>s=<span class="cstat-no" title="statement not covered" >Y("prisma:client:dataproxyEngine");a</span>sync function <span class="fstat-no" title="function not covered" >zc(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >ks["@prisma/engines-version"],</span>n=<span class="cstat-no" title="statement not covered" >t.clientVersion??"unknown";<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)<span class="cstat-no" title="statement not covered" >return y.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION||globalThis.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.includes("accelerate")&amp;&amp;n!=="0.0.0"&amp;&amp;n!=="in-memory")<span class="cstat-no" title="statement not covered" >return n;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >n?.split("-")??[];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(o===void 0&amp;&amp;Kc.test(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(o!==void 0||n==="0.0.0"||n==="in-memory"){let[s]=<span class="cstat-no" title="statement not covered" >r.split("-")??[],</span>[a,l,d]=<span class="cstat-no" title="statement not covered" >s.split("."),g</span>=<span class="cstat-no" title="statement not covered" >Yc(`&lt;=${a}.${l}.${d}`),h</span>=<span class="cstat-no" title="statement not covered" >await Ve(g,{clientVersion:n});<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!h.ok)<span class="cstat-no" title="statement not covered" >throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${h.status} ${h.statusText}, response body: ${await h.text()||"&lt;empty body&gt;"}`);l</span></span>et v=<span class="cstat-no" title="statement not covered" >await h.text();<span class="cstat-no" title="statement not covered" >I</span>s("length of body fetched from unpkg.com",v.length);l</span>et S;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >S=JSON.parse(v)}</span>catch(A){<span class="cstat-no" title="statement not covered" >throw console.error("JSON.parse error: body fetched from unpkg.com: ",v),A}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn S.version}<span class="cstat-no" title="statement not covered" >t</span></span>hrow new $e("Only `major.minor.patch` versions are supported by Accelerate.",{clientVersion:n})}</span>async function <span class="fstat-no" title="function not covered" >Os(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >await zc(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn Is("version",r),r}</span>function <span class="fstat-no" title="function not covered" >Yc(e</span>){<span class="cstat-no" title="statement not covered" >return encodeURI(`https://unpkg.com/prisma@${e}/package.json`)}</span>var Ds=<span class="cstat-no" title="statement not covered" >3,t</span>r=<span class="cstat-no" title="statement not covered" >Y("prisma:client:dataproxyEngine"),H</span>n=<span class="cstat-no" title="statement not covered" >class{apiKey;tracingHelper;logLevel;logQueries;engineHash;<span class="fstat-no" title="function not covered" >constructor({</span>apiKey:t,tracingHelper:r,logLevel:n,logQueries:i,engineHash:o}){<span class="cstat-no" title="statement not covered" >this.apiKey=t,this.tracingHelper=r,this.logLevel=n,this.logQueries=i,this.engineHash=o}<span class="fstat-no" title="function not covered" ></span>build({</span>traceparent:t,interactiveTransaction:r}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let n=<span class="cstat-no" title="statement not covered" >{Authorization:`Bearer ${this.apiKey}`,"Prisma-Engine-Hash":this.engineHash};<span class="cstat-no" title="statement not covered" >t</span>his.tracingHelper.isEnabled()&amp;&amp;(n.traceparent=t??this.tracingHelper.getTraceParent()),r&amp;&amp;(n["X-transaction-id"]=r.id</span>);let i=<span class="cstat-no" title="statement not covered" >this.buildCaptureSettings();<span class="cstat-no" title="statement not covered" >r</span>eturn i.length&gt;0&amp;&amp;(n["X-capture-telemetry"]=i.join(", ")),n}<span class="fstat-no" title="function not covered" ></span>buildCaptureSettings(){</span>let t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return this.tracingHelper.isEnabled()&amp;&amp;t.push("tracing"),this.logLevel&amp;&amp;t.push(this.logLevel),this.logQueries&amp;&amp;t.push("query"),t}</span>},h</span>t=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >name="DataProxyEngine";inlineSchema;inlineSchemaHash;inlineDatasources;config;logEmitter;env;clientVersion;engineHash;tracingHelper;remoteClientVersion;host;headerBuilder;startPromise;protocol;<span class="fstat-no" title="function not covered" >c</span>onstructor(t</span>){<span class="cstat-no" title="statement not covered" >Ss(t),this.config=t,this.env={...t.env,...typeof y&lt;"u"?y.env:{}},this.inlineSchema=Rs(t.inlineSchema),this.inlineDatasources=t.inlineDatasources,this.inlineSchemaHash=t.inlineSchemaHash,this.clientVersion=t.clientVersion,this.engineHash=t.engineVersion,this.logEmitter=t.logEmitter,this.tracingHelper=t.tracingHelper}<span class="fstat-no" title="function not covered" >a</span>piKey(){<span class="cstat-no" title="statement not covered" ></span>return this.headerBuilder.apiKey}<span class="fstat-no" title="function not covered" >v</span>ersion(){<span class="cstat-no" title="statement not covered" ></span>return this.engineHash}<span class="fstat-no" title="function not covered" >a</span>sync s</span>tart(){<span class="cstat-no" title="statement not covered" >this.startPromise!==void 0&amp;&amp;await this.startPromise,this.startPromise=(<span class="fstat-no" title="function not covered" >async()=&gt;{l</span>et{apiKey:t,url:r}=<span class="cstat-no" title="statement not covered" >this.getURLAndAPIKey();<span class="cstat-no" title="statement not covered" >t</span>his.host=r.host,this.headerBuilder=new Hn({apiKey:t,tracingHelper:this.tracingHelper,logLevel:this.config.logLevel,logQueries:this.config.logQueries,engineHash:this.engineHash}),this.protocol=fn(r)?"http":"https",this.remoteClientVersion=await Os(this.host,this.config),tr("host",this.host),tr("protocol",this.protocol)}</span>)(),await this.startPromise}<span class="fstat-no" title="function not covered" >a</span>sync s</span>top(){}<span class="fstat-no" title="function not covered" >propagateResponseExtensions(t</span>){<span class="cstat-no" title="statement not covered" >t?.logs?.length&amp;&amp;t.logs.forEach(<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >s</span>witch(r.level){case"debug":case"trace":<span class="cstat-no" title="statement not covered" >tr(r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"error":case"warn":case"info":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit(r.level,{timestamp:Wn(r.timestamp),message:r.attributes.message??"",target:r.target});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"query":{<span class="cstat-no" title="statement not covered" >this.logEmitter.emit("query",{query:r.attributes.query??"",timestamp:Wn(r.timestamp),duration:r.attributes.duration_ms??0,params:r.attributes.params??"",target:r.target});<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >r.level}}</span></span>),t?.traces?.length&amp;&amp;this.tracingHelper.dispatchEngineSpans(t.traces)}<span class="fstat-no" title="function not covered" ></span>onBeforeExit(){<span class="cstat-no" title="statement not covered" ></span>throw new Error('"beforeExit" hook is not applicable to the remote query engine')}<span class="fstat-no" title="function not covered" ></span>async u</span>rl(t){<span class="cstat-no" title="statement not covered" >return await this.start(),`${this.protocol}://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${t}`}<span class="fstat-no" title="function not covered" >a</span>sync u</span>ploadSchema(){let t=<span class="cstat-no" title="statement not covered" >{name:"schemaUpload",internal:!0};<span class="cstat-no" title="statement not covered" >r</span>eturn this.tracingHelper.runInChildSpan(t,<span class="fstat-no" title="function not covered" >async()=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >await Ve(await this.url("schema"),{method:"PUT",headers:this.headerBuilder.build(),body:this.inlineSchema,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" >r</span>.ok||tr("schema response status",r.status);l</span>et n=<span class="cstat-no" title="statement not covered" >await Xt(r,this.clientVersion);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n)<span class="cstat-no" title="statement not covered" >throw this.logEmitter.emit("warn",{message:`Error while uploading schema: ${n.message}`,timestamp:new Date,target:""}),n;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("info",{message:`Schema (re)uploaded (hash: ${this.inlineSchemaHash})`,timestamp:new Date,target:""})}</span>)}<span class="fstat-no" title="function not covered" ></span>request(t</span>,{traceparent:r,interactiveTransaction:n,customDataProxyFetch:i}){<span class="cstat-no" title="statement not covered" >return this.requestInternal({body:t,traceparent:r,interactiveTransaction:n,customDataProxyFetch:i})}<span class="fstat-no" title="function not covered" ></span>async r</span>equestBatch(t,{traceparent:r,transaction:n,customDataProxyFetch:i}){let o=<span class="cstat-no" title="statement not covered" >n?.kind==="itx"?n.options:void 0,s</span>=<span class="cstat-no" title="statement not covered" >jr(t,n);<span class="cstat-no" title="statement not covered" >r</span>eturn(await this.requestInternal({body:s,customDataProxyFetch:i,interactiveTransaction:o,traceparent:r})).map(<span class="fstat-no" title="function not covered" >l=&gt;(<span class="cstat-no" title="statement not covered" >l</span>.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l?this.convertProtocolErrorsToClientError(l.errors):l))}<span class="fstat-no" title="function not covered" ></span></span>requestInternal({</span>body:t,traceparent:r,customDataProxyFetch:n,interactiveTransaction:i}){<span class="cstat-no" title="statement not covered" >return this.withRetry({actionGerund:"querying",callback:<span class="fstat-no" title="function not covered" >async({</span>logHttpCall:o})=&gt;{let s=<span class="cstat-no" title="statement not covered" >i?`${i.payload.endpoint}/graphql`:await this.url("graphql");<span class="cstat-no" title="statement not covered" >o</span>(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await Ve(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r,interactiveTransaction:i}),body:JSON.stringify(t),clientVersion:this.clientVersion},n);<span class="cstat-no" title="statement not covered" >a</span>.ok||tr("graphql response status",a.status),await this.handleError(await Xt(a,this.clientVersion));l</span>et l=<span class="cstat-no" title="statement not covered" >await a.json();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(l.extensions&amp;&amp;this.propagateResponseExtensions(l.extensions),"errors"in l)<span class="cstat-no" title="statement not covered" >throw this.convertProtocolErrorsToClientError(l.errors);<span class="cstat-no" title="statement not covered" >r</span></span>eturn"batchResult"in l?l.batchResult:l}</span>})}<span class="fstat-no" title="function not covered" ></span>async t</span>ransaction(t,r,n){let i=<span class="cstat-no" title="statement not covered" >{start:"starting",commit:"committing",rollback:"rolling back"};<span class="cstat-no" title="statement not covered" >r</span>eturn this.withRetry({actionGerund:`${i[t]} transaction`,callback:<span class="fstat-no" title="function not covered" >async({</span>logHttpCall:o})=&gt;{<span class="cstat-no" title="statement not covered" >if(t==="start"){let s=<span class="cstat-no" title="statement not covered" >JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel}),a</span>=<span class="cstat-no" title="statement not covered" >await this.url("transaction/start");<span class="cstat-no" title="statement not covered" >o</span>(a);l</span>et l=<span class="cstat-no" title="statement not covered" >await Ve(a,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),body:s,clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" >a</span>wait this.handleError(await Xt(l,this.clientVersion));l</span>et d=<span class="cstat-no" title="statement not covered" >await l.json(),{</span>extensions:g}=<span class="cstat-no" title="statement not covered" >d;<span class="cstat-no" title="statement not covered" >g</span>&amp;&amp;this.propagateResponseExtensions(g);l</span>et h=<span class="cstat-no" title="statement not covered" >d.id,</span>v=<span class="cstat-no" title="statement not covered" >d["data-proxy"].endpoint;<span class="cstat-no" title="statement not covered" ></span>return{id:h,payload:{endpoint:v}}}</span>else{let s=<span class="cstat-no" title="statement not covered" >`${n.payload.endpoint}/${t}`;<span class="cstat-no" title="statement not covered" ></span>o(s);l</span>et a=<span class="cstat-no" title="statement not covered" >await Ve(s,{method:"POST",headers:this.headerBuilder.build({traceparent:r.traceparent}),clientVersion:this.clientVersion});<span class="cstat-no" title="statement not covered" >a</span>wait this.handleError(await Xt(a,this.clientVersion));l</span>et l=<span class="cstat-no" title="statement not covered" >await a.json(),{</span>extensions:d}=<span class="cstat-no" title="statement not covered" >l;<span class="cstat-no" title="statement not covered" >d</span>&amp;&amp;this.propagateResponseExtensions(d);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}</span>})}<span class="fstat-no" title="function not covered" ></span>getURLAndAPIKey(){</span>let t=<span class="cstat-no" title="statement not covered" >{clientVersion:this.clientVersion},r</span>=<span class="cstat-no" title="statement not covered" >Object.keys(this.inlineDatasources)[0],</span>n=<span class="cstat-no" title="statement not covered" >mt({inlineDatasources:this.inlineDatasources,overrideDatasources:this.config.overrideDatasources,clientVersion:this.clientVersion,env:this.env}),i</span>;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >i=new URL(n)}</span>catch{<span class="cstat-no" title="statement not covered" >throw new qe(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\``,t)}</span>l</span>et{protocol:o,searchParams:s}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o!=="prisma:"&amp;&amp;o!==mr)<span class="cstat-no" title="statement not covered" >throw new qe(`Error validating datasource \`${r}\`: the URL must start with the protocol \`prisma://\` or \`prisma+postgres://\``,t);l</span></span>et a=<span class="cstat-no" title="statement not covered" >s.get("api_key");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a===null||a.length&lt;1)<span class="cstat-no" title="statement not covered" >throw new qe(`Error validating datasource \`${r}\`: the URL must contain a valid API key`,t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{apiKey:a,url:i}}<span class="fstat-no" title="function not covered" ></span>metrics(){<span class="cstat-no" title="statement not covered" ></span>throw new $e("Metrics are not yet supported for Accelerate",{clientVersion:this.clientVersion})}<span class="fstat-no" title="function not covered" ></span>async w</span>ithRetry(t){<span class="cstat-no" title="statement not covered" >for(let r=<span class="cstat-no" title="statement not covered" >0;;r</span>++){let n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >i=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.logEmitter.emit("info",{message:`Calling ${i} (n=${r})`,timestamp:new Date,target:""})}</span>;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return await t.callback({logHttpCall:n})}</span>catch(i){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!(i instanceof ne)||!i.isRetryable)<span class="cstat-no" title="statement not covered" >throw i;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r&gt;=Ds)<span class="cstat-no" title="statement not covered" >throw i instanceof ft?i.cause:i;<span class="cstat-no" title="statement not covered" >t</span></span>his.logEmitter.emit("warn",{message:`Attempt ${r+1}/${Ds} failed for ${t.actionGerund}: ${i.message??"(unknown)"}`,timestamp:new Date,target:""});l</span>et o=<span class="cstat-no" title="statement not covered" >await As(r);<span class="cstat-no" title="statement not covered" >t</span>his.logEmitter.emit("warn",{message:`Retrying after ${o}ms`,timestamp:new Date,target:""})}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>async h</span>andleError(t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t instanceof je)<span class="cstat-no" title="statement not covered" >throw await this.uploadSchema(),new ft({clientVersion:this.clientVersion,cause:t});<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t)<span class="cstat-no" title="statement not covered" >throw t}<span class="fstat-no" title="function not covered" ></span></span>convertProtocolErrorsToClientError(t</span>){<span class="cstat-no" title="statement not covered" >return t.length===1?Vr(t[0],this.config.clientVersion,this.config.activeProvider):new se(JSON.stringify(t),{clientVersion:this.config.clientVersion})}<span class="fstat-no" title="function not covered" ></span>applyPendingMigrations(){<span class="cstat-no" title="statement not covered" ></span>throw new Error("Method not implemented.")}</span>};f</span>unction <span class="fstat-no" title="function not covered" >Ms({</span>copyEngine:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>,t){let r;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=mt({inlineDatasources:t.inlineDatasources,overrideDatasources:t.overrideDatasources,env:{...t.env,...y.env},clientVersion:t.clientVersion})}</span>catch{}l</span>et n=<span class="cstat-no" title="statement not covered" >!!(r?.startsWith("prisma://")||fr(r));<span class="cstat-no" title="statement not covered" >e</span>&amp;&amp;n&amp;&amp;dr("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");l</span>et i=<span class="cstat-no" title="statement not covered" >Ye(t.generator),o</span>=<span class="cstat-no" title="statement not covered" >n||!e,s</span>=<span class="cstat-no" title="statement not covered" >!!t.adapter,</span>a=<span class="cstat-no" title="statement not covered" >i==="library",l</span>=<span class="cstat-no" title="statement not covered" >i==="binary",d</span>=<span class="cstat-no" title="statement not covered" >i==="client";<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o&amp;&amp;s||s){let g;<span class="cstat-no" title="statement not covered" >throw g=["Prisma Client was configured to use the `adapter` option but it was imported via its `/edge` endpoint.","Please either remove the `/edge` endpoint or remove the `adapter` from the Prisma Client constructor."],new X(g.join(`</span></span>
`),{clientVersion:t.clientVersion})}<span class="cstat-no" title="statement not covered" >return o?new ht(t):new ht(t)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Wr({</span>generator:e}){<span class="cstat-no" title="statement not covered" >return e?.previewFeatures??[]}<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar _s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=&gt;(<span class="cstat-no" title="statement not covered" >{</span>command:e});<span class="cstat-no" title="statement not covered" >f</span></span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Ns=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.strings.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r,n)=&gt;<span class="cstat-no" title="statement not covered" >`${t}@P${n}${r}`)</span>;<span class="cstat-no" title="statement not covered" >f</span></span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >yt(e</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Fs(e,"fast")}</span>catch{<span class="cstat-no" title="statement not covered" >return Fs(e,"slow")}</span>}</span>function <span class="fstat-no" title="function not covered" >Fs(e</span>,t){<span class="cstat-no" title="statement not covered" >return JSON.stringify(e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >B</span>s(r,t)))}</span></span>function <span class="fstat-no" title="function not covered" >Bs(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >B</span>s(r,t));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(typeof e=="bigint")<span class="cstat-no" title="statement not covered" >return{prisma__type:"bigint",prisma__value:e.toString()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(tt(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"date",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(he.isDecimal(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"decimal",prisma__value:e.toJSON()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(w.Buffer.isBuffer(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:e.toString("base64")};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Zc(e))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:w.Buffer.from(e).toString("base64")};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(e)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn{prisma__type:"bytes",prisma__value:w.Buffer.from(r,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn typeof e=="object"&amp;&amp;t==="slow"?Us(e):e}</span>function <span class="fstat-no" title="function not covered" >Zc(e</span>){<span class="cstat-no" title="statement not covered" >return e instanceof ArrayBuffer||e instanceof SharedArrayBuffer?!0:typeof e=="object"&amp;&amp;e!==null?e[Symbol.toStringTag]==="ArrayBuffer"||e[Symbol.toStringTag]==="SharedArrayBuffer":!1}</span>function <span class="fstat-no" title="function not covered" >Us(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="object"||e===null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e.toJSON=="function")<span class="cstat-no" title="statement not covered" >return e.toJSON();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(e))<span class="cstat-no" title="statement not covered" >return e.map(Ls);l</span></span>et t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r of Object.keys(e))<span class="cstat-no" title="statement not covered" >t[r]=Ls(e[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Ls(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="bigint"?e.toString():Us(e)}</span>var Xc=<span class="cstat-no" title="statement not covered" >/^(\s*alter\s)/i,q</span>s=<span class="cstat-no" title="statement not covered" >Y("prisma:client");f</span>unction <span class="fstat-no" title="function not covered" >Kn(e</span>,t,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!(e!=="postgresql"&amp;&amp;e!=="cockroachdb")&amp;&amp;r.length&gt;0&amp;&amp;Xc.exec(t))<span class="cstat-no" title="statement not covered" >throw new Error(`Running ALTER using ${n} is not supported</span></span>
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.
&nbsp;
Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)
&nbsp;
More Information: https://pris.ly/d/execute-raw
`)}var zn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>clientMethod:e,activeProvider:t})=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >"",i</span>;<span class="cstat-no" title="statement not covered" >if(Br(r))<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:yt(r.values),__prismaRawParameters__:!0};else <span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(r)){let[o,...s]=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >n</span>=o,i={values:yt(s||[]),__prismaRawParameters__:!0}}</span>else <span class="cstat-no" title="statement not covered" >switch(t){case"sqlite":case"mysql":{<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:yt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"cockroachdb":case"postgresql":case"postgres":{<span class="cstat-no" title="statement not covered" >n=r.text,i={values:yt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"sqlserver":{<span class="cstat-no" title="statement not covered" >n=Ns(r),i={values:yt(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new Error(`The ${t} provider does not support ${e}`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn i?.values?qs(`prisma.${e}(${n}, ${i.values})`):qs(`prisma.${e}(${n})`),{query:n,parameters:i}}</span>,$</span></span>s=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e</span>){<span class="cstat-no" title="statement not covered" >return[e.strings,...e.values]},<span class="fstat-no" title="function not covered" >m</span>iddlewareArgsToRequestArgs(e</span>){let[t,...r]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn new le(t,r)}</span>},j</span>s=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(e</span>){<span class="cstat-no" title="statement not covered" >return[e]},<span class="fstat-no" title="function not covered" >m</span>iddlewareArgsToRequestArgs(e</span>){<span class="cstat-no" title="statement not covered" >return e[0]}}</span>;<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Yn(e</span>){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(r</span>,n){let i,o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return s===void 0||s?.kind==="itx"?i??=Vs(r(s)):Vs(r(s))}</span>catch(a){<span class="cstat-no" title="statement not covered" >return Promise.reject(a)}</span>}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >get s</span>pec(){<span class="cstat-no" title="statement not covered" >return n}</span>,<span class="fstat-no" title="function not covered" >then(s</span>,a){<span class="cstat-no" title="statement not covered" >return o().then(s,a)}</span>,<span class="fstat-no" title="function not covered" >catch(s</span>){<span class="cstat-no" title="statement not covered" >return o().catch(s)}</span>,<span class="fstat-no" title="function not covered" >finally(s</span>){<span class="cstat-no" title="statement not covered" >return o().finally(s)}</span>,<span class="fstat-no" title="function not covered" >requestTransaction(s</span>){let a=<span class="cstat-no" title="statement not covered" >o(s);<span class="cstat-no" title="statement not covered" >r</span>eturn a.requestTransaction?a.requestTransaction(s):a}</span>,[Symbol.toStringTag]:"PrismaPromise"}}</span>}</span>function <span class="fstat-no" title="function not covered" >Vs(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e.then=="function"?e:Promise.resolve(e)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar ep=<span class="cstat-no" title="statement not covered" >mn.split(".")[0],</span>tp=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >isEnabled(){<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>,<span class="fstat-no" title="function not covered" >getTraceParent(){<span class="cstat-no" title="statement not covered" >r</span>eturn"00-10-10-00"}</span>,<span class="fstat-no" title="function not covered" >dispatchEngineSpans(){}</span>,<span class="fstat-no" title="function not covered" >getActiveContext(){}</span>,<span class="fstat-no" title="function not covered" >runInChildSpan(e</span>,t){<span class="cstat-no" title="statement not covered" >return t()}</span>},Z</span>n=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >isEnabled(){<span class="cstat-no" title="statement not covered" ></span>return this.getGlobalTracingHelper().isEnabled()}<span class="fstat-no" title="function not covered" ></span>getTraceParent(t</span>){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().getTraceParent(t)}<span class="fstat-no" title="function not covered" ></span>dispatchEngineSpans(t</span>){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().dispatchEngineSpans(t)}<span class="fstat-no" title="function not covered" ></span>getActiveContext(){<span class="cstat-no" title="statement not covered" ></span>return this.getGlobalTracingHelper().getActiveContext()}<span class="fstat-no" title="function not covered" ></span>runInChildSpan(t</span>,r){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().runInChildSpan(t,r)}<span class="fstat-no" title="function not covered" ></span>getGlobalTracingHelper(){</span>let t=<span class="cstat-no" title="statement not covered" >globalThis[`V${ep}_PRISMA_INSTRUMENTATION`],</span>r=<span class="cstat-no" title="statement not covered" >globalThis.PRISMA_INSTRUMENTATION;<span class="cstat-no" title="statement not covered" ></span>return t?.helper??r?.helper??tp}</span>};f</span>unction <span class="fstat-no" title="function not covered" >Gs(){<span class="cstat-no" title="statement not covered" >r</span>eturn new Zn}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Qs(e</span>,t=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()=&gt;{}</span>)</span>{let r,n=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >r</span>=i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{<span class="fstat-no" title="function not covered" >then(i</span>){<span class="cstat-no" title="statement not covered" >return--e===0&amp;&amp;r(t()),i?.(n)}</span>}}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Js(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="string"?e:e.reduce(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >typeof r=="string"?r:r.level;<span class="cstat-no" title="statement not covered" ></span>return n==="query"?t:t&amp;&amp;(r==="info"||t==="info")?"info":n}</span>,void 0)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Hr=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >_middlewares=[];<span class="fstat-no" title="function not covered" >u</span>se(t</span>){<span class="cstat-no" title="statement not covered" >this._middlewares.push(t)}<span class="fstat-no" title="function not covered" ></span>get(t</span>){<span class="cstat-no" title="statement not covered" >return this._middlewares[t]}<span class="fstat-no" title="function not covered" >h</span>as(t</span>){<span class="cstat-no" title="statement not covered" >return!!this._middlewares[t]}<span class="fstat-no" title="function not covered" >l</span>ength(){<span class="cstat-no" title="statement not covered" ></span>return this._middlewares.length}}</span>;<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Hs=<span class="cstat-no" title="statement not covered" >Qe(eo());<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Kr(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e.batchRequestIdx=="number"}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ws(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.action!=="findUnique"&amp;&amp;e.action!=="findUniqueOrThrow")<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.modelName&amp;&amp;t.push(e.modelName),e.query.arguments&amp;&amp;t.push(Xn(e.query.arguments)),t.push(Xn(e.query.selection)),t.join("")}</span>function <span class="fstat-no" title="function not covered" >Xn(e</span>){<span class="cstat-no" title="statement not covered" >return`(${Object.keys(e).sort().map(<span class="fstat-no" title="function not covered" >r=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >e[r];<span class="cstat-no" title="statement not covered" ></span>return typeof n=="object"&amp;&amp;n!==null?`(${r} ${Xn(n)})`:r}</span>).join(" ")})`}<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar rp=<span class="cstat-no" title="statement not covered" >{aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};f</span>unction <span class="fstat-no" title="function not covered" >ei(e</span>){<span class="cstat-no" title="statement not covered" >return rp[e]}<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar zr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >this.options=t;<span class="cstat-no" title="statement not covered" >t</span>his.batches={}}</span>batches;<span class="cstat-no" title="statement not covered" >tickActive=!1;<span class="fstat-no" title="function not covered" >r</span>equest(t</span>){let r=<span class="cstat-no" title="statement not covered" >this.options.batchBy(t);<span class="cstat-no" title="statement not covered" >r</span>eturn r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,y.nextTick(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.dispatchBatches(),this.tickActive=!1}</span>))),new Promise(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >this.batches[r].push({request:t,resolve:n,reject:i})}</span>)):this.options.singleLoader(t)}<span class="fstat-no" title="function not covered" ></span>dispatchBatches(){<span class="cstat-no" title="statement not covered" ></span>for(let t in this.batches){let r=<span class="cstat-no" title="statement not covered" >this.batches[t];<span class="cstat-no" title="statement not covered" ></span>delete this.batches[t],r.length===1?this.options.singleLoader(r[0].request).then(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >n</span> instanceof Error?r[0].reject(n):r[0].resolve(n)}</span>).catch(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >r</span>[0].reject(n)}</span>):(r.sort(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >this.options.batchOrder(n.request,i.request)),t</span>his.options.batchLoader(r.map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.request)</span>).then(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(n instanceof Error)<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n);else <span class="cstat-no" title="statement not covered" >f</span></span>or(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;r.length;i++){let o=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" ></span>o instanceof Error?r[i].reject(o):r[i].resolve(o)}</span>}</span></span>).catch(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n)}</span></span>))}</span>}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"DataLoader"}</span>};<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ge(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t===null)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >s</span></span>witch(e){case"bigint":<span class="cstat-no" title="statement not covered" >return BigInt(t);c</span>ase"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >w.Buffer.from(t,"base64");<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(r,n,i)}</span>case"decimal":<span class="cstat-no" title="statement not covered" >return new he(t);c</span>ase"datetime":case"date":<span class="cstat-no" title="statement not covered" >return new Date(t);c</span>ase"time":<span class="cstat-no" title="statement not covered" >return new Date(`1970-01-01T${t}Z`);c</span>ase"bigint-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >G</span>e("bigint",r));c</span></span>ase"bytes-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >G</span>e("bytes",r));c</span></span>ase"decimal-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >G</span>e("decimal",r));c</span></span>ase"datetime-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >G</span>e("datetime",r));c</span></span>ase"date-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >G</span>e("date",r));c</span></span>ase"time-array":<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >G</span>e("time",r));d</span></span>efault:<span class="cstat-no" title="statement not covered" >return t}</span>}</span>function <span class="fstat-no" title="function not covered" >ti(e</span>){let t=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >np(e);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;n</span>&lt;e.rows.length;n++){let i=<span class="cstat-no" title="statement not covered" >e.rows[n],</span>o=<span class="cstat-no" title="statement not covered" >{...r};<span class="cstat-no" title="statement not covered" >f</span>or(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >o[e.columns[s]]=Ge(e.types[s],i[s]);<span class="cstat-no" title="statement not covered" >t</span></span>.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >np(e</span>){let t=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;e.columns.length;r++)<span class="cstat-no" title="statement not covered" >t[e.columns[r]]=null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>var ip=<span class="cstat-no" title="statement not covered" >Y("prisma:client:request_handler"),Y</span>r=<span class="cstat-no" title="statement not covered" >class{client;dataloader;logEmitter;<span class="fstat-no" title="function not covered" >constructor(t</span>,r){<span class="cstat-no" title="statement not covered" >this.logEmitter=r,this.client=t,this.dataloader=new zr({batchLoader:ws(<span class="fstat-no" title="function not covered" >async({</span>requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=<span class="cstat-no" title="statement not covered" >n[0],</span>a=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >h=&gt;<span class="cstat-no" title="statement not covered" >h</span>.protocolQuery)</span>,l</span>=<span class="cstat-no" title="statement not covered" >this.client._tracingHelper.getTraceParent(s),d</span>=<span class="cstat-no" title="statement not covered" >n.some(<span class="fstat-no" title="function not covered" >h=&gt;<span class="cstat-no" title="statement not covered" >e</span>i(h.protocolQuery.action));<span class="cstat-no" title="statement not covered" >r</span></span>eturn(await this.client._engine.requestBatch(a,{traceparent:l,transaction:op(o),containsWrite:d,customDataProxyFetch:i})).map(<span class="fstat-no" title="function not covered" >(h</span>,v)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(h instanceof Error)<span class="cstat-no" title="statement not covered" >return h;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return this.mapQueryEngineResult(n[v],h)}</span>catch(S){<span class="cstat-no" title="statement not covered" >return S}</span>}</span>)}</span>),singleLoader:<span class="fstat-no" title="function not covered" >async n</span>=&gt;{let i=<span class="cstat-no" title="statement not covered" >n.transaction?.kind==="itx"?Ks(n.transaction):void 0,o</span>=<span class="cstat-no" title="statement not covered" >await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:ei(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});<span class="cstat-no" title="statement not covered" >r</span>eturn this.mapQueryEngineResult(n,o)}</span>,batchBy:<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.transaction?.id?`transaction-${n.transaction.id}`:Ws(n.protocolQuery),<span class="fstat-no" title="function not covered" >b</span>atchOrder(n</span>,i){<span class="cstat-no" title="statement not covered" >return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}</span>})}<span class="fstat-no" title="function not covered" ></span>async r</span>equest(t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await this.dataloader.request(t)}</span>catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >t</span>his.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:t.globalOmit})}</span>}<span class="fstat-no" title="function not covered" ></span>mapQueryEngineResult({</span>dataPath:t,unpacker:r},n){let i=<span class="cstat-no" title="statement not covered" >n?.data,o</span>=<span class="cstat-no" title="statement not covered" >this.unpack(i,t,r);<span class="cstat-no" title="statement not covered" >r</span>eturn y.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}<span class="fstat-no" title="function not covered" ></span>handleAndLogRequestError(t</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.handleRequestError(t)}</span>catch(r){<span class="cstat-no" title="statement not covered" >throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:r.message,target:t.clientMethod,timestamp:new Date}),r}</span>}<span class="fstat-no" title="function not covered" ></span>handleRequestError({</span>error:t,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(ip(t),sp(t,i))<span class="cstat-no" title="statement not covered" >throw t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t instanceof oe&amp;&amp;ap(t)){let d=<span class="cstat-no" title="statement not covered" >zs(t.meta);<span class="cstat-no" title="statement not covered" >_</span>r({args:o,errors:[d],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}</span>l</span>et l=<span class="cstat-no" title="statement not covered" >t.message;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;(l=Cr({callsite:n,originalMethod:r,isPanic:t.isPanic,showColors:this.client._errorFormat==="pretty",message:l})),l=this.sanitizeMessage(l),t.code){let d=<span class="cstat-no" title="statement not covered" >s?{modelName:s,...t.meta}:t.meta;<span class="cstat-no" title="statement not covered" ></span>throw new oe(l,{code:t.code,clientVersion:this.client._clientVersion,meta:d,batchRequestIdx:t.batchRequestIdx})}</span>else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.isPanic)<span class="cstat-no" title="statement not covered" >throw new Re(l,this.client._clientVersion);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t instanceof se)<span class="cstat-no" title="statement not covered" >throw new se(l,{clientVersion:this.client._clientVersion,batchRequestIdx:t.batchRequestIdx});<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t instanceof Q)<span class="cstat-no" title="statement not covered" >throw new Q(l,this.client._clientVersion);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t instanceof Re)<span class="cstat-no" title="statement not covered" >throw new Re(l,this.client._clientVersion)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow t.clientVersion=this.client._clientVersion,t}<span class="fstat-no" title="function not covered" ></span>sanitizeMessage(t</span>){<span class="cstat-no" title="statement not covered" >return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?(0,Hs.default)(t):t}<span class="fstat-no" title="function not covered" ></span>unpack(t</span>,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t||(t.data&amp;&amp;(t=t.data),!t))<span class="cstat-no" title="statement not covered" >return t;l</span></span>et i=<span class="cstat-no" title="statement not covered" >Object.keys(t)[0],</span>o=<span class="cstat-no" title="statement not covered" >Object.values(t)[0],</span>s=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >d=&gt;<span class="cstat-no" title="statement not covered" >d</span>!=="select"&amp;&amp;d!=="include"),a</span></span>=<span class="cstat-no" title="statement not covered" >Fn(o,s),l</span>=<span class="cstat-no" title="statement not covered" >i==="queryRaw"?ti(a):Ct(a);<span class="cstat-no" title="statement not covered" >r</span>eturn n?n(l):l}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"RequestHandler"}</span>};f</span>unction <span class="fstat-no" title="function not covered" >op(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.kind==="batch")<span class="cstat-no" title="statement not covered" >return{kind:"batch",options:{isolationLevel:e.isolationLevel}};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.kind==="itx")<span class="cstat-no" title="statement not covered" >return{kind:"itx",options:Ks(e)};<span class="cstat-no" title="statement not covered" >P</span></span>e(e,"Unknown transaction kind")}</span>}</span>function <span class="fstat-no" title="function not covered" >Ks(e</span>){<span class="cstat-no" title="statement not covered" >return{id:e.id,payload:e.payload}}</span>function <span class="fstat-no" title="function not covered" >sp(e</span>,t){<span class="cstat-no" title="statement not covered" >return Kr(e)&amp;&amp;t?.kind==="batch"&amp;&amp;e.batchRequestIdx!==t.index}f</span>unction <span class="fstat-no" title="function not covered" >ap(e</span>){<span class="cstat-no" title="statement not covered" >return e.code==="P2009"||e.code==="P2012"}</span>function <span class="fstat-no" title="function not covered" >zs(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.kind==="Union")<span class="cstat-no" title="statement not covered" >return{kind:"Union",errors:e.errors.map(zs)};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(e.selectionPath)){let[,...t]=<span class="cstat-no" title="statement not covered" >e.selectionPath;<span class="cstat-no" title="statement not covered" ></span>return{...e,selectionPath:t}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar Ys=<span class="cstat-no" title="statement not covered" >Cs;<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar ra=<span class="cstat-no" title="statement not covered" >Qe(vn());<span class="cstat-no" title="statement not covered" >f</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar U=<span class="cstat-no" title="statement not covered" >class extends Error{<span class="fstat-no" title="function not covered" >constructor(t</span>){<span class="cstat-no" title="statement not covered" >super(t+`</span></span>
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientConstructorValidationError"}</span>};<span class="cstat-no" title="statement not covered" >N(U,"PrismaClientConstructorValidationError");v</span>ar Zs=<span class="cstat-no" title="statement not covered" >["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],X</span>s=<span class="cstat-no" title="statement not covered" >["pretty","colorless","minimal"],e</span>a=<span class="cstat-no" title="statement not covered" >["info","query","warn","error"],l</span>p=<span class="cstat-no" title="statement not covered" >{datasources:<span class="fstat-no" title="function not covered" >(e</span>,{datasourceNames:t})=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="object"||Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[r,n]of Object.entries(e)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t.includes(r)){let i=<span class="cstat-no" title="statement not covered" >wt(r,t)||` Available datasources: ${t.join(", ")}`;<span class="cstat-no" title="statement not covered" ></span>throw new U(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(typeof n!="object"||Array.isArray(n))<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span></span></span></span></span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n&amp;&amp;typeof n=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(n)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i!=="url")<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.</span></span></span></span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof o!="string")<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.</span></span>
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e&amp;&amp;Ye(t.generator)==="client")<span class="cstat-no" title="statement not covered" >throw new U('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e===void 0)<span class="cstat-no" title="statement not covered" >throw new U('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!Wr(t).includes("driverAdapters"))<span class="cstat-no" title="statement not covered" >throw new U('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Ye(t.generator)==="binary")<span class="cstat-no" title="statement not covered" >throw new U('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')}</span></span>,datasourceUrl:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(typeof e&lt;"u"&amp;&amp;typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.</span></span>
Expected string or undefined.`)},errorFormat:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="string")<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!Xs.includes(e)){let t=<span class="cstat-no" title="statement not covered" >wt(e,Xs);<span class="cstat-no" title="statement not covered" >t</span>hrow new U(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`)}</span>}</span>}</span>,log:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);f</span></span>unction <span class="fstat-no" title="function not covered" >t(r</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof r=="string"&amp;&amp;!ea.includes(r)){let n=<span class="cstat-no" title="statement not covered" >wt(r,ea);<span class="cstat-no" title="statement not covered" >t</span>hrow new U(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}</span>}<span class="cstat-no" title="statement not covered" ></span>for(let r of e){<span class="cstat-no" title="statement not covered" >t(r);l</span>et n=<span class="cstat-no" title="statement not covered" >{level:t,emit:<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >["stdout","event"];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o.includes(i)){let s=<span class="cstat-no" title="statement not covered" >wt(i,o);<span class="cstat-no" title="statement not covered" >t</span>hrow new U(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}</span>}</span>};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r&amp;&amp;typeof r=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(r))<span class="cstat-no" title="statement not covered" >if(n[i])<span class="cstat-no" title="statement not covered" >n[i](o);else <span class="cstat-no" title="statement not covered" >t</span>hrow new U(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}</span></span></span></span>}</span>,transactionOptions:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >e.maxWait;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(t!=null&amp;&amp;t&lt;=0)<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${t} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.timeout;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(r!=null&amp;&amp;r&lt;=0)<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)}</span></span>,omit:<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new U('"omit" option is expected to be an object.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e===null)<span class="cstat-no" title="statement not covered" >throw new U('"omit" option can not be `null`');l</span></span>et r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let[n,i]of Object.entries(e)){let o=<span class="cstat-no" title="statement not covered" >cp(n,t.runtimeDataModel);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownModel",modelKey:n});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let[s,a]of Object.entries(i)){let l=<span class="cstat-no" title="statement not covered" >o.fields.find(<span class="fstat-no" title="function not covered" >d=&gt;<span class="cstat-no" title="statement not covered" >d</span>.name===s);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!l){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownField",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(l.relationName){<span class="cstat-no" title="statement not covered" >r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>ypeof a!="boolean"&amp;&amp;r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}</span>}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(r.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new U(pp(e,r))}</span></span>,__internal:<span class="fstat-no" title="function not covered" >e=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et t=<span class="cstat-no" title="statement not covered" >["debug","engine","configOverride"];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(typeof e!="object")<span class="cstat-no" title="statement not covered" >throw new U(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[r]of Object.entries(e))<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t.includes(r)){let n=<span class="cstat-no" title="statement not covered" >wt(r,t);<span class="cstat-no" title="statement not covered" >t</span>hrow new U(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}</span>}</span></span>};function <span class="fstat-no" title="function not covered" >na(e</span>,t){<span class="cstat-no" title="statement not covered" >for(let[r,n]of Object.entries(e)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!Zs.includes(r)){let i=<span class="cstat-no" title="statement not covered" >wt(r,Zs);<span class="cstat-no" title="statement not covered" >t</span>hrow new U(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}<span class="cstat-no" title="statement not covered" ></span>l</span>p[r](n,t)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(e.datasourceUrl&amp;&amp;e.datasources)<span class="cstat-no" title="statement not covered" >throw new U('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}</span></span>function <span class="fstat-no" title="function not covered" >wt(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.length===0||typeof e!="string")<span class="cstat-no" title="statement not covered" >return"";l</span></span>et r=<span class="cstat-no" title="statement not covered" >up(e,t);<span class="cstat-no" title="statement not covered" >r</span>eturn r?` Did you mean "${r}"?`:""}</span>function <span class="fstat-no" title="function not covered" >up(e</span>,t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.length===0)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et r=<span class="cstat-no" title="statement not covered" >t.map(<span class="fstat-no" title="function not covered" >i=&gt;(<span class="cstat-no" title="statement not covered" >{</span>value:i,distance:(0,ra.default)(e,i)}));<span class="cstat-no" title="statement not covered" >r</span></span>.sort(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i.distance&lt;o.distance?-1:1);l</span></span>et n=<span class="cstat-no" title="statement not covered" >r[0];<span class="cstat-no" title="statement not covered" ></span>return n.distance&lt;3?n.value:null}</span>function <span class="fstat-no" title="function not covered" >cp(e</span>,t){<span class="cstat-no" title="statement not covered" >return ta(t.models,e)??ta(t.types,e)}</span>function <span class="fstat-no" title="function not covered" >ta(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >Object.keys(e).find(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >D</span>e(n)===t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r)<span class="cstat-no" title="statement not covered" >return e[r]}f</span></span>unction <span class="fstat-no" title="function not covered" >pp(e</span>,t){let r=<span class="cstat-no" title="statement not covered" >lt(e);<span class="cstat-no" title="statement not covered" >f</span>or(let o of t)<span class="cstat-no" title="statement not covered" >switch(o.kind){case"UnknownModel":<span class="cstat-no" title="statement not covered" >r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Unknown model name: ${o.modelKey}.`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownField":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Model "${o.modelKey}" does not have a field named "${o.fieldName}".`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RelationInOmit":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >'</span>Relations are already excluded by default and can not be specified in "omit".');<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"InvalidFieldValue":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Omit field option value must be a boolean.");<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>l</span></span>et{message:n,args:i}=<span class="cstat-no" title="statement not covered" >Mr(r,"colorless");<span class="cstat-no" title="statement not covered" >r</span>eturn`Error validating "omit" option:</span>
&nbsp;
${i}
&nbsp;
${n}`}<span class="cstat-no" title="statement not covered" >f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();f</span>unction <span class="fstat-no" title="function not covered" >ia(e</span>){<span class="cstat-no" title="statement not covered" >return e.length===0?Promise.resolve([]):new Promise(<span class="fstat-no" title="function not covered" >(t</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >new Array(e.length),i</span>=<span class="cstat-no" title="statement not covered" >null,o</span>=<span class="cstat-no" title="statement not covered" >!1,s</span>=<span class="cstat-no" title="statement not covered" >0,a</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >o</span>||(s++,s===e.length&amp;&amp;(o=!0,i?r(i):t(n)))}</span>,l</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >d=&gt;{<span class="cstat-no" title="statement not covered" >o</span>||(o=!0,r(d))}</span>;<span class="cstat-no" title="statement not covered" >f</span>or(let d=<span class="cstat-no" title="statement not covered" >0;d</span>&lt;e.length;d++)<span class="cstat-no" title="statement not covered" >e[d].then(<span class="fstat-no" title="function not covered" >g=&gt;{<span class="cstat-no" title="statement not covered" >n</span>[d]=g,a()}</span>,<span class="fstat-no" title="function not covered" >g=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!Kr(g)){<span class="cstat-no" title="statement not covered" >l(g);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>g</span>.batchRequestIdx===d?l(g):(i||(i=g),a())}</span>)}</span></span>)}</span>var Ne=<span class="cstat-no" title="statement not covered" >Y("prisma:client");<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);v</span>ar mp=<span class="cstat-no" title="statement not covered" >{requestArgsToMiddlewareArgs:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>,m</span>iddlewareArgsToRequestArgs:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>}</span>,f</span>p=<span class="cstat-no" title="statement not covered" >Symbol.for("prisma.client.transaction.id"),d</span>p=<span class="cstat-no" title="statement not covered" >{id:0,<span class="fstat-no" title="function not covered" >nextId(){<span class="cstat-no" title="statement not covered" >r</span>eturn++this.id}}</span>;f</span>unction <span class="fstat-no" title="function not covered" >gp(e</span>){class t{<span class="cstat-no" title="statement not covered" >_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;<span class="cstat-no" title="statement not covered" >_</span>middlewares=new Hr;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;<span class="cstat-no" title="statement not covered" >_</span>createPrismaPromise=Yn();<span class="fstat-no" title="function not covered" >c</span>onstructor(n</span>){<span class="cstat-no" title="statement not covered" >e=n?.__internal?.configOverride?.(e)??e,vs(e),n&amp;&amp;na(n,e);l</span>et i=<span class="cstat-no" title="statement not covered" >new Ur().on("error",<span class="fstat-no" title="function not covered" >()=&gt;{}</span>);<span class="cstat-no" title="statement not covered" >t</span>his._extensions=ut.empty(),this._previewFeatures=Wr(e),this._clientVersion=e.clientVersion??Ys,this._activeProvider=e.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=Gs();l</span>et o=<span class="cstat-no" title="statement not covered" >e.relativeEnvPaths&amp;&amp;{rootEnvPath:e.relativeEnvPaths.rootEnvPath&amp;&amp;pr.resolve(e.dirname,e.relativeEnvPaths.rootEnvPath),schemaEnvPath:e.relativeEnvPaths.schemaEnvPath&amp;&amp;pr.resolve(e.dirname,e.relativeEnvPaths.schemaEnvPath)},s</span>;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n?.adapter){<span class="cstat-no" title="statement not covered" >s=n.adapter;l</span>et l=<span class="cstat-no" title="statement not covered" >e.activeProvider==="postgresql"?"postgres":e.activeProvider;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(s.provider!==l)<span class="cstat-no" title="statement not covered" >throw new Q(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${l}\` specified in the Prisma schema.`,this._clientVersion);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n.datasources||n.datasourceUrl!==void 0)<span class="cstat-no" title="statement not covered" >throw new Q("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}</span></span>l</span>et a=<span class="cstat-no" title="statement not covered" >e.injectableEdgeEnv?.();<span class="cstat-no" title="statement not covered" >t</span>ry{let l=<span class="cstat-no" title="statement not covered" >n??{},d</span>=<span class="cstat-no" title="statement not covered" >l.__internal??{},g</span>=<span class="cstat-no" title="statement not covered" >d.debug===!0;<span class="cstat-no" title="statement not covered" >g</span>&amp;&amp;Y.enable("prisma:client");l</span>et h=<span class="cstat-no" title="statement not covered" >pr.resolve(e.dirname,e.relativePath);<span class="cstat-no" title="statement not covered" >q</span>i.existsSync(h)||(h=e.dirname),Ne("dirname",e.dirname),Ne("relativePath",e.relativePath),Ne("cwd",h);l</span>et v=<span class="cstat-no" title="statement not covered" >d.engine||{};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(l.errorFormat?this._errorFormat=l.errorFormat:y.env.NODE_ENV==="production"?this._errorFormat="minimal":y.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=e.runtimeDataModel,this._engineConfig={cwd:h,dirname:e.dirname,enableDebugLogs:g,allowTriggerPanic:v.allowTriggerPanic,prismaPath:v.binaryPath??void 0,engineEndpoint:v.endpoint,generator:e.generator,showColors:this._errorFormat==="pretty",logLevel:l.log&amp;&amp;Js(l.log),logQueries:l.log&amp;&amp;!!(typeof l.log=="string"?l.log==="query":l.log.find(<span class="fstat-no" title="function not covered" >S=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof S=="string"?S==="query":S.level==="query")</span>),env:a?.parsed??{},flags:[],engineWasm:e.engineWasm,compilerWasm:e.compilerWasm,clientVersion:e.clientVersion,engineVersion:e.engineVersion,previewFeatures:this._previewFeatures,activeProvider:e.activeProvider,inlineSchema:e.inlineSchema,overrideDatasources:Ts(l,e.datasourceNames),inlineDatasources:e.inlineDatasources,inlineSchemaHash:e.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:l.transactionOptions?.maxWait??2e3,timeout:l.transactionOptions?.timeout??5e3,isolationLevel:l.transactionOptions?.isolationLevel},logEmitter:i,isBundled:e.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:mt,getBatchRequestPayload:jr,prismaGraphQLToJSError:Vr,PrismaClientUnknownRequestError:se,PrismaClientInitializationError:Q,PrismaClientKnownRequestError:oe,debug:Y("prisma:client:accelerateEngine"),engineVersion:sa.version,clientVersion:e.clientVersion}},Ne("clientVersion",e.clientVersion),this._engine=Ms(e,this._engineConfig),this._requestHandler=new Yr(this,i),l.log)<span class="cstat-no" title="statement not covered" >for(let S of l.log){let A=<span class="cstat-no" title="statement not covered" >typeof S=="string"?S:S.emit==="stdout"?S.level:null;<span class="cstat-no" title="statement not covered" >A</span>&amp;&amp;this.$on(A,<span class="fstat-no" title="function not covered" >R=&gt;{<span class="cstat-no" title="statement not covered" >v</span>t.log(`${vt.tags[A]??""}`,R.message||R.query)}</span>)}</span>}</span></span>catch(l){<span class="cstat-no" title="statement not covered" >throw l.clientVersion=this._clientVersion,l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._appliedParent=$t(this)}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClient"}<span class="fstat-no" title="function not covered" ></span>$use(n</span>){<span class="cstat-no" title="statement not covered" >this._middlewares.use(n)}<span class="fstat-no" title="function not covered" ></span>$on(n</span>,i){<span class="cstat-no" title="statement not covered" >return n==="beforeExit"?this._engine.onBeforeExit(i):n&amp;&amp;this._engineConfig.logEmitter.on(n,i),this}<span class="fstat-no" title="function not covered" >$</span>connect(){<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return this._engine.start()}</span>catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>}<span class="fstat-no" title="function not covered" ></span>async $</span>disconnect(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await this._engine.stop()}</span>catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>finally{<span class="cstat-no" title="statement not covered" >Bi()}</span>}<span class="fstat-no" title="function not covered" ></span>$executeRawInternal(n</span>,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:zn({clientMethod:i,activeProvider:a}),callsite:_e(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$executeRaw(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n.raw!==void 0||n.sql!==void 0){let[s,a]=<span class="cstat-no" title="statement not covered" >oa(n,i);<span class="cstat-no" title="statement not covered" >r</span>eturn Kn(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$executeRawUnsafe(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;(<span class="cstat-no" title="statement not covered" >K</span>n(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}<span class="fstat-no" title="function not covered" ></span></span>$runCommandRaw(n</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.activeProvider!=="mongodb")<span class="cstat-no" title="statement not covered" >throw new X(`The ${e.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:_s,callsite:_e(this._errorFormat),transaction:i}))}<span class="fstat-no" title="function not covered" ></span></span>async $</span>queryRawInternal(n,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:zn({clientMethod:i,activeProvider:a}),callsite:_e(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$queryRaw(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n.raw!==void 0||n.sql!==void 0)<span class="cstat-no" title="statement not covered" >return this.$queryRawInternal(o,"$queryRaw",...oa(n,i));<span class="cstat-no" title="statement not covered" >t</span></span>hrow new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$queryRawTyped(n</span>){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!this._hasPreviewFlag("typedSql"))<span class="cstat-no" title="statement not covered" >throw new X("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.$queryRawInternal(i,"$queryRawTyped",n)}</span>)}<span class="fstat-no" title="function not covered" ></span>$queryRawUnsafe(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}<span class="fstat-no" title="function not covered" ></span></span>_transactionWithArray({</span>promises:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >dp.nextId(),s</span>=<span class="cstat-no" title="statement not covered" >Qs(n.length),a</span>=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >(l</span>,d)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(l?.[Symbol.toStringTag]!=="PrismaPromise")<span class="cstat-no" title="statement not covered" >throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");l</span></span>et g=<span class="cstat-no" title="statement not covered" >i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,</span>h=<span class="cstat-no" title="statement not covered" >{kind:"batch",id:o,index:d,isolationLevel:g,lock:s};<span class="cstat-no" title="statement not covered" >r</span>eturn l.requestTransaction?.(h)??l}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn ia(a)}<span class="fstat-no" title="function not covered" ></span>async _</span>transactionWithCallback({callback:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >{traceparent:this._tracingHelper.getTraceParent()},s</span>=<span class="cstat-no" title="statement not covered" >{maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a</span>=<span class="cstat-no" title="statement not covered" >await this._engine.transaction("start",o,s),l</span>;<span class="cstat-no" title="statement not covered" >try{let d=<span class="cstat-no" title="statement not covered" >{kind:"itx",...a};<span class="cstat-no" title="statement not covered" >l</span>=await n(this._createItxClient(d)),await this._engine.transaction("commit",o,a)}</span>catch(d){<span class="cstat-no" title="statement not covered" >throw await this._engine.transaction("rollback",o,a).catch(<span class="fstat-no" title="function not covered" >()=&gt;{}</span>),d}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l}<span class="fstat-no" title="function not covered" ></span>_createItxClient(n</span>){<span class="cstat-no" title="statement not covered" >return pe($t(pe(ls(this),[ee("_appliedParent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._appliedParent._createItxClient(n)),e</span>e("_createPrismaPromise",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Y</span>n(n)),e</span>e(fp,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>.id)</span>])),[ct(fs)])}<span class="fstat-no" title="function not covered" ></span>$transaction(n</span>,i){let o;<span class="cstat-no" title="statement not covered" >typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>hrow new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}</span>:o=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._transactionWithCallback({callback:n,options:i}):o</span>=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._transactionWithArray({promises:n,options:i});l</span></span>et s=<span class="cstat-no" title="statement not covered" >{name:"transaction",attributes:{method:"$transaction"}};<span class="cstat-no" title="statement not covered" >r</span>eturn this._tracingHelper.runInChildSpan(s,o)}<span class="fstat-no" title="function not covered" ></span>_request(n</span>){<span class="cstat-no" title="statement not covered" >n.otelParentCtx=this._tracingHelper.getActiveContext();l</span>et i=<span class="cstat-no" title="statement not covered" >n.middlewareArgsMapper??mp,o</span>=<span class="cstat-no" title="statement not covered" >{args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s</span>=<span class="cstat-no" title="statement not covered" >{middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a</span>=<span class="cstat-no" title="statement not covered" >-1,l</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >async d</span>=&gt;{let g=<span class="cstat-no" title="statement not covered" >this._middlewares.get(++a);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(g)<span class="cstat-no" title="statement not covered" >return this._tracingHelper.runInChildSpan(s.middleware,<span class="fstat-no" title="function not covered" >D=&gt;<span class="cstat-no" title="statement not covered" >g</span>(d,<span class="fstat-no" title="function not covered" >M=&gt;(<span class="cstat-no" title="statement not covered" >D</span>?.end(),l(M)</span>)));l</span></span></span>et{runInTransaction:h,args:v,...S}=<span class="cstat-no" title="statement not covered" >d,A</span>=<span class="cstat-no" title="statement not covered" >{...n,...S};<span class="cstat-no" title="statement not covered" >v</span>&amp;&amp;(A.args=i.middlewareArgsToRequestArgs(v)),n.transaction!==void 0&amp;&amp;h===!1&amp;&amp;delete A.transaction;l</span>et R=<span class="cstat-no" title="statement not covered" >await ys(this,A);<span class="cstat-no" title="statement not covered" >r</span>eturn A.model?ms({result:R,modelName:A.model,args:A.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):R}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this._tracingHelper.runInChildSpan(s.operation,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >l</span>(o))}<span class="fstat-no" title="function not covered" ></span></span>async _</span>executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:l,argsMapper:d,transaction:g,unpacker:h,otelParentCtx:v,customDataProxyFetch:S}){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >n=d?d(n):n;l</span>et A=<span class="cstat-no" title="statement not covered" >{name:"serialize"},R</span>=<span class="cstat-no" title="statement not covered" >this._tracingHelper.runInChildSpan(A,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>n({modelName:l,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));<span class="cstat-no" title="statement not covered" >r</span></span>eturn Y.enabled("prisma:client")&amp;&amp;(Ne("Prisma Client call:"),Ne(`prisma.${i}(${Zo(n)})`),Ne("Generated request:"),Ne(JSON.stringify(R,null,2)+`</span></span>
`)),g?.kind==="batch"&amp;&amp;await g.lock,this._requestHandler.request({protocolQuery:R,modelName:l,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:g,unpacker:h,otelParentCtx:v,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:S})}catch(A){<span class="cstat-no" title="statement not covered" >throw A.clientVersion=this._clientVersion,A}</span>}<span class="cstat-no" title="statement not covered" >$metrics=new Bt(this);<span class="fstat-no" title="function not covered" >_</span>hasPreviewFlag(n</span>){<span class="cstat-no" title="statement not covered" >return!!this._engineConfig.previewFeatures?.includes(n)}<span class="fstat-no" title="function not covered" ></span>$applyPendingMigrations(){<span class="cstat-no" title="statement not covered" ></span>return this._engine.applyPendingMigrations()}<span class="cstat-no" title="statement not covered" ></span>$extends=us}<span class="cstat-no" title="statement not covered" ></span>return t}</span>function <span class="fstat-no" title="function not covered" >oa(e</span>,t){<span class="cstat-no" title="statement not covered" >return hp(e)?[new le(e,t),$s]:[e,js]}f</span>unction <span class="fstat-no" title="function not covered" >hp(e</span>){<span class="cstat-no" title="statement not covered" >return Array.isArray(e)&amp;&amp;Array.isArray(e.raw)}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar yp=<span class="cstat-no" title="statement not covered" >new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);f</span>unction <span class="fstat-no" title="function not covered" >wp(e</span>){<span class="cstat-no" title="statement not covered" >return new Proxy(e,{<span class="fstat-no" title="function not covered" >get(t</span>,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r in t)<span class="cstat-no" title="statement not covered" >return t[r];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!yp.has(r))<span class="cstat-no" title="statement not covered" >throw new TypeError(`Invalid enum value: ${String(r)}`)}</span></span>})}<span class="cstat-no" title="statement not covered" ></span>f();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >m</span>();v</span>ar export_warnEnvConflicts=<span class="cstat-no" title="statement not covered" >void 0;export{<span class="cstat-no" title="statement not covered" >T</span>r as D</span>MMF,<span class="cstat-no" title="statement not covered" >Y as D</span>ebug,<span class="cstat-no" title="statement not covered" >he as D</span>ecimal,<span class="cstat-no" title="statement not covered" >vi as E</span>xtensions,<span class="cstat-no" title="statement not covered" >Bt as M</span>etricsClient,<span class="cstat-no" title="statement not covered" >Q as P</span>rismaClientInitializationError,<span class="cstat-no" title="statement not covered" >oe as P</span>rismaClientKnownRequestError,<span class="cstat-no" title="statement not covered" >Re as P</span>rismaClientRustPanicError,<span class="cstat-no" title="statement not covered" >se as P</span>rismaClientUnknownRequestError,<span class="cstat-no" title="statement not covered" >X as P</span>rismaClientValidationError,<span class="cstat-no" title="statement not covered" >Ci as P</span>ublic,<span class="cstat-no" title="statement not covered" >le as S</span>ql,<span class="cstat-no" title="statement not covered" >Ku as c</span>reateParam,<span class="cstat-no" title="statement not covered" >oc as d</span>efineDmmfProperty,<span class="cstat-no" title="statement not covered" >Ct as d</span>eserializeJsonResponse,<span class="cstat-no" title="statement not covered" >ti as d</span>eserializeRawResult,<span class="cstat-no" title="statement not covered" >du as d</span>mmfToRuntimeDataModel,<span class="cstat-no" title="statement not covered" >cc as e</span>mpty,<span class="cstat-no" title="statement not covered" >gp as g</span>etPrismaClient,<span class="cstat-no" title="statement not covered" >qn as g</span>etRuntime,<span class="cstat-no" title="statement not covered" >uc as j</span>oin,<span class="cstat-no" title="statement not covered" >wp as m</span>akeStrictEnum,<span class="cstat-no" title="statement not covered" >ac as m</span>akeTypedQueryFactory,<span class="cstat-no" title="statement not covered" >An as o</span>bjectEnumValues,<span class="cstat-no" title="statement not covered" >Ho as r</span>aw,<span class="cstat-no" title="statement not covered" >On as s</span>erializeJsonQuery,<span class="cstat-no" title="statement not covered" >kn as s</span>kip,<span class="cstat-no" title="statement not covered" >Ko as s</span>qltag,<span class="cstat-no" title="statement not covered" >export_warnEnvConflicts as w</span>arnEnvConflicts,<span class="cstat-no" title="statement not covered" >dr as w</span>arnOnce};
//# sourceMappingURL=edge-esm.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-05-21T22:28:03.832Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    