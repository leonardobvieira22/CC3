
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for src/generated/prisma/runtime/wasm.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">src/generated/prisma/runtime</a> wasm.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/3775</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/2005</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/956</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/19</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a>
<a name='L26'></a><a href='#L26'>26</a>
<a name='L27'></a><a href='#L27'>27</a>
<a name='L28'></a><a href='#L28'>28</a>
<a name='L29'></a><a href='#L29'>29</a>
<a name='L30'></a><a href='#L30'>30</a>
<a name='L31'></a><a href='#L31'>31</a>
<a name='L32'></a><a href='#L32'>32</a>
<a name='L33'></a><a href='#L33'>33</a>
<a name='L34'></a><a href='#L34'>34</a>
<a name='L35'></a><a href='#L35'>35</a>
<a name='L36'></a><a href='#L36'>36</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">&nbsp;
/* !!! This is code generated by Prisma. Do not edit directly. !!!
/* eslint-disable */
"use strict";var zo=<span class="cstat-no" title="statement not covered" >Object.create;</span>var Ot=<span class="cstat-no" title="statement not covered" >Object.defineProperty;</span>var Yo=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor;</span>var Xo=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames;</span>var Zo=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf,</span>es=<span class="cstat-no" title="statement not covered" >Object.prototype.hasOwnProperty;</span>var ne=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;(e=t(t=0)),e);v</span></span></span>ar Le=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;(<span class="cstat-no" title="statement not covered" >e</span>||t((e={exports:{}}).exports,e),e.exports</span></span></span>),rt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >for(var r in e)<span class="cstat-no" title="statement not covered" >Ot(t,r,{get:e[r],enumerable:!0})}</span></span>,c</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r,n)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e&amp;&amp;typeof e=="object"||typeof e=="function")<span class="cstat-no" title="statement not covered" >for(let i of Xo(e))<span class="cstat-no" title="statement not covered" >!es.call(t,i)&amp;&amp;i!==r&amp;&amp;Ot(t,i,{get:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>[i],</span>enumerable:!(n=Yo(e,i))||n.enumerable});<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn t}</span>;v</span>ar nt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;(<span class="cstat-no" title="statement not covered" >r=t!=null?zo(Zo(t)):{},cn(e||!t||!t.__esModule?Ot(r,"default",{value:t,enumerable:!0}):r,t)</span>),t</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >c</span>n(Ot({},"__esModule",{value:!0}),t);f</span></span>unction <span class="fstat-no" title="function not covered" >xr(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e=e.toLowerCase(),e==="utf8"||e==="utf-8")<span class="cstat-no" title="statement not covered" >return new y(os.encode(t));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e==="base64"||e==="base64url")<span class="cstat-no" title="statement not covered" >return t=t.replace(/-/g,"+").replace(/_/g,"/"),t=t.replace(/[^A-Za-z0-9+/]/g,""),new y([...atob(t)].map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.charCodeAt(0)));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(e==="binary"||e==="ascii"||e==="latin1"||e==="latin-1")<span class="cstat-no" title="statement not covered" >return new y([...t].map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.charCodeAt(0)));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(e==="ucs2"||e==="ucs-2"||e==="utf16le"||e==="utf-16le"){let r=<span class="cstat-no" title="statement not covered" >new y(t.length*2),n</span>=<span class="cstat-no" title="statement not covered" >new DataView(r.buffer);<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;t.length;i++)<span class="cstat-no" title="statement not covered" >n.setUint16(i*2,t.charCodeAt(i),!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(e==="hex"){let r=<span class="cstat-no" title="statement not covered" >new y(t.length/2);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0,i</span>=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;t.length;i+=2,n++)<span class="cstat-no" title="statement not covered" >r[n]=parseInt(t.slice(i,i+2),16);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>p</span>n(`encoding "${e}"`)}</span>function <span class="fstat-no" title="function not covered" >rs(t</span>){let r=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyNames(DataView.prototype).filter(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >a</span>.startsWith("get")||a.startsWith("set")),n</span></span>=<span class="cstat-no" title="statement not covered" >r.map(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >a</span>.replace("get","read").replace("set","write")),i</span></span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(a</span>,f)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(h</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return B(h,"offset"),Y(h,"offset"),V(h,"offset",this.length-1),new DataView(this.buffer)[r[a]](h,f)}</span>,o</span></span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(a</span>,f)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >function(h</span>,T=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{let C=<span class="cstat-no" title="statement not covered" >r[a].match(/set(\w+\d+)/)[1].toLowerCase(),k</span>=<span class="cstat-no" title="statement not covered" >is[C];<span class="cstat-no" title="statement not covered" ></span>return B(T,"offset"),Y(T,"offset"),V(T,"offset",this.length-1),ns(h,"value",k[0],k[1]),new DataView(this.buffer)[r[a]](T,h,f),T+parseInt(r[a].match(/\d+/)[0])/8}</span>,s</span></span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=&gt;{<span class="cstat-no" title="statement not covered" >a</span>.forEach(<span class="fstat-no" title="function not covered" >f=&gt;{<span class="cstat-no" title="statement not covered" >f</span>.includes("Uint")&amp;&amp;(t[f.replace("Uint","UInt")]=t[f]),f.includes("Float64")&amp;&amp;(t[f.replace("Float64","Double")]=t[f]),f.includes("Float32")&amp;&amp;(t[f.replace("Float32","Float")]=t[f]</span>)})}</span>;<span class="cstat-no" title="statement not covered" >n</span>.forEach(<span class="fstat-no" title="function not covered" >(a</span>,f)=&gt;{<span class="cstat-no" title="statement not covered" >a.startsWith("read")&amp;&amp;(t[a]=i(f,!1),t[a+"LE"]=i(f,!0),t[a+"BE"]=i(f,!1)),a.startsWith("write")&amp;&amp;(t[a]=o(f,!1),t[a+"LE"]=o(f,!0),t[a+"BE"]=o(f,!1)),s([a,a+"LE",a+"BE"])}</span>)}</span>function <span class="fstat-no" title="function not covered" >pn(t</span>){<span class="cstat-no" title="statement not covered" >throw new Error(`Buffer polyfill does not implement "${t}"`)}</span>function <span class="fstat-no" title="function not covered" >Mt(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!(t instanceof Uint8Array))<span class="cstat-no" title="statement not covered" >throw new TypeError(`The "${e}" argument must be an instance of Buffer or Uint8Array`)}</span></span>function <span class="fstat-no" title="function not covered" >V(t</span>,e,r=<span class="branch-0 cbranch-no" title="branch not covered" >ls+1)</span>{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&lt;0||t&gt;r){let n=<span class="cstat-no" title="statement not covered" >new RangeError(`The value of "${e}" is out of range. It must be &gt;= 0 &amp;&amp; &lt;= ${r}. Received ${t}`);<span class="cstat-no" title="statement not covered" >t</span>hrow n.code="ERR_OUT_OF_RANGE",n}</span>}</span>function <span class="fstat-no" title="function not covered" >B(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="number"){let r=<span class="cstat-no" title="statement not covered" >new TypeError(`The "${e}" argument must be of type number. Received type ${typeof t}.`);<span class="cstat-no" title="statement not covered" >t</span>hrow r.code="ERR_INVALID_ARG_TYPE",r}</span>}</span>function <span class="fstat-no" title="function not covered" >Y(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!Number.isInteger(t)||Number.isNaN(t)){let r=<span class="cstat-no" title="statement not covered" >new RangeError(`The value of "${e}" is out of range. It must be an integer. Received ${t}`);<span class="cstat-no" title="statement not covered" >t</span>hrow r.code="ERR_OUT_OF_RANGE",r}</span>}</span>function <span class="fstat-no" title="function not covered" >ns(t</span>,e,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t&lt;r||t&gt;n){let i=<span class="cstat-no" title="statement not covered" >new RangeError(`The value of "${e}" is out of range. It must be &gt;= ${r} and &lt;= ${n}. Received ${t}`);<span class="cstat-no" title="statement not covered" >t</span>hrow i.code="ERR_OUT_OF_RANGE",i}</span>}</span>function <span class="fstat-no" title="function not covered" >mn(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="string"){let r=<span class="cstat-no" title="statement not covered" >new TypeError(`The "${e}" argument must be of type string. Received type ${typeof t}`);<span class="cstat-no" title="statement not covered" >t</span>hrow r.code="ERR_INVALID_ARG_TYPE",r}</span>}</span>function <span class="fstat-no" title="function not covered" >us(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" >return y.from(t,e)}</span>var y,is,os,ss,as,ls,b,Er,u=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >y=<span class="cstat-no" title="statement not covered" >class t extends Uint8Array{_isBuffer=!0;<span class="fstat-no" title="function not covered" >g</span>et o</span>ffset(){<span class="cstat-no" title="statement not covered" >return this.byteOffset}<span class="fstat-no" title="function not covered" >s</span>tatic a</span>lloc(e,r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" >return mn(n,"encoding"),t.allocUnsafe(e).fill(r,n)}<span class="fstat-no" title="function not covered" ></span>static a</span>llocUnsafe(e){<span class="cstat-no" title="statement not covered" >return t.from(e)}<span class="fstat-no" title="function not covered" ></span>static a</span>llocUnsafeSlow(e){<span class="cstat-no" title="statement not covered" >return t.from(e)}<span class="fstat-no" title="function not covered" ></span>static i</span>sBuffer(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;!!e._isBuffer}<span class="fstat-no" title="function not covered" >s</span>tatic b</span>yteLength(e,r=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof e=="string")<span class="cstat-no" title="statement not covered" >return xr(e,r).byteLength;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e&amp;&amp;e.byteLength)<span class="cstat-no" title="statement not covered" >return e.byteLength;l</span></span>et n=<span class="cstat-no" title="statement not covered" >new TypeError('The "string" argument must be of type string or an instance of Buffer or ArrayBuffer.');<span class="cstat-no" title="statement not covered" >t</span>hrow n.code="ERR_INVALID_ARG_TYPE",n}<span class="fstat-no" title="function not covered" ></span>static i</span>sEncoding(e){<span class="cstat-no" title="statement not covered" >return as.includes(e)}<span class="fstat-no" title="function not covered" ></span>static c</span>ompare(e,r){<span class="cstat-no" title="statement not covered" >Mt(e,"buff1"),Mt(r,"buff2");<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;n</span>&lt;e.length;n++){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e[n]&lt;r[n])<span class="cstat-no" title="statement not covered" >return-1;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e[n]&gt;r[n])<span class="cstat-no" title="statement not covered" >return 1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e.length===r.length?0:e.length&gt;r.length?1:-1}<span class="fstat-no" title="function not covered" ></span>static f</span>rom(e,r=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e&amp;&amp;typeof e=="object"&amp;&amp;e.type==="Buffer")<span class="cstat-no" title="statement not covered" >return new t(e.data);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="number")<span class="cstat-no" title="statement not covered" >return new t(new Uint8Array(e));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e=="string")<span class="cstat-no" title="statement not covered" >return xr(e,r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(e)){let{byteOffset:n,byteLength:i,buffer:o}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >r</span>eturn"map"in e&amp;&amp;typeof e.map=="function"?new t(e.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >s</span>%256),n</span>,i):new t(o,n,i)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(e&amp;&amp;typeof e=="object"&amp;&amp;("length"in e||"byteLength"in e||"buffer"in e))<span class="cstat-no" title="statement not covered" >return new t(e);<span class="cstat-no" title="statement not covered" >t</span></span>hrow new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}<span class="fstat-no" title="function not covered" ></span>static c</span>oncat(e,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===0)<span class="cstat-no" title="statement not covered" >return t.alloc(0);l</span></span>et n=<span class="cstat-no" title="statement not covered" >[].concat(...e.map(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >[</span>...o])),i</span></span>=<span class="cstat-no" title="statement not covered" >t.alloc(r!==void 0?r:n.length);<span class="cstat-no" title="statement not covered" >r</span>eturn i.set(r!==void 0?n.slice(0,r):n),i}<span class="fstat-no" title="function not covered" ></span>slice(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >return this.subarray(e,r)}<span class="fstat-no" title="function not covered" ></span>subarray(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >return Object.setPrototypeOf(super.subarray(e,r),t.prototype)}<span class="fstat-no" title="function not covered" ></span>reverse(){<span class="cstat-no" title="statement not covered" ></span>return super.reverse(),this}<span class="fstat-no" title="function not covered" >r</span>eadIntBE(e</span>,r){<span class="cstat-no" title="statement not covered" >B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,e,r),i</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;r;o++)<span class="cstat-no" title="statement not covered" >i=i*256+n.getUint8(o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.getUint8(0)&amp;128&amp;&amp;(i-=Math.pow(256,r)),i}<span class="fstat-no" title="function not covered" ></span>readIntLE(e</span>,r){<span class="cstat-no" title="statement not covered" >B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,e,r),i</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;r;o++)<span class="cstat-no" title="statement not covered" >i+=n.getUint8(o)*Math.pow(256,o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.getUint8(r-1)&amp;128&amp;&amp;(i-=Math.pow(256,r)),i}<span class="fstat-no" title="function not covered" ></span>readUIntBE(e</span>,r){<span class="cstat-no" title="statement not covered" >B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,e,r),i</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;r;o++)<span class="cstat-no" title="statement not covered" >i=i*256+n.getUint8(o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>readUintBE(e</span>,r){<span class="cstat-no" title="statement not covered" >return this.readUIntBE(e,r)}<span class="fstat-no" title="function not covered" ></span>readUIntLE(e</span>,r){<span class="cstat-no" title="statement not covered" >B(e,"offset"),Y(e,"offset"),V(e,"offset",this.length-1),B(r,"byteLength"),Y(r,"byteLength");l</span>et n=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,e,r),i</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;r;o++)<span class="cstat-no" title="statement not covered" >i+=n.getUint8(o)*Math.pow(256,o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>readUintLE(e</span>,r){<span class="cstat-no" title="statement not covered" >return this.readUIntLE(e,r)}<span class="fstat-no" title="function not covered" ></span>writeIntBE(e</span>,r,n){<span class="cstat-no" title="statement not covered" >return e=e&lt;0?e+Math.pow(256,n):e,this.writeUIntBE(e,r,n)}<span class="fstat-no" title="function not covered" ></span>writeIntLE(e</span>,r,n){<span class="cstat-no" title="statement not covered" >return e=e&lt;0?e+Math.pow(256,n):e,this.writeUIntLE(e,r,n)}<span class="fstat-no" title="function not covered" ></span>writeUIntBE(e</span>,r,n){<span class="cstat-no" title="statement not covered" >B(r,"offset"),Y(r,"offset"),V(r,"offset",this.length-1),B(n,"byteLength"),Y(n,"byteLength");l</span>et i=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,r,n);<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >n-1;o</span>&gt;=0;o--)<span class="cstat-no" title="statement not covered" >i.setUint8(o,e&amp;255),e=e/256;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+n}<span class="fstat-no" title="function not covered" ></span>writeUintBE(e</span>,r,n){<span class="cstat-no" title="statement not covered" >return this.writeUIntBE(e,r,n)}<span class="fstat-no" title="function not covered" ></span>writeUIntLE(e</span>,r,n){<span class="cstat-no" title="statement not covered" >B(r,"offset"),Y(r,"offset"),V(r,"offset",this.length-1),B(n,"byteLength"),Y(n,"byteLength");l</span>et i=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,r,n);<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;n;o++)<span class="cstat-no" title="statement not covered" >i.setUint8(o,e&amp;255),e=e/256;<span class="cstat-no" title="statement not covered" >r</span></span>eturn r+n}<span class="fstat-no" title="function not covered" ></span>writeUintLE(e</span>,r,n){<span class="cstat-no" title="statement not covered" >return this.writeUIntLE(e,r,n)}<span class="fstat-no" title="function not covered" ></span>toJSON(){<span class="cstat-no" title="statement not covered" ></span>return{type:"Buffer",data:Array.from(this)}}<span class="fstat-no" title="function not covered" ></span>swap16(){</span>let e=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,this.byteOffset,this.byteLength);<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;this.length;r+=2)<span class="cstat-no" title="statement not covered" >e.setUint16(r,e.getUint16(r,!0),!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" >s</span>wap32(){</span>let e=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,this.byteOffset,this.byteLength);<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;this.length;r+=4)<span class="cstat-no" title="statement not covered" >e.setUint32(r,e.getUint32(r,!0),!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" >s</span>wap64(){</span>let e=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer,this.byteOffset,this.byteLength);<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;this.length;r+=8)<span class="cstat-no" title="statement not covered" >e.setBigUint64(r,e.getBigUint64(r,!0),!1);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" >c</span>ompare(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >e.length,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>o=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >return Mt(e,"target"),B(r,"targetStart"),B(n,"targetEnd"),B(i,"sourceStart"),B(o,"sourceEnd"),V(r,"targetStart"),V(n,"targetEnd",e.length),V(i,"sourceStart"),V(o,"sourceEnd",this.length),t.compare(this.slice(i,o),e.slice(r,n))}<span class="fstat-no" title="function not covered" ></span>equals(e</span>){<span class="cstat-no" title="statement not covered" >return Mt(e,"otherBuffer"),this.length===e.length&amp;&amp;this.every(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r===e[n])</span>}<span class="fstat-no" title="function not covered" ></span>copy(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" >V(r,"targetStart"),V(n,"sourceStart",this.length),V(i,"sourceEnd"),r&gt;&gt;&gt;=0,n&gt;&gt;&gt;=0,i&gt;&gt;&gt;=0;l</span>et o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;n&lt;i&amp;&amp;!(this[n]===void 0||e[r]===void 0);)<span class="cstat-no" title="statement not covered" >e[r]=this[n],o++,n++,r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}<span class="fstat-no" title="function not covered" ></span>write(e</span>,r,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8")</span>{let o=<span class="cstat-no" title="statement not covered" >typeof r=="string"?0:r??0,s</span>=<span class="cstat-no" title="statement not covered" >typeof n=="string"?this.length-o:n??this.length-o;<span class="cstat-no" title="statement not covered" >r</span>eturn i=typeof r=="string"?r:typeof n=="string"?n:i,B(o,"offset"),B(s,"length"),V(o,"offset",this.length),V(s,"length",this.length),(i==="ucs2"||i==="ucs-2"||i==="utf16le"||i==="utf-16le")&amp;&amp;(s=s-s%2),xr(e,i).copy(this,o,0,s)}<span class="fstat-no" title="function not covered" ></span>fill(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >this.length,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8")</span>{let o=<span class="cstat-no" title="statement not covered" >typeof r=="string"?0:r,s</span>=<span class="cstat-no" title="statement not covered" >typeof n=="string"?this.length:n;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i=typeof r=="string"?r:typeof n=="string"?n:i,e=t.from(typeof e=="number"?[e]:e??[],i),mn(i,"encoding"),V(o,"offset",this.length),V(s,"end",this.length),e.length!==0)<span class="cstat-no" title="statement not covered" >for(let a=<span class="cstat-no" title="statement not covered" >o;a</span>&lt;s;a+=e.length)<span class="cstat-no" title="statement not covered" >super.set(e.slice(0,e.length+a&gt;=this.length?this.length-a:e.length),a);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}<span class="fstat-no" title="function not covered" >i</span>ncludes(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8")</span>{<span class="cstat-no" title="statement not covered" >return this.indexOf(e,r,n)!==-1}<span class="fstat-no" title="function not covered" ></span>lastIndexOf(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8")</span>{<span class="cstat-no" title="statement not covered" >return this.indexOf(e,r,n,!0)}<span class="fstat-no" title="function not covered" ></span>indexOf(e</span>,r=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"utf-8",</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{let o=<span class="cstat-no" title="statement not covered" >i?this.findLastIndex.bind(this):this.findIndex.bind(this);<span class="cstat-no" title="statement not covered" >n</span>=typeof r=="string"?r:n;l</span>et s=<span class="cstat-no" title="statement not covered" >t.from(typeof e=="number"?[e]:e,n),a</span>=<span class="cstat-no" title="statement not covered" >typeof r=="string"?0:r;<span class="cstat-no" title="statement not covered" >r</span>eturn a=typeof r=="number"?a:null,a=Number.isNaN(a)?null:a,a??=i?this.length:0,a=a&lt;0?this.length+a:a,s.length===0&amp;&amp;i===!1?a&gt;=this.length?this.length:a:s.length===0&amp;&amp;i===!0?(a&gt;=this.length?this.length:a)||this.length:o(<span class="fstat-no" title="function not covered" >(f</span>,h)=&gt;<span class="cstat-no" title="statement not covered" >(i?h&lt;=a:h&gt;=a)&amp;&amp;this[h]===s[0]&amp;&amp;s.every(<span class="fstat-no" title="function not covered" >(C</span>,k)=&gt;<span class="cstat-no" title="statement not covered" >this[h+k]===C))}<span class="fstat-no" title="function not covered" ></span></span></span>toString(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >"utf8",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >this.length)</span>{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r=r&lt;0?0:r,e=e.toString().toLowerCase(),n&lt;=0)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e==="utf8"||e==="utf-8")<span class="cstat-no" title="statement not covered" >return ss.decode(this.slice(r,n));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e==="base64"||e==="base64url"){let i=<span class="cstat-no" title="statement not covered" >btoa(this.reduce(<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >o+Er(s),"</span>"));<span class="cstat-no" title="statement not covered" >r</span>eturn e==="base64url"?i.replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,""):i}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(e==="binary"||e==="ascii"||e==="latin1"||e==="latin-1")<span class="cstat-no" title="statement not covered" >return this.slice(r,n).reduce(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i+Er(o&amp;(e==="ascii"?127:255)),"</span>");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e==="ucs2"||e==="ucs-2"||e==="utf16le"||e==="utf-16le"){let i=<span class="cstat-no" title="statement not covered" >new DataView(this.buffer.slice(r,n));<span class="cstat-no" title="statement not covered" >r</span>eturn Array.from({length:i.byteLength/2},<span class="fstat-no" title="function not covered" >(o</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >s*2+1&lt;i.byteLength?Er(i.getUint16(s*2,!0)):"").j</span>oin("")}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(e==="hex")<span class="cstat-no" title="statement not covered" >return this.slice(r,n).reduce(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i+o.toString(16).padStart(2,"0"),"</span>");<span class="cstat-no" title="statement not covered" >p</span></span>n(`encoding "${e}"`)}<span class="fstat-no" title="function not covered" ></span>toLocaleString(){<span class="cstat-no" title="statement not covered" ></span>return this.toString()}<span class="fstat-no" title="function not covered" ></span>inspect(){<span class="cstat-no" title="statement not covered" ></span>return`&lt;Buffer ${this.toString("hex").match(/.{1,2}/g).join(" ")}&gt;`}}</span>;<span class="cstat-no" title="statement not covered" >i</span>s={int8:[-128,127],int16:[-32768,32767],int32:[-2147483648,2147483647],uint8:[0,255],uint16:[0,65535],uint32:[0,4294967295],float32:[-1/0,1/0],float64:[-1/0,1/0],bigint64:[-0x8000000000000000n,0x7fffffffffffffffn],biguint64:[0n,0xffffffffffffffffn]},os=new TextEncoder,ss=new TextDecoder,as=["utf8","utf-8","hex","base64","ascii","binary","base64url","ucs2","ucs-2","utf16le","utf-16le","latin1","latin-1"],ls=4294967295;<span class="cstat-no" title="statement not covered" >r</span>s(y.prototype);<span class="cstat-no" title="statement not covered" >b</span>=new Proxy(us,{<span class="fstat-no" title="function not covered" >construct(t</span>,[e,r]){<span class="cstat-no" title="statement not covered" >return y.from(e,r)}</span>,<span class="fstat-no" title="function not covered" >get(t</span>,e){<span class="cstat-no" title="statement not covered" >return y[e]}}</span>),Er=String.fromCodePoint});v</span></span>ar g,c=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >g={nextTick:<span class="fstat-no" title="function not covered" >(t</span>,...e)=&gt;{<span class="cstat-no" title="statement not covered" >setTimeout(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>(...e)}</span>,0)}</span>,env:{},version:"",cwd:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>/",s</span>tderr:{},argv:["/bin/node"]}}</span>);v</span>ar E,m=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >E=globalThis.performance??(<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et t=<span class="cstat-no" title="statement not covered" >Date.now();<span class="cstat-no" title="statement not covered" >r</span>eturn{now:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >D</span>ate.now()-t}</span>}</span>)()}</span>);v</span>ar x,p=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >x=<span class="fstat-no" title="function not covered" >()=&gt;{}</span>;<span class="cstat-no" title="statement not covered" >x</span>.prototype=x}</span>);v</span>ar w,d=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >w=class{value;<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.value=e}<span class="fstat-no" title="function not covered" ></span>deref(){<span class="cstat-no" title="statement not covered" ></span>return this.value}}</span>}</span>);f</span>unction <span class="fstat-no" title="function not covered" >yn(t</span>,e){var r,n,i,o,s,a,f,h,T=<span class="cstat-no" title="statement not covered" >t.constructor,</span>C=<span class="cstat-no" title="statement not covered" >T.precision;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!t.s||!e.s)<span class="cstat-no" title="statement not covered" >return e.s||(e=new T(t)),q?_(e,C):e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(f=t.d,h=e.d,s=t.e,i=e.e,f=f.slice(),o=s-i,o){<span class="cstat-no" title="statement not covered" >for(o&lt;0?(n=f,o=-o,a=h.length):(n=h,i=s,a=f.length),s=Math.ceil(C/N),a=s&gt;a?s+1:a+1,o&gt;a&amp;&amp;(o=a,n.length=1),n.reverse();o--;)<span class="cstat-no" title="statement not covered" >n.push(0);<span class="cstat-no" title="statement not covered" >n</span></span>.reverse()}<span class="cstat-no" title="statement not covered" ></span>f</span>or(a=f.length,o=h.length,a-o&lt;0&amp;&amp;(o=a,n=h,h=f,f=n),r=0;o;)<span class="cstat-no" title="statement not covered" >r=(f[--o]=f[o]+h[o]+r)/Q|0,f[o]%=Q;<span class="cstat-no" title="statement not covered" >f</span></span>or(r&amp;&amp;(f.unshift(r),++i),a=f.length;f[--a]==0;)<span class="cstat-no" title="statement not covered" >f.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.d=f,e.e=i,q?_(e,C):e}</span>function <span class="fstat-no" title="function not covered" >me(t</span>,e,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t!==~~t||t&lt;e||t&gt;r)<span class="cstat-no" title="statement not covered" >throw Error(Oe+t)}</span></span>function <span class="fstat-no" title="function not covered" >ce(t</span>){var e,r,n,i=<span class="cstat-no" title="statement not covered" >t.length-1,o</span>=<span class="cstat-no" title="statement not covered" >"",s</span>=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>if(i&gt;0){<span class="cstat-no" title="statement not covered" >for(o+=s,e=1;e&lt;i;e++)<span class="cstat-no" title="statement not covered" >n=t[e]+"",r=N-n.length,r&amp;&amp;(o+=Pe(r)),o+=n;<span class="cstat-no" title="statement not covered" >s</span></span>=t[e],n=s+"",r=N-n.length,r&amp;&amp;(o+=Pe(r))}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s===0)<span class="cstat-no" title="statement not covered" >return"0";<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;s%10===0;)<span class="cstat-no" title="statement not covered" >s/=10;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o+s}</span>function <span class="fstat-no" title="function not covered" >hn(t</span>,e){var r,n,i,o,s,a,f=<span class="cstat-no" title="statement not covered" >0,h</span>=<span class="cstat-no" title="statement not covered" >0,T</span>=<span class="cstat-no" title="statement not covered" >t.constructor,</span>C=<span class="cstat-no" title="statement not covered" >T.precision;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if($(t)&gt;16)<span class="cstat-no" title="statement not covered" >throw Error(vr+$(t));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!t.s)<span class="cstat-no" title="statement not covered" >return new T(ee);<span class="cstat-no" title="statement not covered" >f</span></span>or(e==null?(q=!1,a=C):a=e,s=new T(.03125);t.abs().gte(.1);)<span class="cstat-no" title="statement not covered" >t=t.times(s),h+=5;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=Math.log(ke(2,h))/Math.LN10*2+5|0,a+=n,r=i=o=new T(ee),T.precision=a;;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i=_(i.times(t),a),r=r.times(++f),s=o.plus(he(i,r,a)),ce(s.d).slice(0,a)===ce(o.d).slice(0,a)){<span class="cstat-no" title="statement not covered" >for(;h--;)<span class="cstat-no" title="statement not covered" >o=_(o.times(o),a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn T.precision=C,e==null?(q=!0,_(o,C)):o}<span class="cstat-no" title="statement not covered" ></span>o</span>=s}</span>}</span>function <span class="fstat-no" title="function not covered" >$(t</span>){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >t.e*N,r</span>=<span class="cstat-no" title="statement not covered" >t.d[0];</span>r&gt;=10;r/=10)<span class="cstat-no" title="statement not covered" >e++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Pr(t</span>,e,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e&gt;t.LN10.sd())<span class="cstat-no" title="statement not covered" >throw q=!0,r&amp;&amp;(t.precision=r),Error(ie+"LN10 precision limit exceeded");<span class="cstat-no" title="statement not covered" >r</span></span>eturn _(new t(t.LN10),e)}</span>function <span class="fstat-no" title="function not covered" >Pe(t</span>){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >"";t</span>--;)<span class="cstat-no" title="statement not covered" >e+="0";<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >it(t</span>,e){var r,n,i,o,s,a,f,h,T,C=<span class="cstat-no" title="statement not covered" >1,k</span>=<span class="cstat-no" title="statement not covered" >10,A</span>=<span class="cstat-no" title="statement not covered" >t,O</span>=<span class="cstat-no" title="statement not covered" >A.d,</span>S=<span class="cstat-no" title="statement not covered" >A.constructor,</span>M=<span class="cstat-no" title="statement not covered" >S.precision;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(A.s&lt;1)<span class="cstat-no" title="statement not covered" >throw Error(ie+(A.s?"NaN":"-Infinity"));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(A.eq(ee))<span class="cstat-no" title="statement not covered" >return new S(0);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e==null?(q=!1,h=M):h=e,A.eq(10))<span class="cstat-no" title="statement not covered" >return e==null&amp;&amp;(q=!0),Pr(S,h);<span class="cstat-no" title="statement not covered" >i</span></span>f(h+=k,S.precision=h,r=ce(O),n=r.charAt(0),o=$(A),Math.abs(o)&lt;15e14){<span class="cstat-no" title="statement not covered" >for(;n&lt;7&amp;&amp;n!=1||n==1&amp;&amp;r.charAt(1)&gt;3;)<span class="cstat-no" title="statement not covered" >A=A.times(t),r=ce(A.d),n=r.charAt(0),C++;<span class="cstat-no" title="statement not covered" >o</span></span>=$(A),n&gt;1?(A=new S("0."+r),o++):A=new S(n+"."+r.slice(1))}</span>else <span class="cstat-no" title="statement not covered" >return f=Pr(S,h+2,M).times(o+""),A=it(new S(n+"."+r.slice(1)),h-k).plus(f),S.precision=M,e==null?(q=!0,_(A,M)):A;<span class="cstat-no" title="statement not covered" >f</span></span>or(a=s=A=he(A.minus(ee),A.plus(ee),h),T=_(A.times(A),h),i=3;;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s=_(s.times(T),h),f=a.plus(he(s,new S(i),h)),ce(f.d).slice(0,h)===ce(a.d).slice(0,h))<span class="cstat-no" title="statement not covered" >return a=a.times(2),o!==0&amp;&amp;(a=a.plus(Pr(S,h+2,M).times(o+""))),a=he(a,new S(C),h),S.precision=M,e==null?(q=!0,_(a,M)):a;<span class="cstat-no" title="statement not covered" >a</span></span>=f,i+=2}</span>}</span>function <span class="fstat-no" title="function not covered" >dn(t</span>,e){var r,n,i;<span class="cstat-no" title="statement not covered" >for((r=e.indexOf("."))&gt;-1&amp;&amp;(e=e.replace(".","")),(n=e.search(/e/i))&gt;0?(r&lt;0&amp;&amp;(r=n),r+=+e.slice(n+1),e=e.substring(0,n)):r&lt;0&amp;&amp;(r=e.length),n=0;e.charCodeAt(n)===48;)<span class="cstat-no" title="statement not covered" >++n;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=e.length;e.charCodeAt(i-1)===48;)<span class="cstat-no" title="statement not covered" >--i;<span class="cstat-no" title="statement not covered" >i</span></span>f(e=e.slice(n,i),e){<span class="cstat-no" title="statement not covered" >if(i-=n,r=r-n-1,t.e=Ne(r/N),t.d=[],n=(r+1)%N,r&lt;0&amp;&amp;(n+=N),n&lt;i){<span class="cstat-no" title="statement not covered" >for(n&amp;&amp;t.d.push(+e.slice(0,n)),i-=N;n&lt;i;)<span class="cstat-no" title="statement not covered" >t.d.push(+e.slice(n,n+=N));<span class="cstat-no" title="statement not covered" >e</span></span>=e.slice(n),n=N-e.length}else <span class="cstat-no" title="statement not covered" >n</span>-=i;<span class="cstat-no" title="statement not covered" >f</span></span>or(;n--;)<span class="cstat-no" title="statement not covered" >e+="0";<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t.d.push(+e),q&amp;&amp;(t.e&gt;It||t.e&lt;-It))<span class="cstat-no" title="statement not covered" >throw Error(vr+r)}</span></span>else <span class="cstat-no" title="statement not covered" >t.s=0,t.e=0,t.d=[0];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >_(t</span>,e,r){var n,i,o,s,a,f,h,T,C=<span class="cstat-no" title="statement not covered" >t.d;<span class="cstat-no" title="statement not covered" ></span>for(s=1,o=C[0];o&gt;=10;o/=10)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >i</span></span>f(n=e-s,n&lt;0)<span class="cstat-no" title="statement not covered" >n+=N,i=e,h=C[T=0];else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(T=Math.ceil((n+1)/N),o=C.length,T&gt;=o)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(h=o=C[T],s=1;o&gt;=10;o/=10)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" >n</span></span>%=N,i=n-N+s}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(r!==void 0&amp;&amp;(o=ke(10,s-i-1),a=h/o%10|0,f=e&lt;0||C[T+1]!==void 0||h%o,f=r&lt;4?(a||f)&amp;&amp;(r==0||r==(t.s&lt;0?3:2)):a&gt;5||a==5&amp;&amp;(r==4||f||r==6&amp;&amp;(n&gt;0?i&gt;0?h/ke(10,s-i):0:C[T-1])%10&amp;1||r==(t.s&lt;0?8:7))),e&lt;1||!C[0])<span class="cstat-no" title="statement not covered" >return f?(o=$(t),C.length=1,e=e-o-1,C[0]=ke(10,(N-e%N)%N),t.e=Ne(-e/N)||0):(C.length=1,C[0]=t.e=t.s=0),t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n==0?(C.length=T,o=1,T--):(C.length=T+1,o=ke(10,N-n),C[T]=i&gt;0?(h/ke(10,s-i)%ke(10,i)|0)*o:0),f)<span class="cstat-no" title="statement not covered" >for(;;)<span class="cstat-no" title="statement not covered" >if(T==0){(<span class="cstat-no" title="statement not covered" >C[0]+=o)==Q&amp;&amp;(C[0]=1,++t.e</span>);<span class="cstat-no" title="statement not covered" >break}</span>else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(C[T]+=o,C[T]!=Q)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >C</span></span>[T--]=0,o=1}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(n=C.length;C[--n]===0;)<span class="cstat-no" title="statement not covered" >C.pop();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(q&amp;&amp;(t.e&gt;It||t.e&lt;-It))<span class="cstat-no" title="statement not covered" >throw Error(vr+$(t));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}</span>function <span class="fstat-no" title="function not covered" >bn(t</span>,e){var r,n,i,o,s,a,f,h,T,C,k=<span class="cstat-no" title="statement not covered" >t.constructor,</span>A=<span class="cstat-no" title="statement not covered" >k.precision;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!t.s||!e.s)<span class="cstat-no" title="statement not covered" >return e.s?e.s=-e.s:e=new k(t),q?_(e,A):e;<span class="cstat-no" title="statement not covered" >i</span></span>f(f=t.d,C=e.d,n=e.e,h=t.e,f=f.slice(),s=h-n,s){<span class="cstat-no" title="statement not covered" >for(T=s&lt;0,T?(r=f,s=-s,a=C.length):(r=C,n=h,a=f.length),i=Math.max(Math.ceil(A/N),a)+2,s&gt;i&amp;&amp;(s=i,r.length=1),r.reverse(),i=s;i--;)<span class="cstat-no" title="statement not covered" >r.push(0);<span class="cstat-no" title="statement not covered" >r</span></span>.reverse()}</span>else{<span class="cstat-no" title="statement not covered" >for(i=f.length,a=C.length,T=i&lt;a,T&amp;&amp;(a=i),i=0;i&lt;a;i++)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(f[i]!=C[i]){<span class="cstat-no" title="statement not covered" >T=f[i]&lt;C[i];<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>s</span></span>=0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(T&amp;&amp;(r=f,f=C,C=r,e.s=-e.s),a=f.length,i=C.length-a;i&gt;0;--i)<span class="cstat-no" title="statement not covered" >f[a++]=0;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=C.length;i&gt;s;){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(f[--i]&lt;C[i]){<span class="cstat-no" title="statement not covered" >for(o=i;o&amp;&amp;f[--o]===0;)<span class="cstat-no" title="statement not covered" >f[o]=Q-1;<span class="cstat-no" title="statement not covered" >-</span></span>-f[o],f[i]+=Q}<span class="cstat-no" title="statement not covered" ></span>f</span>[i]-=C[i]}<span class="cstat-no" title="statement not covered" >f</span></span>or(;f[--a]===0;)<span class="cstat-no" title="statement not covered" >f.pop();<span class="cstat-no" title="statement not covered" >f</span></span>or(;f[0]===0;f.shift())<span class="cstat-no" title="statement not covered" >--n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn f[0]?(e.d=f,e.e=n,q?_(e,A):e):new k(0)}</span>function <span class="fstat-no" title="function not covered" >Me(t</span>,e,r){var n,i=<span class="cstat-no" title="statement not covered" >$(t),o</span>=<span class="cstat-no" title="statement not covered" >ce(t.d),s</span>=<span class="cstat-no" title="statement not covered" >o.length;<span class="cstat-no" title="statement not covered" ></span>return e?(r&amp;&amp;(n=r-s)&gt;0?o=o.charAt(0)+"."+o.slice(1)+Pe(n):s&gt;1&amp;&amp;(o=o.charAt(0)+"."+o.slice(1)),o=o+(i&lt;0?"e":"e+")+i):i&lt;0?(o="0."+Pe(-i-1)+o,r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(o+=Pe(n))):i&gt;=s?(o+=Pe(i+1-s),r&amp;&amp;(n=r-i-1)&gt;0&amp;&amp;(o=o+"."+Pe(n))):((n=i+1)&lt;s&amp;&amp;(o=o.slice(0,n)+"."+o.slice(n)),r&amp;&amp;(n=r-s)&gt;0&amp;&amp;(i+1===s&amp;&amp;(o+="."),o+=Pe(n))),t.s&lt;0?"-"+o:o}</span>function <span class="fstat-no" title="function not covered" >fn(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.length&gt;e)<span class="cstat-no" title="statement not covered" >return t.length=e,!0}</span></span>function <span class="fstat-no" title="function not covered" >wn(t</span>){var e,r,n;function <span class="fstat-no" title="function not covered" >i(o</span>){var s=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!(s instanceof i))<span class="cstat-no" title="statement not covered" >return new i(o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(s.constructor=i,o instanceof i){<span class="cstat-no" title="statement not covered" >s.s=o.s,s.e=o.e,s.d=(o=o.d)?o.slice():o;<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>i</span>f(typeof o=="number"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o*0!==0)<span class="cstat-no" title="statement not covered" >throw Error(Oe+o);<span class="cstat-no" title="statement not covered" >i</span></span>f(o&gt;0)<span class="cstat-no" title="statement not covered" >s.s=1;else <span class="cstat-no" title="statement not covered" >i</span>f(o&lt;0)<span class="cstat-no" title="statement not covered" >o=-o,s.s=-1;else{<span class="cstat-no" title="statement not covered" ></span>s.s=0,s.e=0,s.d=[0];<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span></span>f(o===~~o&amp;&amp;o&lt;1e7){<span class="cstat-no" title="statement not covered" >s.e=0,s.d=[o];<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn dn(s,o.toString())}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof o!="string")<span class="cstat-no" title="statement not covered" >throw Error(Oe+o);<span class="cstat-no" title="statement not covered" >i</span></span></span>f(o.charCodeAt(0)===45?(o=o.slice(1),s.s=-1):s.s=1,ms.test(o))<span class="cstat-no" title="statement not covered" >dn(s,o);else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(Oe+o)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span></span>if(i.prototype=R,i.ROUND_UP=0,i.ROUND_DOWN=1,i.ROUND_CEIL=2,i.ROUND_FLOOR=3,i.ROUND_HALF_UP=4,i.ROUND_HALF_DOWN=5,i.ROUND_HALF_EVEN=6,i.ROUND_HALF_CEIL=7,i.ROUND_HALF_FLOOR=8,i.clone=wn,i.config=i.set=ps,t===void 0&amp;&amp;(t={}),t)<span class="cstat-no" title="statement not covered" >for(n=["precision","rounding","toExpNeg","toExpPos","LN10"],e=0;e&lt;n.length;)<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(r=n[e++])||(t[r]=this[r]</span></span></span>);<span class="cstat-no" title="statement not covered" >return i.config(t),i}</span>function <span class="fstat-no" title="function not covered" >ps(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t||typeof t!="object")<span class="cstat-no" title="statement not covered" >throw Error(ie+"Object expected");v</span></span>ar e,r,n,i=<span class="cstat-no" title="statement not covered" >["precision",1,Fe,"rounding",0,8,"toExpNeg",-1/0,0,"toExpPos",0,1/0];<span class="cstat-no" title="statement not covered" >f</span>or(e=0;e&lt;i.length;e+=3)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((n=t[r=i[e]])!==void 0)<span class="cstat-no" title="statement not covered" >if(Ne(n)===n&amp;&amp;n&gt;=i[e+1]&amp;&amp;n&lt;=i[e+2])<span class="cstat-no" title="statement not covered" >this[r]=n;else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(Oe+r+": "+n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span></span>f((n=t[r="LN10"])!==void 0)<span class="cstat-no" title="statement not covered" >if(n==Math.LN10)<span class="cstat-no" title="statement not covered" >this[r]=new this(n);else <span class="cstat-no" title="statement not covered" >t</span>hrow Error(Oe+r+": "+n);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn this}v</span>ar Fe,cs,Tr,q,ie,Oe,vr,Ne,ke,ms,ee,Q,N,gn,It,R,he,Tr,Dt,xn=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >F</span>e=1e9,cs={precision:20,rounding:4,toExpNeg:-7,toExpPos:21,LN10:"2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"},q=!0,ie="[DecimalError] ",Oe=ie+"Invalid argument: ",vr=ie+"Exponent out of range: ",Ne=Math.floor,ke=Math.pow,ms=/^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,Q=1e7,N=7,gn=9007199254740991,It=Ne(gn/N),R={};<span class="cstat-no" title="statement not covered" >R</span>.absoluteValue=R.abs=<span class="fstat-no" title="function not covered" >function(){v</span>ar t=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" >r</span>eturn t.s&amp;&amp;(t.s=1),t}</span>;<span class="cstat-no" title="statement not covered" >R</span>.comparedTo=R.cmp=<span class="fstat-no" title="function not covered" >function(t</span>){var e,r,n,i,o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(t=new o.constructor(t),o.s!==t.s)<span class="cstat-no" title="statement not covered" >return o.s||-t.s;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(o.e!==t.e)<span class="cstat-no" title="statement not covered" >return o.e&gt;t.e^o.s&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=o.d.length,i=t.d.length,e=0,r=n&lt;i?n:i;e&lt;r;++e)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o.d[e]!==t.d[e])<span class="cstat-no" title="statement not covered" >return o.d[e]&gt;t.d[e]^o.s&lt;0?1:-1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn n===i?0:n&gt;i^o.s&lt;0?1:-1}</span>;<span class="cstat-no" title="statement not covered" >R</span>.decimalPlaces=R.dp=<span class="fstat-no" title="function not covered" >function(){v</span>ar t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >t.d.length-1,r</span>=<span class="cstat-no" title="statement not covered" >(e-t.e)*N;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e=t.d[e],e)<span class="cstat-no" title="statement not covered" >for(;e%10==0;e/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn r&lt;0?0:r}</span>;<span class="cstat-no" title="statement not covered" >R</span>.dividedBy=R.div=<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >return he(this,new this.constructor(t))}</span>;<span class="cstat-no" title="statement not covered" >R</span>.dividedToIntegerBy=R.idiv=<span class="fstat-no" title="function not covered" >function(t</span>){var e=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >e.constructor;<span class="cstat-no" title="statement not covered" ></span>return _(he(e,new r(t),0,1),r.precision)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.equals=R.eq=<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >return!this.cmp(t)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.exponent=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn $(this)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.greaterThan=R.gt=<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(t)&gt;0}</span>;<span class="cstat-no" title="statement not covered" >R</span>.greaterThanOrEqualTo=R.gte=<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(t)&gt;=0}</span>;<span class="cstat-no" title="statement not covered" >R</span>.isInteger=R.isint=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.e&gt;this.d.length-2}</span>;<span class="cstat-no" title="statement not covered" >R</span>.isNegative=R.isneg=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.s&lt;0}</span>;<span class="cstat-no" title="statement not covered" >R</span>.isPositive=R.ispos=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.s&gt;0}</span>;<span class="cstat-no" title="statement not covered" >R</span>.isZero=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn this.s===0}</span>;<span class="cstat-no" title="statement not covered" >R</span>.lessThan=R.lt=<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(t)&lt;0}</span>;<span class="cstat-no" title="statement not covered" >R</span>.lessThanOrEqualTo=R.lte=<span class="fstat-no" title="function not covered" >function(t</span>){<span class="cstat-no" title="statement not covered" >return this.cmp(t)&lt;1}</span>;<span class="cstat-no" title="statement not covered" >R</span>.logarithm=R.log=<span class="fstat-no" title="function not covered" >function(t</span>){var e,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor,</span>i=<span class="cstat-no" title="statement not covered" >n.precision,</span>o=<span class="cstat-no" title="statement not covered" >i+5;<span class="cstat-no" title="statement not covered" >i</span>f(t===void 0)<span class="cstat-no" title="statement not covered" >t=new n(10);else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t=new n(t),t.s&lt;1||t.eq(ee))<span class="cstat-no" title="statement not covered" >throw Error(ie+"NaN");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(r.s&lt;1)<span class="cstat-no" title="statement not covered" >throw Error(ie+(r.s?"NaN":"-Infinity"));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.eq(ee)?new n(0):(q=!1,e=he(it(r,o),it(t,o),o),q=!0,_(e,i))}</span>;<span class="cstat-no" title="statement not covered" >R</span>.minus=R.sub=<span class="fstat-no" title="function not covered" >function(t</span>){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t=new e.constructor(t),e.s==t.s?bn(e,t):yn(e,(t.s=-t.s,t))}</span>;<span class="cstat-no" title="statement not covered" >R</span>.modulo=R.mod=<span class="fstat-no" title="function not covered" >function(t</span>){var e,r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor,</span>i=<span class="cstat-no" title="statement not covered" >n.precision;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(t=new n(t),!t.s)<span class="cstat-no" title="statement not covered" >throw Error(ie+"NaN");<span class="cstat-no" title="statement not covered" >r</span></span>eturn r.s?(q=!1,e=he(r,t,0,1).times(t),q=!0,r.minus(e)):_(new n(r),i)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.naturalExponential=R.exp=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn hn(this)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.naturalLogarithm=R.ln=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn it(this)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.negated=R.neg=<span class="fstat-no" title="function not covered" >function(){v</span>ar t=<span class="cstat-no" title="statement not covered" >new this.constructor(this);<span class="cstat-no" title="statement not covered" >r</span>eturn t.s=-t.s||0,t}</span>;<span class="cstat-no" title="statement not covered" >R</span>.plus=R.add=<span class="fstat-no" title="function not covered" >function(t</span>){var e=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t=new e.constructor(t),e.s==t.s?yn(e,t):bn(e,(t.s=-t.s,t))}</span>;<span class="cstat-no" title="statement not covered" >R</span>.precision=R.sd=<span class="fstat-no" title="function not covered" >function(t</span>){var e,r,n,i=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(t!==void 0&amp;&amp;t!==!!t&amp;&amp;t!==1&amp;&amp;t!==0)<span class="cstat-no" title="statement not covered" >throw Error(Oe+t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e=$(i)+1,n=i.d.length-1,r=n*N+1,n=i.d[n],n){<span class="cstat-no" title="statement not covered" >for(;n%10==0;n/=10)<span class="cstat-no" title="statement not covered" >r--;<span class="cstat-no" title="statement not covered" >f</span></span>or(n=i.d[0];n&gt;=10;n/=10)<span class="cstat-no" title="statement not covered" >r++}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t&amp;&amp;e&gt;r?e:r}</span>;<span class="cstat-no" title="statement not covered" >R</span>.squareRoot=R.sqrt=<span class="fstat-no" title="function not covered" >function(){v</span>ar t,e,r,n,i,o,s,a=<span class="cstat-no" title="statement not covered" >this,</span>f=<span class="cstat-no" title="statement not covered" >a.constructor;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(a.s&lt;1){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!a.s)<span class="cstat-no" title="statement not covered" >return new f(0);<span class="cstat-no" title="statement not covered" >t</span></span>hrow Error(ie+"NaN")}<span class="cstat-no" title="statement not covered" ></span>f</span>or(t=$(a),q=!1,i=Math.sqrt(+a),i==0||i==1/0?(e=ce(a.d),(e.length+t)%2==0&amp;&amp;(e+="0"),i=Math.sqrt(e),t=Ne((t+1)/2)-(t&lt;0||t%2),i==1/0?e="5e"+t:(e=i.toExponential(),e=e.slice(0,e.indexOf("e")+1)+t),n=new f(e)):n=new f(i.toString()),r=f.precision,i=s=r+3;;)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o=n,n=o.plus(he(a,o,s+2)).times(.5),ce(o.d).slice(0,s)===(e=ce(n.d)).slice(0,s)){<span class="cstat-no" title="statement not covered" >if(e=e.slice(s-3,s+1),i==s&amp;&amp;e=="4999"){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(_(o,r+1,0),o.times(o).eq(a)){<span class="cstat-no" title="statement not covered" >n=o;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e!="9999")<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >s</span></span></span>+=4}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn q=!0,_(n,r)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.times=R.mul=<span class="fstat-no" title="function not covered" >function(t</span>){var e,r,n,i,o,s,a,f,h,T=<span class="cstat-no" title="statement not covered" >this,</span>C=<span class="cstat-no" title="statement not covered" >T.constructor,</span>k=<span class="cstat-no" title="statement not covered" >T.d,</span>A=<span class="cstat-no" title="statement not covered" >(t=new C(t)).d;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!T.s||!t.s)<span class="cstat-no" title="statement not covered" >return new C(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(t.s*=T.s,r=T.e+t.e,f=k.length,h=A.length,f&lt;h&amp;&amp;(o=k,k=A,A=o,s=f,f=h,h=s),o=[],s=f+h,n=s;n--;)<span class="cstat-no" title="statement not covered" >o.push(0);<span class="cstat-no" title="statement not covered" >f</span></span>or(n=h;--n&gt;=0;){<span class="cstat-no" title="statement not covered" >for(e=0,i=f+n;i&gt;n;)<span class="cstat-no" title="statement not covered" >a=o[i]+A[n]*k[i-n-1]+e,o[i--]=a%Q|0,e=a/Q|0;<span class="cstat-no" title="statement not covered" >o</span></span>[i]=(o[i]+e)%Q|0}<span class="cstat-no" title="statement not covered" ></span>f</span>or(;!o[--s];)<span class="cstat-no" title="statement not covered" >o.pop();<span class="cstat-no" title="statement not covered" >r</span></span>eturn e?++r:o.shift(),t.d=o,t.e=r,q?_(t,C.precision):t}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toDecimalPlaces=R.todp=<span class="fstat-no" title="function not covered" >function(t</span>,e){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return r=new n(r),t===void 0?r:(me(t,0,Fe),e===void 0?e=n.rounding:me(e,0,8),_(r,t+$(r)+1,e))}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toExponential=<span class="fstat-no" title="function not covered" >function(t</span>,e){var r,n=<span class="cstat-no" title="statement not covered" >this,</span>i=<span class="cstat-no" title="statement not covered" >n.constructor;<span class="cstat-no" title="statement not covered" ></span>return t===void 0?r=Me(n,!0):(me(t,0,Fe),e===void 0?e=i.rounding:me(e,0,8),n=_(new i(n),t+1,e),r=Me(n,!0,t+1)),r}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toFixed=<span class="fstat-no" title="function not covered" >function(t</span>,e){var r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return t===void 0?Me(i):(me(t,0,Fe),e===void 0?e=o.rounding:me(e,0,8),n=_(new o(i),t+$(i)+1,e),r=Me(n.abs(),!1,t+$(n)+1),i.isneg()&amp;&amp;!i.isZero()?"-"+r:r)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toInteger=R.toint=<span class="fstat-no" title="function not covered" >function(){v</span>ar t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return _(new e(t),$(t)+1,e.rounding)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toNumber=<span class="fstat-no" title="function not covered" >function(){<span class="cstat-no" title="statement not covered" >r</span>eturn+this};<span class="cstat-no" title="statement not covered" >R</span></span>.toPower=R.pow=<span class="fstat-no" title="function not covered" >function(t</span>){var e,r,n,i,o,s,a=<span class="cstat-no" title="statement not covered" >this,</span>f=<span class="cstat-no" title="statement not covered" >a.constructor,</span>h=<span class="cstat-no" title="statement not covered" >12,T</span>=<span class="cstat-no" title="statement not covered" >+(t=new f(t));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!t.s)<span class="cstat-no" title="statement not covered" >return new f(ee);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(a=new f(a),!a.s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.s&lt;1)<span class="cstat-no" title="statement not covered" >throw Error(ie+"Infinity");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(a.eq(ee))<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n=f.precision,t.eq(ee))<span class="cstat-no" title="statement not covered" >return _(a,n);<span class="cstat-no" title="statement not covered" >i</span></span>f(e=t.e,r=t.d.length-1,s=e&gt;=r,o=a.s,s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if((r=T&lt;0?-T:T)&lt;=gn){<span class="cstat-no" title="statement not covered" >for(i=new f(ee),e=Math.ceil(n/N+4),q=!1;r%2&amp;&amp;(i=i.times(a),fn(i.d,e)),r=Ne(r/2),r!==0;)<span class="cstat-no" title="statement not covered" >a=a.times(a),fn(a.d,e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn q=!0,t.s&lt;0?new f(ee).div(i):_(i,n)}</span>}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o&lt;0)<span class="cstat-no" title="statement not covered" >throw Error(ie+"NaN");<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn o=o&lt;0&amp;&amp;t.d[Math.max(e,r)]&amp;1?-1:1,a.s=1,q=!1,i=t.times(it(a,n+h)),q=!0,i=hn(i),i.s=o,i}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toPrecision=<span class="fstat-no" title="function not covered" >function(t</span>,e){var r,n,i=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.constructor;<span class="cstat-no" title="statement not covered" ></span>return t===void 0?(r=$(i),n=Me(i,r&lt;=o.toExpNeg||r&gt;=o.toExpPos)):(me(t,1,Fe),e===void 0?e=o.rounding:me(e,0,8),i=_(new o(i),t,e),r=$(i),n=Me(i,t&lt;=r||r&lt;=o.toExpNeg,t)),n}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toSignificantDigits=R.tosd=<span class="fstat-no" title="function not covered" >function(t</span>,e){var r=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >r.constructor;<span class="cstat-no" title="statement not covered" ></span>return t===void 0?(t=n.precision,e=n.rounding):(me(t,1,Fe),e===void 0?e=n.rounding:me(e,0,8)),_(new n(r),t,e)}</span>;<span class="cstat-no" title="statement not covered" >R</span>.toString=R.valueOf=R.val=R.toJSON=R[Symbol.for("nodejs.util.inspect.custom")]=<span class="fstat-no" title="function not covered" >function(){v</span>ar t=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >$(t),r</span>=<span class="cstat-no" title="statement not covered" >t.constructor;<span class="cstat-no" title="statement not covered" ></span>return Me(t,e&lt;=r.toExpNeg||e&gt;=r.toExpPos)}</span>;<span class="cstat-no" title="statement not covered" >h</span>e=<span class="fstat-no" title="function not covered" >function(){f</span>unction <span class="fstat-no" title="function not covered" >t(n</span>,i){var o,s=<span class="cstat-no" title="statement not covered" >0,a</span>=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>for(n=n.slice();a--;)<span class="cstat-no" title="statement not covered" >o=n[a]*i+s,n[a]=o%Q|0,s=o/Q|0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s&amp;&amp;n.unshift(s),n}</span>function <span class="fstat-no" title="function not covered" >e(n</span>,i,o,s){var a,f;<span class="cstat-no" title="statement not covered" >if(o!=s)<span class="cstat-no" title="statement not covered" >f=o&gt;s?1:-1;else <span class="cstat-no" title="statement not covered" >f</span>or(a=f=0;a&lt;o;a++)<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n[a]!=i[a]){<span class="cstat-no" title="statement not covered" >f=n[a]&gt;i[a]?1:-1;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn f}</span>function <span class="fstat-no" title="function not covered" >r(n</span>,i,o){<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;o</span>--;)<span class="cstat-no" title="statement not covered" >n[o]-=s,s=n[o]&lt;i[o]?1:0,n[o]=s*Q+n[o]-i[o];<span class="cstat-no" title="statement not covered" >f</span></span>or(;!n[0]&amp;&amp;n.length&gt;1;)<span class="cstat-no" title="statement not covered" >n.shift()}<span class="cstat-no" title="statement not covered" ></span></span>return <span class="fstat-no" title="function not covered" >function(n</span>,i,o,s){var a,f,h,T,C,k,A,O,S,M,oe,H,L,z,Se,wr,se,St,kt=<span class="cstat-no" title="statement not covered" >n.constructor,</span>Ho=<span class="cstat-no" title="statement not covered" >n.s==i.s?1:-1,u</span>e=<span class="cstat-no" title="statement not covered" >n.d,</span>U=<span class="cstat-no" title="statement not covered" >i.d;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!n.s)<span class="cstat-no" title="statement not covered" >return new kt(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!i.s)<span class="cstat-no" title="statement not covered" >throw Error(ie+"Division by zero");<span class="cstat-no" title="statement not covered" >f</span></span>or(f=n.e-i.e,se=U.length,Se=ue.length,A=new kt(Ho),O=A.d=[],h=0;U[h]==(ue[h]||0);)<span class="cstat-no" title="statement not covered" >++h;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(U[h]&gt;(ue[h]||0)&amp;&amp;--f,o==null?H=o=kt.precision:s?H=o+($(n)-$(i))+1:H=o,H&lt;0)<span class="cstat-no" title="statement not covered" >return new kt(0);<span class="cstat-no" title="statement not covered" >i</span></span>f(H=H/N+2|0,h=0,se==1)<span class="cstat-no" title="statement not covered" >for(T=0,U=U[0],H++;(h&lt;Se||T)&amp;&amp;H--;h++)<span class="cstat-no" title="statement not covered" >L=T*Q+(ue[h]||0),O[h]=L/U|0,T=L%U|0;else{<span class="cstat-no" title="statement not covered" ></span></span>for(T=Q/(U[0]+1)|0,T&gt;1&amp;&amp;(U=t(U,T),ue=t(ue,T),se=U.length,Se=ue.length),z=se,S=ue.slice(0,se),M=S.length;M&lt;se;)<span class="cstat-no" title="statement not covered" >S[M++]=0;<span class="cstat-no" title="statement not covered" >S</span></span>t=U.slice(),St.unshift(0),wr=U[0],U[1]&gt;=Q/2&amp;&amp;++wr;<span class="cstat-no" title="statement not covered" >d</span>o <span class="cstat-no" title="statement not covered" >T=0,a=e(U,S,se,M),a&lt;0?(oe=S[0],se!=M&amp;&amp;(oe=oe*Q+(S[1]||0)),T=oe/wr|0,T&gt;1?(T&gt;=Q&amp;&amp;(T=Q-1),C=t(U,T),k=C.length,M=S.length,a=e(C,S,k,M),a==1&amp;&amp;(T--,r(C,se&lt;k?St:U,k))):(T==0&amp;&amp;(a=T=1),C=U.slice()),k=C.length,k&lt;M&amp;&amp;C.unshift(0),r(S,C,M),a==-1&amp;&amp;(M=S.length,a=e(U,S,se,M),a&lt;1&amp;&amp;(T++,r(S,se&lt;M?St:U,M))),M=S.length):a===0&amp;&amp;(T++,S=[0]),O[h++]=T,a&amp;&amp;S[0]?S[M++]=ue[z]||0:(S=[ue[z]],M=1);while((</span>z++&lt;Se||S[0]!==void 0)&amp;&amp;H--)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn O[0]||O.shift(),A.e=f,_(A,s?o+$(A)+1:o)}</span>}</span>();<span class="cstat-no" title="statement not covered" >T</span>r=wn(cs);<span class="cstat-no" title="statement not covered" >e</span>e=new Tr(1);<span class="cstat-no" title="statement not covered" >D</span>t=Tr}</span>);v</span>ar v,ae,l=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >xn();<span class="cstat-no" title="statement not covered" >v</span>=class extends Dt{<span class="fstat-no" title="function not covered" >static i</span>sDecimal(e){<span class="cstat-no" title="statement not covered" >return e instanceof Dt}<span class="fstat-no" title="function not covered" ></span>static r</span>andom(e=<span class="branch-0 cbranch-no" title="branch not covered" >20)</span>{{let n=<span class="cstat-no" title="statement not covered" >globalThis.crypto.getRandomValues(new Uint8Array(e)).reduce(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i+o,"</span>");<span class="cstat-no" title="statement not covered" >r</span>eturn new Dt(`0.${n.slice(0,e)}`)}</span>}},ae=v}</span>);f</span>unction <span class="fstat-no" title="function not covered" >bs(){<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Nn(){<span class="cstat-no" title="statement not covered" >r</span>eturn{dev:0,ino:0,mode:0,nlink:0,uid:0,gid:0,rdev:0,size:0,blksize:0,blocks:0,atimeMs:0,mtimeMs:0,ctimeMs:0,birthtimeMs:0,atime:new Date,mtime:new Date,ctime:new Date,birthtime:new Date}}</span>function <span class="fstat-no" title="function not covered" >ws(){<span class="cstat-no" title="statement not covered" >r</span>eturn Nn()}</span>function <span class="fstat-no" title="function not covered" >xs(){<span class="cstat-no" title="statement not covered" >r</span>eturn[]}f</span>unction <span class="fstat-no" title="function not covered" >Es(t</span>){<span class="cstat-no" title="statement not covered" >t(null,[])}</span>function <span class="fstat-no" title="function not covered" >Ps(){<span class="cstat-no" title="statement not covered" >r</span>eturn""}</span>function <span class="fstat-no" title="function not covered" >vs(){<span class="cstat-no" title="statement not covered" >r</span>eturn""}</span>function <span class="fstat-no" title="function not covered" >Ts(){}</span>function <span class="fstat-no" title="function not covered" >Cs(){}</span>function <span class="fstat-no" title="function not covered" >Rs(){}</span>function <span class="fstat-no" title="function not covered" >As(){}</span>function <span class="fstat-no" title="function not covered" >Ss(){}</span>function <span class="fstat-no" title="function not covered" >ks(){}</span>var Os,Ms,qn,Un=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >O</span>s={},Ms={existsSync:bs,lstatSync:Nn,statSync:ws,readdirSync:xs,readdir:Es,readlinkSync:Ps,realpathSync:vs,chmodSync:Ts,renameSync:Cs,mkdirSync:Rs,rmdirSync:As,rmSync:Ss,unlinkSync:ks,promises:Os},qn=Ms}</span>);f</span>unction <span class="fstat-no" title="function not covered" >Is(.</span>..t){<span class="cstat-no" title="statement not covered" >return t.join("/")}</span>function <span class="fstat-no" title="function not covered" >Ds(.</span>..t){<span class="cstat-no" title="statement not covered" >return t.join("/")}</span>function <span class="fstat-no" title="function not covered" >_s(t</span>){let e=<span class="cstat-no" title="statement not covered" >Bn(t),r</span>=<span class="cstat-no" title="statement not covered" >$n(t),[</span>n,i]=<span class="cstat-no" title="statement not covered" >e.split(".");<span class="cstat-no" title="statement not covered" >r</span>eturn{root:"/",dir:r,base:e,ext:i,name:n}}</span>function <span class="fstat-no" title="function not covered" >Bn(t</span>){let e=<span class="cstat-no" title="statement not covered" >t.split("/");<span class="cstat-no" title="statement not covered" >r</span>eturn e[e.length-1]}f</span>unction <span class="fstat-no" title="function not covered" >$n(t</span>){<span class="cstat-no" title="statement not covered" >return t.split("/").slice(0,-1).join("/")}</span>var Vn,Ls,Fs,Nt,jn=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >V</span>n="/",Ls={sep:Vn},Fs={basename:Bn,dirname:$n,join:Ds,parse:_s,posix:Ls,resolve:Is,sep:Vn},Nt=Fs}</span>);v</span>ar Qn=<span class="cstat-no" title="statement not covered" >Le(<span class="fstat-no" title="function not covered" >(Z</span>c,Ns)=&gt;{<span class="cstat-no" title="statement not covered" >Ns.exports={name:"@prisma/internals",version:"6.8.2",description:"This package is intended for Prisma's internal use",main:"dist/index.js",types:"dist/index.d.ts",repository:{type:"git",url:"https://github.com/prisma/prisma.git",directory:"packages/internals"},homepage:"https://www.prisma.io",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",bugs:"https://github.com/prisma/prisma/issues",license:"Apache-2.0",scripts:{dev:"DEV=true tsx helpers/build.ts",build:"tsx helpers/build.ts",test:"dotenv -e ../../.db.env -- jest --silent",prepublishOnly:"pnpm run build"},files:["README.md","dist","!**/libquery_engine*","!dist/get-generators/engines/*","scripts"],devDependencies:{"@babel/helper-validator-identifier":"7.25.9","@opentelemetry/api":"1.9.0","@swc/core":"1.11.5","@swc/jest":"0.2.37","@types/babel__helper-validator-identifier":"7.15.2","@types/jest":"29.5.14","@types/node":"18.19.76","@types/resolve":"1.20.6",archiver:"6.0.2","checkpoint-client":"1.1.33","cli-truncate":"4.0.0",dotenv:"16.5.0",esbuild:"0.25.1","escape-string-regexp":"5.0.0",execa:"5.1.1","fast-glob":"3.3.3","find-up":"7.0.0","fp-ts":"2.16.9","fs-extra":"11.3.0","fs-jetpack":"5.1.0","global-dirs":"4.0.0",globby:"11.1.0","identifier-regex":"1.0.0","indent-string":"4.0.0","is-windows":"1.0.2","is-wsl":"3.1.0",jest:"29.7.0","jest-junit":"16.0.0",kleur:"4.1.5","mock-stdin":"1.0.0","new-github-issue-url":"0.2.1","node-fetch":"3.3.2","npm-packlist":"5.1.3",open:"7.4.2","p-map":"4.0.0","read-package-up":"11.0.0",resolve:"1.22.10","string-width":"7.2.0","strip-ansi":"6.0.1","strip-indent":"4.0.0","temp-dir":"2.0.0",tempy:"1.0.1","terminal-link":"4.0.0",tmp:"0.2.3","ts-node":"10.9.2","ts-pattern":"5.6.2","ts-toolbelt":"9.6.0",typescript:"5.4.5",yarn:"1.22.22"},dependencies:{"@prisma/config":"workspace:*","@prisma/debug":"workspace:*","@prisma/dmmf":"workspace:*","@prisma/driver-adapter-utils":"workspace:*","@prisma/engines":"workspace:*","@prisma/fetch-engine":"workspace:*","@prisma/generator":"workspace:*","@prisma/generator-helper":"workspace:*","@prisma/get-platform":"workspace:*","@prisma/prisma-schema-wasm":"6.8.0-43.2060c79ba17c6bb9f5823312b6f6b7f4a845738e","@prisma/schema-engine-wasm":"6.8.0-43.2060c79ba17c6bb9f5823312b6f6b7f4a845738e","@prisma/schema-files-loader":"workspace:*",arg:"5.0.2",prompts:"2.4.2"},peerDependencies:{typescript:"&gt;=5.1.0"},peerDependenciesMeta:{typescript:{optional:!0}},sideEffects:!1}}</span>);v</span>ar Kn=<span class="cstat-no" title="statement not covered" >Le(<span class="fstat-no" title="function not covered" >(E</span>m,Wn)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >W</span>n.exports=<span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>r)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r={indent:" ",includeEmptyLines:!1,...r},typeof t!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof t}\``);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof e!="number")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof e}\``);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof r.indent!="string")<span class="cstat-no" title="statement not covered" >throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e===0)<span class="cstat-no" title="statement not covered" >return t;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;<span class="cstat-no" title="statement not covered" >r</span>eturn t.replace(n,r.indent.repeat(e))}</span>}</span>);v</span>ar Yn=<span class="cstat-no" title="statement not covered" >Le(<span class="fstat-no" title="function not covered" >(L</span>m,zn)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >z</span>n.exports=<span class="fstat-no" title="function not covered" >({</span>onlyFirst:t=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{let e=<span class="cstat-no" title="statement not covered" >["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&amp;.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=&gt;&lt;~]))"].join("|");<span class="cstat-no" title="statement not covered" >r</span>eturn new RegExp(e,t?void 0:"g")}</span>}</span>);v</span>ar Zn=<span class="cstat-no" title="statement not covered" >Le(<span class="fstat-no" title="function not covered" >(V</span>m,Xn)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Js=<span class="cstat-no" title="statement not covered" >Yn();<span class="cstat-no" title="statement not covered" >X</span>n.exports=<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof t=="string"?t.replace(Js(),""):t}</span></span>);v</span>ar Fr=<span class="cstat-no" title="statement not covered" >Le(<span class="fstat-no" title="function not covered" >(s</span>y,ii)=&gt;{"use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >i</span>i.exports=<span class="fstat-no" title="function not covered" >function(){f</span>unction <span class="fstat-no" title="function not covered" >t(e</span>,r,n,i,o){<span class="cstat-no" title="statement not covered" >return e&lt;r||n&lt;r?e&gt;n?n+1:e+1:i===o?r:r+1}<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(e</span>,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e===r)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e.length&gt;r.length){var n=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >e</span>=r,r=n}<span class="cstat-no" title="statement not covered" ></span>f</span>or(var i=<span class="cstat-no" title="statement not covered" >e.length,</span>o=<span class="cstat-no" title="statement not covered" >r.length;</span>i&gt;0&amp;&amp;e.charCodeAt(i-1)===r.charCodeAt(o-1);)<span class="cstat-no" title="statement not covered" >i--,o--;<span class="cstat-no" title="statement not covered" >f</span></span>or(var s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;i&amp;&amp;e.charCodeAt(s)===r.charCodeAt(s);)<span class="cstat-no" title="statement not covered" >s++;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(i-=s,o-=s,i===0||o&lt;3)<span class="cstat-no" title="statement not covered" >return o;v</span></span>ar a=<span class="cstat-no" title="statement not covered" >0,f</span>,h,T,C,k,A,O,S,M,oe,H,L,z=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(f=0;f&lt;i;f++)<span class="cstat-no" title="statement not covered" >z.push(f+1),z.push(e.charCodeAt(s+f));<span class="cstat-no" title="statement not covered" >f</span></span>or(var Se=<span class="cstat-no" title="statement not covered" >z.length-1;a</span>&lt;o-3;)<span class="cstat-no" title="statement not covered" >for(M=r.charCodeAt(s+(h=a)),oe=r.charCodeAt(s+(T=a+1)),H=r.charCodeAt(s+(C=a+2)),L=r.charCodeAt(s+(k=a+3)),A=a+=4,f=0;f&lt;Se;f+=2)<span class="cstat-no" title="statement not covered" >O=z[f],S=z[f+1],h=t(O,h,T,M,S),T=t(h,T,C,oe,S),C=t(T,C,k,H,S),A=t(C,k,A,L,S),z[f]=A,k=C,C=T,T=h,h=O;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;a&lt;o;)<span class="cstat-no" title="statement not covered" >for(M=r.charCodeAt(s+(h=a)),A=++a,f=0;f&lt;Se;f+=2)<span class="cstat-no" title="statement not covered" >O=z[f],z[f]=A=t(O,h,A,M,z[f+1]),h=O;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn A}</span>}</span>()}</span>);v</span>ar ui=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>()}</span>);v</span>ar ci=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>()}</span>);v</span>ar _i=<span class="cstat-no" title="statement not covered" >Le(<span class="fstat-no" title="function not covered" >(o</span>P,qa)=&gt;{<span class="cstat-no" title="statement not covered" >qa.exports={name:"@prisma/engines-version",version:"6.8.0-43.2060c79ba17c6bb9f5823312b6f6b7f4a845738e",main:"index.js",types:"index.d.ts",license:"Apache-2.0",author:"Tim Suchanek &lt;suchanek@prisma.io&gt;",prisma:{enginesVersion:"2060c79ba17c6bb9f5823312b6f6b7f4a845738e"},repository:{type:"git",url:"https://github.com/prisma/engines-wrapper.git",directory:"packages/engines-version"},devDependencies:{"@types/node":"18.19.76",typescript:"4.9.5"},files:["index.js","index.d.ts"],scripts:{build:"tsc -d"}}}</span>);v</span>ar nr,Li=<span class="cstat-no" title="statement not covered" >ne(<span class="fstat-no" title="function not covered" >()=&gt;{"</span>use strict";<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >n</span>r=class{<span class="cstat-no" title="statement not covered" >events={};<span class="fstat-no" title="function not covered" >o</span>n(e</span>,r){<span class="cstat-no" title="statement not covered" >return this.events[e]||(this.events[e]=[]),this.events[e].push(r),this}<span class="fstat-no" title="function not covered" >e</span>mit(e</span>,...r){<span class="cstat-no" title="statement not covered" >return this.events[e]?(this.events[e].forEach(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >n</span>(...r)}</span>),!0):!1}</span>}}</span>);v</span>ar Jl=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>t(Jl,{DMMF:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >m</span>t,D</span>ebug:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >J</span>,D</span>ecimal:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >a</span>e,E</span>xtensions:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >C</span>r,M</span>etricsClient:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Y</span>e,P</span>rismaClientInitializationError:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >I</span>,P</span>rismaClientKnownRequestError:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >X</span>,P</span>rismaClientRustPanicError:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >w</span>e,P</span>rismaClientUnknownRequestError:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >j</span>,P</span>rismaClientValidationError:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >W</span>,P</span>ublic:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >R</span>r,S</span>ql:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Z</span>,c</span>reateParam:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >R</span>i,d</span>efineDmmfProperty:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >I</span>i,d</span>eserializeJsonResponse:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >$</span>e,d</span>eserializeRawResult:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >h</span>r,d</span>mmfToRuntimeDataModel:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>i,e</span>mpty:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >N</span>i,g</span>etPrismaClient:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >G</span>o,g</span>etRuntime:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >R</span>e,j</span>oin:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >F</span>i,m</span>akeStrictEnum:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >W</span>o,m</span>akeTypedQueryFactory:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >D</span>i,o</span>bjectEnumValues:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >W</span>t,r</span>aw:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >J</span>r,s</span>erializeJsonQuery:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>r,s</span>kip:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Z</span>t,s</span>qltag:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >G</span>r,w</span>arnEnvConflicts:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >v</span>oid 0,w</span>arnOnce:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >l</span>t}</span>);<span class="cstat-no" title="statement not covered" >m</span>odule.exports=ts(Jl);<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Cr=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>t(Cr,{defineExtension:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >E</span>n,g</span>etExtensionContext:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>n}</span>);<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >En(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t=="function"?t:<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.$extends(t)}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Pn(t</span>){<span class="cstat-no" title="statement not covered" >return t}</span>var Rr=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>t(Rr,{validator:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >v</span>n}</span>);<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >vn(.</span>..t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ar,Tn,Cn,Rn,An=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" >t</span>ypeof g&lt;"u"&amp;&amp;({FORCE_COLOR:Ar,NODE_DISABLE_COLORS:Tn,NO_COLOR:Cn,TERM:Rn}=g.env||{},An=g.stdout&amp;&amp;g.stdout.isTTY</span>);var ds=<span class="cstat-no" title="statement not covered" >{enabled:!Tn&amp;&amp;Cn==null&amp;&amp;Rn!=="dumb"&amp;&amp;(Ar!=null&amp;&amp;Ar!=="0"||An)};f</span>unction <span class="fstat-no" title="function not covered" >F(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >new RegExp(`\\x1b\\[${e}m`,"g"),n</span>=<span class="cstat-no" title="statement not covered" >`\x1B[${t}m`,</span>i=<span class="cstat-no" title="statement not covered" >`\x1B[${e}m`;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >function(o</span>){<span class="cstat-no" title="statement not covered" >return!ds.enabled||o==null?o:n+(~(""+o).indexOf(i)?o.replace(r,i+n):o)+i}</span>}</span>var ju=<span class="cstat-no" title="statement not covered" >F(0,0),_</span>t=<span class="cstat-no" title="statement not covered" >F(1,22),L</span>t=<span class="cstat-no" title="statement not covered" >F(2,22),Q</span>u=<span class="cstat-no" title="statement not covered" >F(3,23),S</span>n=<span class="cstat-no" title="statement not covered" >F(4,24),J</span>u=<span class="cstat-no" title="statement not covered" >F(7,27),G</span>u=<span class="cstat-no" title="statement not covered" >F(8,28),W</span>u=<span class="cstat-no" title="statement not covered" >F(9,29),K</span>u=<span class="cstat-no" title="statement not covered" >F(30,39),q</span>e=<span class="cstat-no" title="statement not covered" >F(31,39),k</span>n=<span class="cstat-no" title="statement not covered" >F(32,39),O</span>n=<span class="cstat-no" title="statement not covered" >F(33,39),M</span>n=<span class="cstat-no" title="statement not covered" >F(34,39),H</span>u=<span class="cstat-no" title="statement not covered" >F(35,39),I</span>n=<span class="cstat-no" title="statement not covered" >F(36,39),z</span>u=<span class="cstat-no" title="statement not covered" >F(37,39),D</span>n=<span class="cstat-no" title="statement not covered" >F(90,39),Y</span>u=<span class="cstat-no" title="statement not covered" >F(90,39),X</span>u=<span class="cstat-no" title="statement not covered" >F(40,49),Z</span>u=<span class="cstat-no" title="statement not covered" >F(41,49),e</span>c=<span class="cstat-no" title="statement not covered" >F(42,49),t</span>c=<span class="cstat-no" title="statement not covered" >F(43,49),r</span>c=<span class="cstat-no" title="statement not covered" >F(44,49),n</span>c=<span class="cstat-no" title="statement not covered" >F(45,49),i</span>c=<span class="cstat-no" title="statement not covered" >F(46,49),o</span>c=<span class="cstat-no" title="statement not covered" >F(47,49);<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar fs=<span class="cstat-no" title="statement not covered" >100,_</span>n=<span class="cstat-no" title="statement not covered" >["green","yellow","blue","magenta","cyan","red"],F</span>t=<span class="cstat-no" title="statement not covered" >[],</span>Ln=<span class="cstat-no" title="statement not covered" >Date.now(),g</span>s=<span class="cstat-no" title="statement not covered" >0,S</span>r=<span class="cstat-no" title="statement not covered" >typeof g&lt;"u"?g.env:{};<span class="cstat-no" title="statement not covered" >g</span>lobalThis.DEBUG??=Sr.DEBUG??"";<span class="cstat-no" title="statement not covered" >g</span>lobalThis.DEBUG_COLORS??=Sr.DEBUG_COLORS?Sr.DEBUG_COLORS==="true":!0;v</span>ar ot=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >enable(t</span>){<span class="cstat-no" title="statement not covered" >typeof t=="string"&amp;&amp;(globalThis.DEBUG=t)}</span>,<span class="fstat-no" title="function not covered" >disable(){l</span>et t=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG;<span class="cstat-no" title="statement not covered" ></span>return globalThis.DEBUG="",t}</span>,<span class="fstat-no" title="function not covered" >enabled(t</span>){let e=<span class="cstat-no" title="statement not covered" >globalThis.DEBUG.split(",").map(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >i</span>.replace(/[.+?^${}()|[\]\\]/g,"\\$&amp;")),r</span></span>=<span class="cstat-no" title="statement not covered" >e.some(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >i</span>===""||i[0]==="-"?!1:t.match(RegExp(i.split("*").join(".*")+"$"))),n</span></span>=<span class="cstat-no" title="statement not covered" >e.some(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >i</span>===""||i[0]!=="-"?!1:t.match(RegExp(i.slice(1).split("*").join(".*")+"$")));<span class="cstat-no" title="statement not covered" >r</span></span>eturn r&amp;&amp;!n}</span>,log:<span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;{let[e,r,...n]=<span class="cstat-no" title="statement not covered" >t;(<span class="cstat-no" title="statement not covered" >c</span>onsole.warn??console.log)(`${e} ${r}`,...n)}</span>,formatters:{}};f</span>unction <span class="fstat-no" title="function not covered" >ys(t</span>){let e=<span class="cstat-no" title="statement not covered" >{color:_n[gs++%_n.length],enabled:ot.enabled(t),namespace:t,log:ot.log,extend:<span class="fstat-no" title="function not covered" >()=&gt;{}</span>},r</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..n)=&gt;{let{enabled:i,namespace:o,color:s,log:a}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n.length!==0&amp;&amp;Ft.push([o,...n]),Ft.length&gt;fs&amp;&amp;Ft.shift(),ot.enabled(o)||i){let f=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >T=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof T=="string"?T:hs(T)),h</span></span>=<span class="cstat-no" title="statement not covered" >`+${Date.now()-Ln}ms`;<span class="cstat-no" title="statement not covered" ></span>Ln=Date.now(),a(o,...f,h)}</span>}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn new Proxy(r,{get:<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e[i],</span>set:<span class="fstat-no" title="function not covered" >(n</span>,i,o)=&gt;<span class="cstat-no" title="statement not covered" >e[i]=o}</span>)}</span>var J=<span class="cstat-no" title="statement not covered" >new Proxy(ys,{get:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >ot[e],</span>set:<span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;<span class="cstat-no" title="statement not covered" >ot[e]=r}</span>);f</span>unction <span class="fstat-no" title="function not covered" >hs(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >2)</span>{let r=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" >r</span>eturn JSON.stringify(t,<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >if(typeof i=="object"&amp;&amp;i!==null){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r.has(i))<span class="cstat-no" title="statement not covered" >return"[Circular *]";<span class="cstat-no" title="statement not covered" >r</span></span>.add(i)}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof i=="bigint")<span class="cstat-no" title="statement not covered" >return i.toString();<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn i}</span>,e)}</span>function <span class="fstat-no" title="function not covered" >Fn(){<span class="cstat-no" title="statement not covered" >F</span>t.length=0}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar kr=<span class="cstat-no" title="statement not covered" >["darwin","darwin-arm64","debian-openssl-1.0.x","debian-openssl-1.1.x","debian-openssl-3.0.x","rhel-openssl-1.0.x","rhel-openssl-1.1.x","rhel-openssl-3.0.x","linux-arm64-openssl-1.1.x","linux-arm64-openssl-1.0.x","linux-arm64-openssl-3.0.x","linux-arm-openssl-1.1.x","linux-arm-openssl-1.0.x","linux-arm-openssl-3.0.x","linux-musl","linux-musl-openssl-3.0.x","linux-musl-arm64-openssl-1.1.x","linux-musl-arm64-openssl-3.0.x","linux-nixos","linux-static-x64","linux-static-arm64","windows","freebsd11","freebsd12","freebsd13","freebsd14","freebsd15","openbsd","netbsd","arm"];<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar qs=<span class="cstat-no" title="statement not covered" >Qn(),O</span>r=<span class="cstat-no" title="statement not covered" >qs.version;<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ue(t</span>){let e=<span class="cstat-no" title="statement not covered" >Us();<span class="cstat-no" title="statement not covered" >r</span>eturn e||(t?.config.engineType==="library"?"library":t?.config.engineType==="binary"?"binary":t?.config.engineType==="client"?"client":Bs(t))}</span>function <span class="fstat-no" title="function not covered" >Us(){l</span>et t=<span class="cstat-no" title="statement not covered" >g.env.PRISMA_CLIENT_ENGINE_TYPE;<span class="cstat-no" title="statement not covered" ></span>return t==="library"?"library":t==="binary"?"binary":t==="client"?"client":void 0}</span>function <span class="fstat-no" title="function not covered" >Bs(t</span>){<span class="cstat-no" title="statement not covered" >return t?.previewFeatures.includes("queryCompiler")?"client":"library"}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Jn=<span class="cstat-no" title="statement not covered" >"prisma+postgres",G</span>n=<span class="cstat-no" title="statement not covered" >`${Jn}:`;</span>function <span class="fstat-no" title="function not covered" >Mr(t</span>){<span class="cstat-no" title="statement not covered" >return t?.toString().startsWith(`${Gn}//`)??!1}</span>var at=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>t(at,{error:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >j</span>s,i</span>nfo:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >V</span>s,l</span>og:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >$</span>s,q</span>uery:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >Q</span>s,s</span>hould:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >H</span>n,t</span>ags:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >s</span>t,w</span>arn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >I</span>r}</span>);<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar st=<span class="cstat-no" title="statement not covered" >{error:qe("prisma:error"),warn:On("prisma:warn"),info:In("prisma:info"),query:Mn("prisma:query")},H</span>n=<span class="cstat-no" title="statement not covered" >{warn:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>g.env.PRISMA_DISABLE_WARNINGS}</span>;f</span>unction <span class="fstat-no" title="function not covered" >$s(.</span>..t){<span class="cstat-no" title="statement not covered" >console.log(...t)}</span>function <span class="fstat-no" title="function not covered" >Ir(t</span>,...e){<span class="cstat-no" title="statement not covered" >Hn.warn()&amp;&amp;console.warn(`${st.warn} ${t}`,...e)}</span>function <span class="fstat-no" title="function not covered" >Vs(t</span>,...e){<span class="cstat-no" title="statement not covered" >console.info(`${st.info} ${t}`,...e)}</span>function <span class="fstat-no" title="function not covered" >js(t</span>,...e){<span class="cstat-no" title="statement not covered" >console.error(`${st.error} ${t}`,...e)}</span>function <span class="fstat-no" title="function not covered" >Qs(t</span>,...e){<span class="cstat-no" title="statement not covered" >console.log(`${st.query} ${t}`,...e)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >qt(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >throw new Error(`${e}. This should never happen. If you see this error, please, open an issue at https://pris.ly/prisma-prisma-bug-report`)}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >be(t</span>,e){<span class="cstat-no" title="statement not covered" >throw new Error(e)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Dr(t</span>,e){<span class="cstat-no" title="statement not covered" >return Object.prototype.hasOwnProperty.call(t,e)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Be(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.keys(t))<span class="cstat-no" title="statement not covered" >r[n]=e(t[n],n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >_r(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.length===0)<span class="cstat-no" title="statement not covered" >return;l</span></span>et r=<span class="cstat-no" title="statement not covered" >t[0];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;n</span>&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >e(r,t[n])&lt;0&amp;&amp;(r=t[n]</span></span>);<span class="cstat-no" title="statement not covered" >return r}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >te(t</span>,e){<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"name",{value:e,configurable:!0})}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ei=<span class="cstat-no" title="statement not covered" >new Set,l</span>t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,...r)=&gt;{<span class="cstat-no" title="statement not covered" >ei.has(t)||(ei.add(t),Ir(e,...r))}</span>;v</span>ar I=<span class="cstat-no" title="statement not covered" >class t extends Error{clientVersion;errorCode;retryable;<span class="fstat-no" title="function not covered" >constructor(e</span>,r,n){<span class="cstat-no" title="statement not covered" >super(e),this.name="PrismaClientInitializationError",this.clientVersion=r,this.errorCode=n,Error.captureStackTrace(t)}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientInitializationError"}</span>};<span class="cstat-no" title="statement not covered" >t</span>e(I,"PrismaClientInitializationError");<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar X=<span class="cstat-no" title="statement not covered" >class extends Error{code;meta;clientVersion;batchRequestIdx;<span class="fstat-no" title="function not covered" >constructor(e</span>,{code:r,clientVersion:n,meta:i,batchRequestIdx:o}){<span class="cstat-no" title="statement not covered" >super(e),this.name="PrismaClientKnownRequestError",this.code=r,this.clientVersion=n,this.meta=i,Object.defineProperty(this,"batchRequestIdx",{value:o,enumerable:!1,writable:!0})}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientKnownRequestError"}</span>};<span class="cstat-no" title="statement not covered" >t</span>e(X,"PrismaClientKnownRequestError");<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar we=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;<span class="fstat-no" title="function not covered" >constructor(e</span>,r){<span class="cstat-no" title="statement not covered" >super(e),this.name="PrismaClientRustPanicError",this.clientVersion=r}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientRustPanicError"}</span>};<span class="cstat-no" title="statement not covered" >t</span>e(we,"PrismaClientRustPanicError");<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar j=<span class="cstat-no" title="statement not covered" >class extends Error{clientVersion;batchRequestIdx;<span class="fstat-no" title="function not covered" >constructor(e</span>,{clientVersion:r,batchRequestIdx:n}){<span class="cstat-no" title="statement not covered" >super(e),this.name="PrismaClientUnknownRequestError",this.clientVersion=r,Object.defineProperty(this,"batchRequestIdx",{value:n,writable:!0,enumerable:!1})}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientUnknownRequestError"}</span>};<span class="cstat-no" title="statement not covered" >t</span>e(j,"PrismaClientUnknownRequestError");<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar W=<span class="cstat-no" title="statement not covered" >class extends Error{name="PrismaClientValidationError";clientVersion;<span class="fstat-no" title="function not covered" >constructor(e</span>,{clientVersion:r}){<span class="cstat-no" title="statement not covered" >super(e),this.clientVersion=r}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientValidationError"}</span>};<span class="cstat-no" title="statement not covered" >t</span>e(W,"PrismaClientValidationError");<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >$e(t</span>){<span class="cstat-no" title="statement not covered" >return t===null?t:Array.isArray(t)?t.map($e):typeof t=="object"?Gs(t)?Ws(t):typeof t=="bigint"||t instanceof Date||t instanceof Uint8Array||t instanceof ae?t:Be(t,$e):t}</span>function <span class="fstat-no" title="function not covered" >Gs(t</span>){<span class="cstat-no" title="statement not covered" >return t!==null&amp;&amp;typeof t=="object"&amp;&amp;typeof t.$type=="string"}</span>function <span class="fstat-no" title="function not covered" >Ws({</span>$type:t,value:e}){<span class="cstat-no" title="statement not covered" >switch(t){case"BigInt":<span class="cstat-no" title="statement not covered" >return BigInt(e);c</span>ase"Bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >b.from(e,"base64");<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(r,n,i)}</span>case"DateTime":<span class="cstat-no" title="statement not covered" >return new Date(e);c</span>ase"Decimal":<span class="cstat-no" title="statement not covered" >return new ae(e);c</span>ase"Json":<span class="cstat-no" title="statement not covered" >return JSON.parse(e);d</span>efault:<span class="cstat-no" title="statement not covered" >be(e,"Unknown tagged value")}</span>}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar pe=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >_map=new Map;<span class="fstat-no" title="function not covered" >g</span>et(e</span>){<span class="cstat-no" title="statement not covered" >return this._map.get(e)?.value}<span class="fstat-no" title="function not covered" ></span>set(e</span>,r){<span class="cstat-no" title="statement not covered" >this._map.set(e,{value:r})}<span class="fstat-no" title="function not covered" ></span>getOrCreate(e</span>,r){let n=<span class="cstat-no" title="statement not covered" >this._map.get(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n)<span class="cstat-no" title="statement not covered" >return n.value;l</span></span>et i=<span class="cstat-no" title="statement not covered" >r();<span class="cstat-no" title="statement not covered" >r</span>eturn this.set(e,i),i}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ve(t</span>){<span class="cstat-no" title="statement not covered" >return t.substring(0,1).toLowerCase()+t.substring(1)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ri(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let n of t){let i=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>r[i]=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ut(t</span>){let e;<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >get(){<span class="cstat-no" title="statement not covered" >r</span>eturn e||(e={value:t()}),e.value}}</span>}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ni(t</span>){<span class="cstat-no" title="statement not covered" >return{models:Lr(t.models),enums:Lr(t.enums),types:Lr(t.types)}}</span>function <span class="fstat-no" title="function not covered" >Lr(t</span>){let e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let{name:r,...n}of t)<span class="cstat-no" title="statement not covered" >e[r]=n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ve(t</span>){<span class="cstat-no" title="statement not covered" >return t instanceof Date||Object.prototype.toString.call(t)==="[object Date]"}</span>function <span class="fstat-no" title="function not covered" >Ut(t</span>){<span class="cstat-no" title="statement not covered" >return t.toString()!=="Invalid Date"}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >je(t</span>){<span class="cstat-no" title="statement not covered" >return v.isDecimal(t)?!0:t!==null&amp;&amp;typeof t=="object"&amp;&amp;typeof t.s=="number"&amp;&amp;typeof t.e=="number"&amp;&amp;typeof t.toFixed=="function"&amp;&amp;Array.isArray(t.d)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar mt=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>t(mt,{ModelAction:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >c</span>t,d</span>atamodelEnumToSchemaEnum:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >K</span>s}</span>);<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ks(t</span>){<span class="cstat-no" title="statement not covered" >return{name:t.name,values:t.values.map(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.name)</span>}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ct=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >L=&gt;(<span class="cstat-no" title="statement not covered" >L</span>.findUnique="findUnique",L.findUniqueOrThrow="findUniqueOrThrow",L.findFirst="findFirst",L.findFirstOrThrow="findFirstOrThrow",L.findMany="findMany",L.create="create",L.createMany="createMany",L.createManyAndReturn="createManyAndReturn",L.update="update",L.updateMany="updateMany",L.updateManyAndReturn="updateManyAndReturn",L.upsert="upsert",L.delete="delete",L.deleteMany="deleteMany",L.groupBy="groupBy",L.count="count",L.aggregate="aggregate",L.findRaw="findRaw",L.aggregateRaw="aggregateRaw",L)</span>)(ct||{});v</span>ar Hs=<span class="cstat-no" title="statement not covered" >nt(Kn());v</span>ar zs=<span class="cstat-no" title="statement not covered" >{red:qe,gray:Dn,dim:Lt,bold:_t,underline:Sn,highlightSource:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.highlight()}</span>,Y</span>s=<span class="cstat-no" title="statement not covered" >{red:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>,g</span>ray:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>,d</span>im:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>,b</span>old:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>,u</span>nderline:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>,h</span>ighlightSource:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>}</span>;f</span>unction <span class="fstat-no" title="function not covered" >Xs({</span>message:t,originalMethod:e,isPanic:r,callArguments:n}){<span class="cstat-no" title="statement not covered" >return{functionName:`prisma.${e}()`,message:t,isPanic:r??!1,callArguments:n}}</span>function <span class="fstat-no" title="function not covered" >Zs({</span>functionName:t,location:e,message:r,isPanic:n,contextLines:i,callArguments:o},s){let a=<span class="cstat-no" title="statement not covered" >[""],f</span>=<span class="cstat-no" title="statement not covered" >e?" in":":";<span class="cstat-no" title="statement not covered" >i</span>f(n?(a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)),a.push(s.red(`It occurred in the ${s.bold(`\`${t}\``)} invocation${f}`))):a.push(s.red(`Invalid ${s.bold(`\`${t}\``)} invocation${f}`)),e&amp;&amp;a.push(s.underline(ea(e))),i){<span class="cstat-no" title="statement not covered" >a.push("");l</span>et h=<span class="cstat-no" title="statement not covered" >[i.toString()];<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;(h.push(o),h.push(s.dim(")"))),a.push(h.join("")),o&amp;&amp;a.push("")}</span>else <span class="cstat-no" title="statement not covered" >a.push(""),o&amp;&amp;a.push(o),a.push("");<span class="cstat-no" title="statement not covered" >r</span></span>eturn a.push(r),a.join(`</span>
`)}function <span class="fstat-no" title="function not covered" >ea(t</span>){let e=<span class="cstat-no" title="statement not covered" >[t.fileName];<span class="cstat-no" title="statement not covered" >r</span>eturn t.lineNumber&amp;&amp;e.push(String(t.lineNumber)),t.columnNumber&amp;&amp;e.push(String(t.columnNumber)),e.join(":")}</span>function <span class="fstat-no" title="function not covered" >Bt(t</span>){let e=<span class="cstat-no" title="statement not covered" >t.showColors?zs:Ys,r</span>;<span class="cstat-no" title="statement not covered" >return typeof $getTemplateParameters&lt;"u"?r=$getTemplateParameters(t,e):r=Xs(t),Zs(r,e)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar pi=<span class="cstat-no" title="statement not covered" >nt(Fr());<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ai(t</span>,e,r){let n=<span class="cstat-no" title="statement not covered" >li(t),i</span>=<span class="cstat-no" title="statement not covered" >ta(n),o</span>=<span class="cstat-no" title="statement not covered" >na(i);<span class="cstat-no" title="statement not covered" >o</span>?$t(o,e,r):e.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Unknown error")}</span></span>function <span class="fstat-no" title="function not covered" >li(t</span>){<span class="cstat-no" title="statement not covered" >return t.errors.flatMap(<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.kind==="Union"?li(e):[e])}</span></span>function <span class="fstat-no" title="function not covered" >ta(t</span>){let e=<span class="cstat-no" title="statement not covered" >new Map,r</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n of t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.kind!=="InvalidArgumentType"){<span class="cstat-no" title="statement not covered" >r.push(n);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >`${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`,</span>o=<span class="cstat-no" title="statement not covered" >e.get(i);<span class="cstat-no" title="statement not covered" >o</span>?e.set(i,{...n,argument:{...n.argument,typeNames:ra(o.argument.typeNames,n.argument.typeNames)}}):e.set(i,n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.push(...e.values()),r}</span>function <span class="fstat-no" title="function not covered" >ra(t</span>,e){<span class="cstat-no" title="statement not covered" >return[...new Set(t.concat(e))]}f</span>unction <span class="fstat-no" title="function not covered" >na(t</span>){<span class="cstat-no" title="statement not covered" >return _r(t,<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >oi(e),i</span>=<span class="cstat-no" title="statement not covered" >oi(r);<span class="cstat-no" title="statement not covered" >r</span>eturn n!==i?n-i:si(e)-si(r)}</span>)}</span>function <span class="fstat-no" title="function not covered" >oi(t</span>){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >r</span>eturn Array.isArray(t.selectionPath)&amp;&amp;(e+=t.selectionPath.length),Array.isArray(t.argumentPath)&amp;&amp;(e+=t.argumentPath.length),e}</span>function <span class="fstat-no" title="function not covered" >si(t</span>){<span class="cstat-no" title="statement not covered" >switch(t.kind){case"InvalidArgumentValue":case"ValueTooLarge":<span class="cstat-no" title="statement not covered" >return 20;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >return 10;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >return-10;d</span>efault:<span class="cstat-no" title="statement not covered" >return 0}</span>}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar re=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>,r){<span class="cstat-no" title="statement not covered" >this.name=e;<span class="cstat-no" title="statement not covered" >t</span>his.value=r}<span class="cstat-no" title="statement not covered" ></span>isRequired=!1;<span class="fstat-no" title="function not covered" >m</span>akeRequired(){<span class="cstat-no" title="statement not covered" ></span>return this.isRequired=!0,this}<span class="fstat-no" title="function not covered" >w</span>rite(e</span>){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >e.context;<span class="cstat-no" title="statement not covered" ></span>e.addMarginSymbol(r(this.isRequired?"+":"?")),e.write(r(this.name)),this.isRequired||e.write(r("?")),e.write(r(": ")),typeof this.value=="string"?e.write(r(this.value)):e.write(this.value)}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >c</span>i();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Qe=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>r){<span class="cstat-no" title="statement not covered" >this.context=r;<span class="cstat-no" title="statement not covered" >t</span>his.currentIndent=e}<span class="cstat-no" title="statement not covered" ></span>lines=[];<span class="cstat-no" title="statement not covered" >c</span>urrentLine="";<span class="cstat-no" title="statement not covered" >c</span>urrentIndent=0;marginSymbol;afterNextNewLineCallback;<span class="fstat-no" title="function not covered" >w</span>rite(e</span>){<span class="cstat-no" title="statement not covered" >return typeof e=="string"?this.currentLine+=e:e.write(this),this}<span class="fstat-no" title="function not covered" >w</span>riteJoined(e</span>,r,n=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >o.write(i))</span></span>{let i=<span class="cstat-no" title="statement not covered" >r.length-1;<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >0;o</span>&lt;r.length;o++)<span class="cstat-no" title="statement not covered" >n(r[o],this),o!==i&amp;&amp;this.write(e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn this}<span class="fstat-no" title="function not covered" >w</span>riteLine(e</span>){<span class="cstat-no" title="statement not covered" >return this.write(e).newLine()}<span class="fstat-no" title="function not covered" ></span>newLine(){<span class="cstat-no" title="statement not covered" ></span>this.lines.push(this.indentedCurrentLine()),this.currentLine="",this.marginSymbol=void 0;l</span>et e=<span class="cstat-no" title="statement not covered" >this.afterNextNewLineCallback;<span class="cstat-no" title="statement not covered" ></span>return this.afterNextNewLineCallback=void 0,e?.(),this}<span class="fstat-no" title="function not covered" >w</span>ithIndent(e</span>){<span class="cstat-no" title="statement not covered" >return this.indent(),e(this),this.unindent(),this}<span class="fstat-no" title="function not covered" >a</span>fterNextNewline(e</span>){<span class="cstat-no" title="statement not covered" >return this.afterNextNewLineCallback=e,this}<span class="fstat-no" title="function not covered" >i</span>ndent(){<span class="cstat-no" title="statement not covered" ></span>return this.currentIndent++,this}<span class="fstat-no" title="function not covered" >u</span>nindent(){<span class="cstat-no" title="statement not covered" ></span>return this.currentIndent&gt;0&amp;&amp;this.currentIndent--,this}<span class="fstat-no" title="function not covered" >a</span>ddMarginSymbol(e</span>){<span class="cstat-no" title="statement not covered" >return this.marginSymbol=e,this}<span class="fstat-no" title="function not covered" >t</span>oString(){<span class="cstat-no" title="statement not covered" ></span>return this.lines.concat(this.indentedCurrentLine()).join(`</span></span>
`)}<span class="fstat-no" title="function not covered" >getCurrentLineLength(){<span class="cstat-no" title="statement not covered" ></span>return this.currentLine.length}<span class="fstat-no" title="function not covered" >i</span>ndentedCurrentLine(){</span>let e=<span class="cstat-no" title="statement not covered" >this.currentLine.padStart(this.currentLine.length+2*this.currentIndent);<span class="cstat-no" title="statement not covered" >r</span>eturn this.marginSymbol?this.marginSymbol+e.slice(1):e}</span>};<span class="cstat-no" title="statement not covered" >ui();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Vt=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.value=e}<span class="fstat-no" title="function not covered" ></span>write(e</span>){<span class="cstat-no" title="statement not covered" >e.write(this.value)}<span class="fstat-no" title="function not covered" ></span>markAsError(){<span class="cstat-no" title="statement not covered" ></span>this.value.markAsError()}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar jt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>,Q</span></span>t=<span class="cstat-no" title="statement not covered" >{bold:jt,red:jt,green:jt,dim:jt,enabled:!1},m</span>i=<span class="cstat-no" title="statement not covered" >{bold:_t,red:qe,green:kn,dim:Lt,enabled:!0},J</span>e=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >write(t</span>){<span class="cstat-no" title="statement not covered" >t.writeLine(",")}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar de=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.contents=e}<span class="cstat-no" title="statement not covered" ></span>isUnderlined=!1;<span class="cstat-no" title="statement not covered" >c</span>olor=<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>;<span class="fstat-no" title="function not covered" >u</span></span>nderline(){<span class="cstat-no" title="statement not covered" ></span>return this.isUnderlined=!0,this}<span class="fstat-no" title="function not covered" >s</span>etColor(e</span>){<span class="cstat-no" title="statement not covered" >return this.color=e,this}<span class="fstat-no" title="function not covered" >w</span>rite(e</span>){let r=<span class="cstat-no" title="statement not covered" >e.getCurrentLineLength();<span class="cstat-no" title="statement not covered" >e</span>.write(this.color(this.contents)),this.isUnderlined&amp;&amp;e.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)))}</span>)}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Te=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >hasError=!1;<span class="fstat-no" title="function not covered" >m</span>arkAsError(){<span class="cstat-no" title="statement not covered" ></span>return this.hasError=!0,this}}</span>;v</span>ar Ge=<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" >class extends Te{items=[];<span class="fstat-no" title="function not covered" >a</span>ddItem(e</span>){<span class="cstat-no" title="statement not covered" >return this.items.push(new Vt(e)),this}<span class="fstat-no" title="function not covered" >g</span>etField(e</span>){<span class="cstat-no" title="statement not covered" >return this.items[e]}<span class="fstat-no" title="function not covered" >g</span>etPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.items.length===0?2:Math.max(...this.items.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.value.getPrintWidth()))+2</span>}<span class="fstat-no" title="function not covered" ></span>write(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(this.items.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(e);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithItems(e)}<span class="fstat-no" title="function not covered" ></span>writeEmpty(e</span>){let r=<span class="cstat-no" title="statement not covered" >new de("[]");<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;r.setColor(e.context.colors.red).underline(),e.write(r)}<span class="fstat-no" title="function not covered" ></span>writeWithItems(e</span>){let{colors:r}=<span class="cstat-no" title="statement not covered" >e.context;<span class="cstat-no" title="statement not covered" ></span>e.writeLine("[").withIndent(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>.writeJoined(Je,this.items).newLine()).w</span>rite("]"),this.hasError&amp;&amp;e.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.writeLine(r.red("~".repeat(this.getPrintWidth())))}</span>)}<span class="fstat-no" title="function not covered" ></span>asObject(){</span>}};v</span>ar We=<span class="cstat-no" title="statement not covered" ><span class="cstat-no" title="statement not covered" >class t extends Te{fields={};suggestions=[];<span class="fstat-no" title="function not covered" >a</span>ddField(e</span>){<span class="cstat-no" title="statement not covered" >this.fields[e.name]=e}<span class="fstat-no" title="function not covered" ></span>addSuggestion(e</span>){<span class="cstat-no" title="statement not covered" >this.suggestions.push(e)}<span class="fstat-no" title="function not covered" ></span>getField(e</span>){<span class="cstat-no" title="statement not covered" >return this.fields[e]}<span class="fstat-no" title="function not covered" >g</span>etDeepField(e</span>){let[r,...n]=<span class="cstat-no" title="statement not covered" >e,i</span>=<span class="cstat-no" title="statement not covered" >this.getField(r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!i)<span class="cstat-no" title="statement not covered" >return;l</span></span>et o=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" >f</span>or(let s of n){let a;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o.value instanceof t?a=o.value.getField(s):o.value instanceof Ge&amp;&amp;(a=o.value.getField(Number(s))),!a)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >o</span></span>=a}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}<span class="fstat-no" title="function not covered" ></span>getDeepFieldValue(e</span>){<span class="cstat-no" title="statement not covered" >return e.length===0?this:this.getDeepField(e)?.value}<span class="fstat-no" title="function not covered" ></span>hasField(e</span>){<span class="cstat-no" title="statement not covered" >return!!this.getField(e)}<span class="fstat-no" title="function not covered" ></span>removeAllFields(){<span class="cstat-no" title="statement not covered" ></span>this.fields={}}<span class="fstat-no" title="function not covered" ></span>removeField(e</span>){<span class="cstat-no" title="statement not covered" >delete this.fields[e]}<span class="fstat-no" title="function not covered" >g</span>etFields(){<span class="cstat-no" title="statement not covered" ></span>return this.fields}<span class="fstat-no" title="function not covered" >i</span>sEmpty(){<span class="cstat-no" title="statement not covered" ></span>return Object.keys(this.fields).length===0}<span class="fstat-no" title="function not covered" ></span>getFieldValue(e</span>){<span class="cstat-no" title="statement not covered" >return this.getField(e)?.value}<span class="fstat-no" title="function not covered" ></span>getDeepSubSelectionValue(e</span>){let r=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(let n of e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!(r instanceof t))<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >r.getSubSelectionValue(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="fstat-no" title="function not covered" ></span>getDeepSelectionParent(e</span>){let r=<span class="cstat-no" title="statement not covered" >this.getSelectionParent();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!r)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >f</span>or(let i of e){let o=<span class="cstat-no" title="statement not covered" >n.value.getFieldValue(i);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o||!(o instanceof t))<span class="cstat-no" title="statement not covered" >return;l</span></span>et s=<span class="cstat-no" title="statement not covered" >o.getSelectionParent();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>=s}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="fstat-no" title="function not covered" ></span>getSelectionParent(){</span>let e=<span class="cstat-no" title="statement not covered" >this.getField("select")?.value.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(e)<span class="cstat-no" title="statement not covered" >return{kind:"select",value:e};l</span></span>et r=<span class="cstat-no" title="statement not covered" >this.getField("include")?.value.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r)<span class="cstat-no" title="statement not covered" >return{kind:"include",value:r}}<span class="fstat-no" title="function not covered" ></span></span>getSubSelectionValue(e</span>){<span class="cstat-no" title="statement not covered" >return this.getSelectionParent()?.value.fields[e].value}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){</span>let e=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" >r</span>eturn e.length==0?2:Math.max(...e.map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.getPrintWidth()))+2</span>}<span class="fstat-no" title="function not covered" ></span>write(e</span>){let r=<span class="cstat-no" title="statement not covered" >Object.values(this.fields);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r.length===0&amp;&amp;this.suggestions.length===0){<span class="cstat-no" title="statement not covered" >this.writeEmpty(e);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>t</span>his.writeWithContents(e,r)}<span class="fstat-no" title="function not covered" ></span>asObject(){<span class="cstat-no" title="statement not covered" ></span>return this}<span class="fstat-no" title="function not covered" >w</span>riteEmpty(e</span>){let r=<span class="cstat-no" title="statement not covered" >new de("{}");<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;r.setColor(e.context.colors.red).underline(),e.write(r)}<span class="fstat-no" title="function not covered" ></span>writeWithContents(e</span>,r){<span class="cstat-no" title="statement not covered" >e.writeLine("{").withIndent(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.writeJoined(Je,[...r,...this.suggestions]).newLine()}</span>),e.write("}"),this.hasError&amp;&amp;e.afterNextNewline(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.writeLine(e.context.colors.red("~".repeat(this.getPrintWidth())))}</span>)}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar G=<span class="cstat-no" title="statement not covered" >class extends Te{<span class="fstat-no" title="function not covered" >constructor(r</span>){<span class="cstat-no" title="statement not covered" >super();<span class="cstat-no" title="statement not covered" >t</span>his.text=r}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.text.length}<span class="fstat-no" title="function not covered" >w</span>rite(r</span>){let n=<span class="cstat-no" title="statement not covered" >new de(this.text);<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;n.underline().setColor(r.context.colors.red),r.write(n)}<span class="fstat-no" title="function not covered" ></span>asObject(){</span>}};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar pt=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >fields=[];<span class="fstat-no" title="function not covered" >a</span>ddField(e</span>,r){<span class="cstat-no" title="statement not covered" >return this.fields.push({<span class="fstat-no" title="function not covered" >write(n</span>){let{green:i,dim:o}=<span class="cstat-no" title="statement not covered" >n.context.colors;<span class="cstat-no" title="statement not covered" ></span>n.write(i(o(`${e}: ${r}`))).addMarginSymbol(i(o("+")))}</span>}),this}<span class="fstat-no" title="function not covered" >w</span>rite(e</span>){let{colors:{green:r}}=<span class="cstat-no" title="statement not covered" >e.context;<span class="cstat-no" title="statement not covered" ></span>e.writeLine(r("{")).withIndent(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.writeJoined(Je,this.fields).newLine()}</span>).write(r("}")).addMarginSymbol(r("+"))}</span>};f</span>unction <span class="fstat-no" title="function not covered" >$t(t</span>,e,r){<span class="cstat-no" title="statement not covered" >switch(t.kind){case"MutuallyExclusiveFields":<span class="cstat-no" title="statement not covered" >ia(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"IncludeOnScalar":<span class="cstat-no" title="statement not covered" >oa(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"EmptySelection":<span class="cstat-no" title="statement not covered" >sa(t,e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownSelectionField":<span class="cstat-no" title="statement not covered" >ca(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidSelectionValue":<span class="cstat-no" title="statement not covered" >ma(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownArgument":<span class="cstat-no" title="statement not covered" >pa(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownInputField":<span class="cstat-no" title="statement not covered" >da(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RequiredArgumentMissing":<span class="cstat-no" title="statement not covered" >fa(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentType":<span class="cstat-no" title="statement not covered" >ga(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"InvalidArgumentValue":<span class="cstat-no" title="statement not covered" >ya(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"ValueTooLarge":<span class="cstat-no" title="statement not covered" >ha(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"SomeFieldsMissing":<span class="cstat-no" title="statement not covered" >ba(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"TooManyFieldsGiven":<span class="cstat-no" title="statement not covered" >wa(t,e);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"Union":<span class="cstat-no" title="statement not covered" >ai(t,e,r);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("not implemented: "+t.kind)}</span>}</span>function <span class="fstat-no" title="function not covered" >ia(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >r</span>&amp;&amp;(r.getField(t.firstField)?.markAsError(),r.getField(t.secondField)?.markAsError()),e.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>Please ${n.bold("either")} use ${n.green(`\`${t.firstField}\``)} or ${n.green(`\`${t.secondField}\``)}, but ${n.red("not both")} at the same time.`)</span>}</span>function <span class="fstat-no" title="function not covered" >oa(t</span>,e){let[r,n]=<span class="cstat-no" title="statement not covered" >dt(t.selectionPath),i</span>=<span class="cstat-no" title="statement not covered" >t.outputType,</span>o=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSelectionParent(r)?.value;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o&amp;&amp;(o.getField(n)?.markAsError(),i))<span class="cstat-no" title="statement not covered" >for(let s of i.fields)<span class="cstat-no" title="statement not covered" >s.isRelation&amp;&amp;o.addSuggestion(new re(s.name,"true"));<span class="cstat-no" title="statement not covered" >e</span></span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >s=&gt;{l</span>et a=<span class="cstat-no" title="statement not covered" >`Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;<span class="cstat-no" title="statement not covered" ></span>return i?a+=` on model ${s.bold(i.name)}. ${ft(s)}`:a+=".",a+=`</span></span>
Note that ${s.bold("include")} statements only accept relation fields.`,a})}function <span class="fstat-no" title="function not covered" >sa(t</span>,e,r){let n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >n.getField("omit")?.value.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i){<span class="cstat-no" title="statement not covered" >aa(t,e,i);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(n.hasField("select")){<span class="cstat-no" title="statement not covered" >la(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn}</span>}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(r?.[ve(t.outputType.name)]){<span class="cstat-no" title="statement not covered" >ua(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>e</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Unknown field at "${t.selectionPath.join(".")} selection"`)</span>}</span>function <span class="fstat-no" title="function not covered" >aa(t</span>,e,r){<span class="cstat-no" title="statement not covered" >r.removeAllFields();<span class="cstat-no" title="statement not covered" >f</span>or(let n of t.outputType.fields)<span class="cstat-no" title="statement not covered" >r.addSuggestion(new re(n.name,"false"));<span class="cstat-no" title="statement not covered" >e</span></span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>The ${n.red("omit")} statement includes every field of the model ${n.bold(t.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >la(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.outputType,</span>n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSelectionParent(t.selectionPath)?.value,i</span>=<span class="cstat-no" title="statement not covered" >n?.isEmpty()??!1;<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(n.removeAllFields(),gi(n,r)),e.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >i</span>?`The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${ft(o)}`:`The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`)</span>}</span>function <span class="fstat-no" title="function not covered" >ua(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >new pt;<span class="cstat-no" title="statement not covered" >f</span>or(let i of t.outputType.fields)<span class="cstat-no" title="statement not covered" >i.isRelation||r.addField(i.name,"false");l</span></span>et n=<span class="cstat-no" title="statement not covered" >new re("omit",r).makeRequired();<span class="cstat-no" title="statement not covered" >i</span>f(t.selectionPath.length===0)<span class="cstat-no" title="statement not covered" >e.arguments.addSuggestion(n);else{</span>let[i,o]=<span class="cstat-no" title="statement not covered" >dt(t.selectionPath),a</span>=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a){let f=<span class="cstat-no" title="statement not covered" >a?.value.asObject()??new We;<span class="cstat-no" title="statement not covered" >f</span>.addSuggestion(n),a.value=f}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >`</span>The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(t.outputType.name)}. At least one field must be included in the result`)</span>}</span>function <span class="fstat-no" title="function not covered" >ca(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >yi(t.selectionPath,e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r.parentKind!=="unknown"){<span class="cstat-no" title="statement not covered" >r.field.markAsError();l</span>et n=<span class="cstat-no" title="statement not covered" >r.parent;<span class="cstat-no" title="statement not covered" ></span>switch(r.parentKind){case"select":<span class="cstat-no" title="statement not covered" >gi(n,t.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"include":<span class="cstat-no" title="statement not covered" >xa(n,t.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"omit":<span class="cstat-no" title="statement not covered" >Ea(n,t.outputType);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;{l</span>et i=<span class="cstat-no" title="statement not covered" >[`Unknown field ${n.red(`\`${r.fieldName}\``)}`];<span class="cstat-no" title="statement not covered" >r</span>eturn r.parentKind!=="unknown"&amp;&amp;i.push(`for ${n.bold(r.parentKind)} statement`),i.push(`on model ${n.bold(`\`${t.outputType.name}\``)}.`),i.push(ft(n)),i.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >ma(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >yi(t.selectionPath,e);<span class="cstat-no" title="statement not covered" >r</span>.parentKind!=="unknown"&amp;&amp;r.field.value.markAsError(),e.addErrorMessage(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >`</span>Invalid value for selection field \`${n.red(r.fieldName)}\`: ${t.underlyingError}`)</span>}</span>function <span class="fstat-no" title="function not covered" >pa(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.argumentPath[0],</span>n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;(n.getField(r)?.markAsError(),Pa(n,t.arguments)),e.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >d</span>i(i,r,t.arguments.map(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >o</span>.name)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >da(t</span>,e){let[r,n]=<span class="cstat-no" title="statement not covered" >dt(t.argumentPath),i</span>=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i){<span class="cstat-no" title="statement not covered" >i.getDeepField(t.argumentPath)?.markAsError();l</span>et o=<span class="cstat-no" title="statement not covered" >i.getDeepFieldValue(r)?.asObject();<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;hi(o,t.inputType)}<span class="cstat-no" title="statement not covered" ></span>e</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >d</span>i(o,n,t.inputType.fields.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >s</span>.name)</span>))}</span></span>function <span class="fstat-no" title="function not covered" >di(t</span>,e,r){let n=<span class="cstat-no" title="statement not covered" >[`Unknown argument \`${t.red(e)}\`.`],i</span>=<span class="cstat-no" title="statement not covered" >Ta(e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;n.push(`Did you mean \`${t.green(i)}\`?`),r.length&gt;0&amp;&amp;n.push(ft(t)),n.join(" ")}</span>function <span class="fstat-no" title="function not covered" >fa(t</span>,e){let r;<span class="cstat-no" title="statement not covered" >e.addErrorMessage(<span class="fstat-no" title="function not covered" >f=&gt;<span class="cstat-no" title="statement not covered" >r</span>?.value instanceof G&amp;&amp;r.value.text==="null"?`Argument \`${f.green(o)}\` must not be ${f.red("null")}.`:`Argument \`${f.green(o)}\` is missing.`)</span>;l</span>et n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!n)<span class="cstat-no" title="statement not covered" >return;l</span></span>et[i,o]=<span class="cstat-no" title="statement not covered" >dt(t.argumentPath),s</span>=<span class="cstat-no" title="statement not covered" >new pt,a</span>=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(i)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a)<span class="cstat-no" title="statement not covered" >if(r=a.getField(o),r&amp;&amp;a.removeField(o),t.inputTypes.length===1&amp;&amp;t.inputTypes[0].kind==="object"){<span class="cstat-no" title="statement not covered" >for(let f of t.inputTypes[0].fields)<span class="cstat-no" title="statement not covered" >s.addField(f.name,f.typeNames.join(" | "));<span class="cstat-no" title="statement not covered" >a</span></span>.addSuggestion(new re(o,s).makeRequired())}</span>else{let f=<span class="cstat-no" title="statement not covered" >t.inputTypes.map(fi).join(" | ");<span class="cstat-no" title="statement not covered" >a</span>.addSuggestion(new re(o,f).makeRequired())}</span>}</span></span>function <span class="fstat-no" title="function not covered" >fi(t</span>){<span class="cstat-no" title="statement not covered" >return t.kind==="list"?`${fi(t.elementType)}[]`:t.name}f</span>unction <span class="fstat-no" title="function not covered" >ga(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;n.getDeepFieldValue(t.argumentPath)?.markAsError(),e.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >Jt("or",t.argument.typeNames.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >i</span>.green(s)));<span class="cstat-no" title="statement not covered" >r</span></span>eturn`Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(t.inferredType)}.`})}</span></span>function <span class="fstat-no" title="function not covered" >ya(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" >n</span>&amp;&amp;n.getDeepFieldValue(t.argumentPath)?.markAsError(),e.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >[`Invalid value for argument \`${i.bold(r)}\``];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t.underlyingError&amp;&amp;o.push(`: ${t.underlyingError}`),o.push("."),t.argument.typeNames.length&gt;0){let s=<span class="cstat-no" title="statement not covered" >Jt("or",t.argument.typeNames.map(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >i</span>.green(a)));<span class="cstat-no" title="statement not covered" >o</span></span>.push(` Expected ${s}.`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o.join("")}</span>)}</span>function <span class="fstat-no" title="function not covered" >ha(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.argument.name,</span>n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject(),i</span>;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n){let s=<span class="cstat-no" title="statement not covered" >n.getDeepField(t.argumentPath)?.value;<span class="cstat-no" title="statement not covered" >s</span>?.markAsError(),s instanceof G&amp;&amp;(i=s.text</span>)}<span class="cstat-no" title="statement not covered" >e</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;{l</span>et s=<span class="cstat-no" title="statement not covered" >["Unable to fit value"];<span class="cstat-no" title="statement not covered" >r</span>eturn i&amp;&amp;s.push(o.red(i)),s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >ba(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.argumentPath[t.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n){let i=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(t.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" >i</span>&amp;&amp;hi(i,t.inputType)}<span class="cstat-no" title="statement not covered" ></span>e</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >[`Argument \`${i.bold(r)}\` of type ${i.bold(t.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" >r</span>eturn t.constraints.minFieldCount===1?t.constraints.requiredFields?o.push(`${i.green("at least one of")} ${Jt("or",t.constraints.requiredFields.map(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >`</span>\`${i.bold(s)}\``)</span>)} arguments.`):o.push(`${i.green("at least one")} argument.`):o.push(`${i.green(`at least ${t.constraints.minFieldCount}`)} arguments.`),o.push(ft(i)),o.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >wa(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.argumentPath[t.argumentPath.length-1],</span>n=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(t.selectionPath)?.asObject(),i</span>=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(n){let o=<span class="cstat-no" title="statement not covered" >n.getDeepFieldValue(t.argumentPath)?.asObject();<span class="cstat-no" title="statement not covered" >o</span>&amp;&amp;(o.markAsError(),i=Object.keys(o.getFields()))}<span class="cstat-no" title="statement not covered" ></span>e</span>.addErrorMessage(<span class="fstat-no" title="function not covered" >o=&gt;{l</span>et s=<span class="cstat-no" title="statement not covered" >[`Argument \`${o.bold(r)}\` of type ${o.bold(t.inputType.name)} needs`];<span class="cstat-no" title="statement not covered" >r</span>eturn t.constraints.minFieldCount===1&amp;&amp;t.constraints.maxFieldCount==1?s.push(`${o.green("exactly one")} argument,`):t.constraints.maxFieldCount==1?s.push(`${o.green("at most one")} argument,`):s.push(`${o.green(`at most ${t.constraints.maxFieldCount}`)} arguments,`),s.push(`but you provided ${Jt("and",i.map(<span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" >o</span>.red(a)))}.</span> Please choose`),t.constraints.maxFieldCount===1?s.push("one."):s.push(`${t.constraints.maxFieldCount}.`),s.join(" ")}</span>)}</span>function <span class="fstat-no" title="function not covered" >gi(t</span>,e){<span class="cstat-no" title="statement not covered" >for(let r of e.fields)<span class="cstat-no" title="statement not covered" >t.hasField(r.name)||t.addSuggestion(new re(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >xa(t</span>,e){<span class="cstat-no" title="statement not covered" >for(let r of e.fields)<span class="cstat-no" title="statement not covered" >r.isRelation&amp;&amp;!t.hasField(r.name)&amp;&amp;t.addSuggestion(new re(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Ea(t</span>,e){<span class="cstat-no" title="statement not covered" >for(let r of e.fields)<span class="cstat-no" title="statement not covered" >!t.hasField(r.name)&amp;&amp;!r.isRelation&amp;&amp;t.addSuggestion(new re(r.name,"true"))}</span></span>function <span class="fstat-no" title="function not covered" >Pa(t</span>,e){<span class="cstat-no" title="statement not covered" >for(let r of e)<span class="cstat-no" title="statement not covered" >t.hasField(r.name)||t.addSuggestion(new re(r.name,r.typeNames.join(" | ")))}</span></span>function <span class="fstat-no" title="function not covered" >yi(t</span>,e){let[r,n]=<span class="cstat-no" title="statement not covered" >dt(t),i</span>=<span class="cstat-no" title="statement not covered" >e.arguments.getDeepSubSelectionValue(r)?.asObject();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!i)<span class="cstat-no" title="statement not covered" >return{parentKind:"unknown",fieldName:n};l</span></span>et o=<span class="cstat-no" title="statement not covered" >i.getFieldValue("select")?.asObject(),s</span>=<span class="cstat-no" title="statement not covered" >i.getFieldValue("include")?.asObject(),a</span>=<span class="cstat-no" title="statement not covered" >i.getFieldValue("omit")?.asObject(),f</span>=<span class="cstat-no" title="statement not covered" >o?.getField(n);<span class="cstat-no" title="statement not covered" >r</span>eturn o&amp;&amp;f?{parentKind:"select",parent:o,field:f,fieldName:n}:(f=s?.getField(n),s&amp;&amp;f?{parentKind:"include",field:f,parent:s,fieldName:n}:(f=a?.getField(n),a&amp;&amp;f?{parentKind:"omit",field:f,parent:a,fieldName:n}:{parentKind:"unknown",fieldName:n}))}</span>function <span class="fstat-no" title="function not covered" >hi(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.kind==="object")<span class="cstat-no" title="statement not covered" >for(let r of e.fields)<span class="cstat-no" title="statement not covered" >t.hasField(r.name)||t.addSuggestion(new re(r.name,r.typeNames.join(" | ")))}</span></span></span>function <span class="fstat-no" title="function not covered" >dt(t</span>){let e=<span class="cstat-no" title="statement not covered" >[...t],r</span>=<span class="cstat-no" title="statement not covered" >e.pop();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!r)<span class="cstat-no" title="statement not covered" >throw new Error("unexpected empty path");<span class="cstat-no" title="statement not covered" >r</span></span>eturn[e,r]}f</span>unction <span class="fstat-no" title="function not covered" >ft({</span>green:t,enabled:e}){<span class="cstat-no" title="statement not covered" >return"Available options are "+(e?`listed in ${t("green")}`:"marked with ?")+"."}</span>function <span class="fstat-no" title="function not covered" >Jt(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===1)<span class="cstat-no" title="statement not covered" >return e[0];l</span></span>et r=<span class="cstat-no" title="statement not covered" >[...e],n</span>=<span class="cstat-no" title="statement not covered" >r.pop();<span class="cstat-no" title="statement not covered" >r</span>eturn`${r.join(", ")} ${t} ${n}`}v</span>ar va=<span class="cstat-no" title="statement not covered" >3;f</span>unction <span class="fstat-no" title="function not covered" >Ta(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >1/0,n</span>;<span class="cstat-no" title="statement not covered" >for(let i of e){let o=<span class="cstat-no" title="statement not covered" >(0,pi.default)(t,i);<span class="cstat-no" title="statement not covered" >o</span>&gt;va||o&lt;r&amp;&amp;(r=o,n=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar gt=<span class="cstat-no" title="statement not covered" >class{modelName;name;typeName;isList;isEnum;<span class="fstat-no" title="function not covered" >constructor(e</span>,r,n,i,o){<span class="cstat-no" title="statement not covered" >this.modelName=e,this.name=r,this.typeName=n,this.isList=i,this.isEnum=o}<span class="fstat-no" title="function not covered" ></span>_toGraphQLInputType(){</span>let e=<span class="cstat-no" title="statement not covered" >this.isList?"List":"",r</span>=<span class="cstat-no" title="statement not covered" >this.isEnum?"Enum":"";<span class="cstat-no" title="statement not covered" >r</span>eturn`${e}${r}${this.typeName}FieldRefInput&lt;${this.modelName}&gt;`}}</span>;f</span>unction <span class="fstat-no" title="function not covered" >Ke(t</span>){<span class="cstat-no" title="statement not covered" >return t instanceof gt}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Gt=<span class="cstat-no" title="statement not covered" >Symbol(),q</span>r=<span class="cstat-no" title="statement not covered" >new WeakMap,x</span>e=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >e===Gt?qr.set(this,`Prisma.${this._getName()}`):qr.set(this,`new Prisma.${this._getNamespace()}.${this._getName()}()`)}<span class="fstat-no" title="function not covered" ></span>_getName(){<span class="cstat-no" title="statement not covered" ></span>return this.constructor.name}<span class="fstat-no" title="function not covered" >t</span>oString(){<span class="cstat-no" title="statement not covered" ></span>return qr.get(this)}</span>},y</span>t=<span class="cstat-no" title="statement not covered" >class extends xe{<span class="fstat-no" title="function not covered" >_getNamespace(){<span class="cstat-no" title="statement not covered" ></span>return"NullTypes"}</span>},h</span>t=<span class="cstat-no" title="statement not covered" >class extends yt{#e};<span class="cstat-no" title="statement not covered" >U</span>r(ht,"DbNull");v</span>ar bt=<span class="cstat-no" title="statement not covered" >class extends yt{#e};<span class="cstat-no" title="statement not covered" >U</span>r(bt,"JsonNull");v</span>ar wt=<span class="cstat-no" title="statement not covered" >class extends yt{#e};<span class="cstat-no" title="statement not covered" >U</span>r(wt,"AnyNull");v</span>ar Wt=<span class="cstat-no" title="statement not covered" >{classes:{DbNull:ht,JsonNull:bt,AnyNull:wt},instances:{DbNull:new ht(Gt),JsonNull:new bt(Gt),AnyNull:new wt(Gt)}};f</span>unction <span class="fstat-no" title="function not covered" >Ur(t</span>,e){<span class="cstat-no" title="statement not covered" >Object.defineProperty(t,"name",{value:e,configurable:!0})}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar bi=<span class="cstat-no" title="statement not covered" >": ",K</span>t=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>,r){<span class="cstat-no" title="statement not covered" >this.name=e;<span class="cstat-no" title="statement not covered" >t</span>his.value=r}<span class="cstat-no" title="statement not covered" ></span>hasError=!1;<span class="fstat-no" title="function not covered" >m</span>arkAsError(){<span class="cstat-no" title="statement not covered" ></span>this.hasError=!0}<span class="fstat-no" title="function not covered" ></span>getPrintWidth(){<span class="cstat-no" title="statement not covered" ></span>return this.name.length+this.value.getPrintWidth()+bi.length}<span class="fstat-no" title="function not covered" >w</span>rite(e</span>){let r=<span class="cstat-no" title="statement not covered" >new de(this.name);<span class="cstat-no" title="statement not covered" >t</span>his.hasError&amp;&amp;r.underline().setColor(e.context.colors.red),e.write(r).write(bi).write(this.value)}</span>};v</span>ar Br=<span class="cstat-no" title="statement not covered" >class{arguments;<span class="cstat-no" title="statement not covered" >errorMessages=[];<span class="fstat-no" title="function not covered" >c</span>onstructor(e</span>){<span class="cstat-no" title="statement not covered" >this.arguments=e}<span class="fstat-no" title="function not covered" ></span>write(e</span>){<span class="cstat-no" title="statement not covered" >e.write(this.arguments)}<span class="fstat-no" title="function not covered" ></span>addErrorMessage(e</span>){<span class="cstat-no" title="statement not covered" >this.errorMessages.push(e)}<span class="fstat-no" title="function not covered" ></span>renderAllMessages(e</span>){<span class="cstat-no" title="statement not covered" >return this.errorMessages.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>(e)).j</span>oin(`</span></span>
`)}};function <span class="fstat-no" title="function not covered" >He(t</span>){<span class="cstat-no" title="statement not covered" >return new Br(wi(t))}</span>function <span class="fstat-no" title="function not covered" >wi(t</span>){let e=<span class="cstat-no" title="statement not covered" >new We;<span class="cstat-no" title="statement not covered" >f</span>or(let[r,n]of Object.entries(t)){let i=<span class="cstat-no" title="statement not covered" >new Kt(r,xi(n));<span class="cstat-no" title="statement not covered" >e</span>.addField(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >xi(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t=="string")<span class="cstat-no" title="statement not covered" >return new G(JSON.stringify(t));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t=="number"||typeof t=="boolean")<span class="cstat-no" title="statement not covered" >return new G(String(t));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t=="bigint")<span class="cstat-no" title="statement not covered" >return new G(`${t}n`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t===null)<span class="cstat-no" title="statement not covered" >return new G("null");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t===void 0)<span class="cstat-no" title="statement not covered" >return new G("undefined");<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(je(t))<span class="cstat-no" title="statement not covered" >return new G(`new Prisma.Decimal("${t.toFixed()}")`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t instanceof Uint8Array)<span class="cstat-no" title="statement not covered" >return b.isBuffer(t)?new G(`Buffer.alloc(${t.byteLength})`):new G(`new Uint8Array(${t.byteLength})`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t instanceof Date){let e=<span class="cstat-no" title="statement not covered" >Ut(t)?t.toISOString():"Invalid Date";<span class="cstat-no" title="statement not covered" >r</span>eturn new G(`new Date("${e}")`)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t instanceof xe?new G(`Prisma.${t._getName()}`):Ke(t)?new G(`prisma.${ve(t.modelName)}.$fields.${t.name}`):Array.isArray(t)?Ca(t):typeof t=="object"?wi(t):new G(Object.prototype.toString.call(t))}</span>function <span class="fstat-no" title="function not covered" >Ca(t</span>){let e=<span class="cstat-no" title="statement not covered" >new Ge;<span class="cstat-no" title="statement not covered" >f</span>or(let r of t)<span class="cstat-no" title="statement not covered" >e.addItem(xi(r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Ht(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >e==="pretty"?mi:Qt,n</span>=<span class="cstat-no" title="statement not covered" >t.renderAllMessages(r),i</span>=<span class="cstat-no" title="statement not covered" >new Qe(0,{colors:r}).write(t).toString();<span class="cstat-no" title="statement not covered" >r</span>eturn{message:n,args:i}}</span>function <span class="fstat-no" title="function not covered" >zt({</span>args:t,errors:e,errorFormat:r,callsite:n,originalMethod:i,clientVersion:o,globalOmit:s}){let a=<span class="cstat-no" title="statement not covered" >He(t);<span class="cstat-no" title="statement not covered" >f</span>or(let C of e)<span class="cstat-no" title="statement not covered" >$t(C,a,s);l</span></span>et{message:f,args:h}=<span class="cstat-no" title="statement not covered" >Ht(a,r),T</span>=<span class="cstat-no" title="statement not covered" >Bt({message:f,callsite:n,originalMethod:i,showColors:r==="pretty",callArguments:h});<span class="cstat-no" title="statement not covered" >t</span>hrow new W(T,{clientVersion:o})}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >fe(t</span>){<span class="cstat-no" title="statement not covered" >return t.replace(/^./,<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.toLowerCase())}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Pi(t</span>,e,r){let n=<span class="cstat-no" title="statement not covered" >fe(r);<span class="cstat-no" title="statement not covered" >r</span>eturn!e.result||!(e.result.$allModels||e.result[n])?t:Ra({...t,...Ei(e.name,t,e.result.$allModels),...Ei(e.name,t,e.result[n])})}</span>function <span class="fstat-no" title="function not covered" >Ra(t</span>){let e=<span class="cstat-no" title="statement not covered" >new pe,r</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e.getOrCreate(n,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>.has(n)?[n]:(i.add(n),t[n]?t[n].needs.flatMap(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >r</span>(o,i)):[</span>n]</span></span></span>));<span class="cstat-no" title="statement not covered" >return Be(t,<span class="fstat-no" title="function not covered" >n=&gt;(<span class="cstat-no" title="statement not covered" >{</span>...n,needs:r(n.name,new Set)}))}</span></span>function <span class="fstat-no" title="function not covered" >Ei(t</span>,e,r){<span class="cstat-no" title="statement not covered" >return r?Be(r,<span class="fstat-no" title="function not covered" >({</span>needs:n,compute:i},o)=&gt;(<span class="cstat-no" title="statement not covered" >{name:o,needs:n?Object.keys(n).filter(<span class="fstat-no" title="function not covered" >s=&gt;<span class="cstat-no" title="statement not covered" >n</span>[s])</span>:[],compute:Aa(e,o,i)})):{</span>}}</span>function <span class="fstat-no" title="function not covered" >Aa(t</span>,e,r){let n=<span class="cstat-no" title="statement not covered" >t?.[e]?.compute;<span class="cstat-no" title="statement not covered" >r</span>eturn n?<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >r</span>({...i,[e]:n(i)}):r</span>}</span>function <span class="fstat-no" title="function not covered" >vi(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e)<span class="cstat-no" title="statement not covered" >return t;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{...t};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.values(e))<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >r[i]=!0;<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>function <span class="fstat-no" title="function not covered" >Ti(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e)<span class="cstat-no" title="statement not covered" >return t;l</span></span>et r=<span class="cstat-no" title="statement not covered" >{...t};<span class="cstat-no" title="statement not covered" >f</span>or(let n of Object.values(e))<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t[n.name])<span class="cstat-no" title="statement not covered" >for(let i of n.needs)<span class="cstat-no" title="statement not covered" >delete r[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn r}</span>var Yt=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>,r){<span class="cstat-no" title="statement not covered" >this.extension=e;<span class="cstat-no" title="statement not covered" >t</span>his.previous=r}<span class="cstat-no" title="statement not covered" ></span>computedFieldsCache=new pe;<span class="cstat-no" title="statement not covered" >m</span>odelExtensionsCache=new pe;<span class="cstat-no" title="statement not covered" >q</span>ueryCallbacksCache=new pe;<span class="cstat-no" title="statement not covered" >c</span>lientExtensions=ut(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.extension.client?{...this.previous?.getAllClientExtensions(),...this.extension.client}:this.previous?.getAllClientExtensions());<span class="cstat-no" title="statement not covered" >b</span></span>atchCallbacks=ut(<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et e=<span class="cstat-no" title="statement not covered" >this.previous?.getAllBatchQueryCallbacks()??[],</span>r=<span class="cstat-no" title="statement not covered" >this.extension.query?.$__internalBatch;<span class="cstat-no" title="statement not covered" >r</span>eturn r?e.concat(r):e}</span>);<span class="fstat-no" title="function not covered" >g</span>etAllComputedFields(e</span>){<span class="cstat-no" title="statement not covered" >return this.computedFieldsCache.getOrCreate(e,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >P</span>i(this.previous?.getAllComputedFields(e),this.extension,e))}<span class="fstat-no" title="function not covered" ></span></span>getAllClientExtensions(){<span class="cstat-no" title="statement not covered" ></span>return this.clientExtensions.get()}<span class="fstat-no" title="function not covered" ></span>getAllModelExtensions(e</span>){<span class="cstat-no" title="statement not covered" >return this.modelExtensionsCache.getOrCreate(e,<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >fe(e);<span class="cstat-no" title="statement not covered" >r</span>eturn!this.extension.model||!(this.extension.model[r]||this.extension.model.$allModels)?this.previous?.getAllModelExtensions(e):{...this.previous?.getAllModelExtensions(e),...this.extension.model.$allModels,...this.extension.model[r]}}</span>)}<span class="fstat-no" title="function not covered" ></span>getAllQueryCallbacks(e</span>,r){<span class="cstat-no" title="statement not covered" >return this.queryCallbacksCache.getOrCreate(`${e}:${r}`,<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >this.previous?.getAllQueryCallbacks(e,r)??[],</span>i=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >this.extension.query;<span class="cstat-no" title="statement not covered" ></span>return!o||!(o[e]||o.$allModels||o[r]||o.$allOperations)?n:(o[e]!==void 0&amp;&amp;(o[e][r]!==void 0&amp;&amp;i.push(o[e][r]),o[e].$allOperations!==void 0&amp;&amp;i.push(o[e].$allOperations)),e!=="$none"&amp;&amp;o.$allModels!==void 0&amp;&amp;(o.$allModels[r]!==void 0&amp;&amp;i.push(o.$allModels[r]),o.$allModels.$allOperations!==void 0&amp;&amp;i.push(o.$allModels.$allOperations)),o[r]!==void 0&amp;&amp;i.push(o[r]),o.$allOperations!==void 0&amp;&amp;i.push(o.$allOperations),n.concat(i))}</span>)}<span class="fstat-no" title="function not covered" ></span>getAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" ></span>return this.batchCallbacks.get()}</span>},z</span>e=<span class="cstat-no" title="statement not covered" >class t{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.head=e}<span class="fstat-no" title="function not covered" ></span>static e</span>mpty(){<span class="cstat-no" title="statement not covered" >return new t}<span class="fstat-no" title="function not covered" ></span>static s</span>ingle(e){<span class="cstat-no" title="statement not covered" >return new t(new Yt(e))}<span class="fstat-no" title="function not covered" ></span>isEmpty(){<span class="cstat-no" title="statement not covered" ></span>return this.head===void 0}<span class="fstat-no" title="function not covered" ></span>append(e</span>){<span class="cstat-no" title="statement not covered" >return new t(new Yt(e,this.head))}<span class="fstat-no" title="function not covered" ></span>getAllComputedFields(e</span>){<span class="cstat-no" title="statement not covered" >return this.head?.getAllComputedFields(e)}<span class="fstat-no" title="function not covered" ></span>getAllClientExtensions(){<span class="cstat-no" title="statement not covered" ></span>return this.head?.getAllClientExtensions()}<span class="fstat-no" title="function not covered" ></span>getAllModelExtensions(e</span>){<span class="cstat-no" title="statement not covered" >return this.head?.getAllModelExtensions(e)}<span class="fstat-no" title="function not covered" ></span>getAllQueryCallbacks(e</span>,r){<span class="cstat-no" title="statement not covered" >return this.head?.getAllQueryCallbacks(e,r)??[]}<span class="fstat-no" title="function not covered" >g</span>etAllBatchQueryCallbacks(){<span class="cstat-no" title="statement not covered" ></span>return this.head?.getAllBatchQueryCallbacks()??[]}}</span>;<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Xt=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.name=e}</span>};f</span>unction <span class="fstat-no" title="function not covered" >Ci(t</span>){<span class="cstat-no" title="statement not covered" >return t instanceof Xt}</span>function <span class="fstat-no" title="function not covered" >Ri(t</span>){<span class="cstat-no" title="statement not covered" >return new Xt(t)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ai=<span class="cstat-no" title="statement not covered" >Symbol(),x</span>t=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e!==Ai)<span class="cstat-no" title="statement not covered" >throw new Error("Skip instance can not be constructed directly")}<span class="fstat-no" title="function not covered" ></span></span>ifUndefined(e</span>){<span class="cstat-no" title="statement not covered" >return e===void 0?Zt:e}</span>},Z</span>t=<span class="cstat-no" title="statement not covered" >new xt(Ai);f</span>unction <span class="fstat-no" title="function not covered" >ge(t</span>){<span class="cstat-no" title="statement not covered" >return t instanceof xt}</span>var Sa=<span class="cstat-no" title="statement not covered" >{findUnique:"findUnique",findUniqueOrThrow:"findUniqueOrThrow",findFirst:"findFirst",findFirstOrThrow:"findFirstOrThrow",findMany:"findMany",count:"aggregate",create:"createOne",createMany:"createMany",createManyAndReturn:"createManyAndReturn",update:"updateOne",updateMany:"updateMany",updateManyAndReturn:"updateManyAndReturn",upsert:"upsertOne",delete:"deleteOne",deleteMany:"deleteMany",executeRaw:"executeRaw",queryRaw:"queryRaw",aggregate:"aggregate",groupBy:"groupBy",runCommandRaw:"runCommandRaw",findRaw:"findRaw",aggregateRaw:"aggregateRaw"},S</span>i=<span class="cstat-no" title="statement not covered" >"explicitly `undefined` values are not allowed";f</span>unction <span class="fstat-no" title="function not covered" >er({</span>modelName:t,action:e,args:r,runtimeDataModel:n,extensions:i=<span class="branch-0 cbranch-no" title="branch not covered" >ze.empty(),</span>callsite:o,clientMethod:s,errorFormat:a,clientVersion:f,previewFeatures:h,globalOmit:T}){let C=<span class="cstat-no" title="statement not covered" >new $r({runtimeDataModel:n,modelName:t,action:e,rootArgs:r,callsite:o,extensions:i,selectionPath:[],argumentPath:[],originalMethod:s,errorFormat:a,clientVersion:f,previewFeatures:h,globalOmit:T});<span class="cstat-no" title="statement not covered" >r</span>eturn{modelName:t,action:Sa[e],query:Et(r,C)}}</span>function <span class="fstat-no" title="function not covered" >Et({</span>select:t,include:e,...r}=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>n){let i=<span class="cstat-no" title="statement not covered" >r.omit;<span class="cstat-no" title="statement not covered" ></span>return delete r.omit,{arguments:Oi(r,n),selection:ka(t,e,i,n)}}</span>function <span class="fstat-no" title="function not covered" >ka(t</span>,e,r,n){<span class="cstat-no" title="statement not covered" >return t?(e?n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"include",secondField:"select",selectionPath:n.getSelectionPath()}):r&amp;&amp;n.throwValidationError({kind:"MutuallyExclusiveFields",firstField:"omit",secondField:"select",selectionPath:n.getSelectionPath()}),Da(t,n)):Oa(n,e,r)}</span>function <span class="fstat-no" title="function not covered" >Oa(t</span>,e,r){let n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >r</span>eturn t.modelOrType&amp;&amp;!t.isRawAction()&amp;&amp;(n.$composites=!0,n.$scalars=!0),e&amp;&amp;Ma(n,e,t),Ia(n,r,t),n}</span>function <span class="fstat-no" title="function not covered" >Ma(t</span>,e,r){<span class="cstat-no" title="statement not covered" >for(let[n,i]of Object.entries(e)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(ge(i))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et o=<span class="cstat-no" title="statement not covered" >r.nestSelection(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(Vr(i,o),i===!1||i===void 0){<span class="cstat-no" title="statement not covered" >t[n]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>l</span>et s=<span class="cstat-no" title="statement not covered" >r.findField(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(s&amp;&amp;s.kind!=="object"&amp;&amp;r.throwValidationError({kind:"IncludeOnScalar",selectionPath:r.getSelectionPath().concat(n),outputType:r.getOutputTypeDescription()}),s){<span class="cstat-no" title="statement not covered" >t[n]=Et(i===!0?{}:i,o);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(i===!0){<span class="cstat-no" title="statement not covered" >t[n]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>[n]=Et(i,o)}</span>}</span>function <span class="fstat-no" title="function not covered" >Ia(t</span>,e,r){let n=<span class="cstat-no" title="statement not covered" >r.getComputedFields(),i</span>=<span class="cstat-no" title="statement not covered" >{...r.getGlobalOmit(),...e},o</span>=<span class="cstat-no" title="statement not covered" >Ti(i,n);<span class="cstat-no" title="statement not covered" >f</span>or(let[s,a]of Object.entries(o)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(ge(a))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >V</span></span>r(a,r.nestSelection(s));l</span>et f=<span class="cstat-no" title="statement not covered" >r.findField(s);<span class="cstat-no" title="statement not covered" >n</span>?.[s]&amp;&amp;!f||(t[s]=!a)}</span>}</span>function <span class="fstat-no" title="function not covered" >Da(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >{},n</span>=<span class="cstat-no" title="statement not covered" >e.getComputedFields(),i</span>=<span class="cstat-no" title="statement not covered" >vi(t,n);<span class="cstat-no" title="statement not covered" >f</span>or(let[o,s]of Object.entries(i)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(ge(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et a=<span class="cstat-no" title="statement not covered" >e.nestSelection(o);<span class="cstat-no" title="statement not covered" >V</span>r(s,a);l</span>et f=<span class="cstat-no" title="statement not covered" >e.findField(o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!(n?.[o]&amp;&amp;!f)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s===!1||s===void 0||ge(s)){<span class="cstat-no" title="statement not covered" >r[o]=!1;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(s===!0){<span class="cstat-no" title="statement not covered" >f?.kind==="object"?r[o]=Et({},a):r[o]=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>r</span>[o]=Et(s,a)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >ki(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t===null)<span class="cstat-no" title="statement not covered" >return null;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t=="string"||typeof t=="number"||typeof t=="boolean")<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t=="bigint")<span class="cstat-no" title="statement not covered" >return{$type:"BigInt",value:String(t)};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Ve(t)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(Ut(t))<span class="cstat-no" title="statement not covered" >return{$type:"DateTime",value:t.toISOString()};<span class="cstat-no" title="statement not covered" >e</span></span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:e.getSelectionPath(),argumentPath:e.getArgumentPath(),argument:{name:e.getArgumentName(),typeNames:["Date"]},underlyingError:"Provided Date object is invalid"})}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(Ci(t))<span class="cstat-no" title="statement not covered" >return{$type:"Param",value:t.name};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Ke(t))<span class="cstat-no" title="statement not covered" >return{$type:"FieldRef",value:{_ref:t.name,_container:t.modelName}};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return _a(t,e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(t)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >r</span>eturn{$type:"Bytes",value:b.from(r,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(La(t))<span class="cstat-no" title="statement not covered" >return t.values;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(je(t))<span class="cstat-no" title="statement not covered" >return{$type:"Decimal",value:t.toFixed()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t instanceof xe){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t!==Wt.instances[t._getName()])<span class="cstat-no" title="statement not covered" >throw new Error("Invalid ObjectEnumValue");<span class="cstat-no" title="statement not covered" >r</span></span>eturn{$type:"Enum",value:t._getName()}}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(Fa(t))<span class="cstat-no" title="statement not covered" >return t.toJSON();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t=="object")<span class="cstat-no" title="statement not covered" >return Oi(t,e);<span class="cstat-no" title="statement not covered" >e</span></span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:e.getSelectionPath(),argumentPath:e.getArgumentPath(),argument:{name:e.getArgumentName(),typeNames:[]},underlyingError:`We could not serialize ${Object.prototype.toString.call(t)} value. Serialize the object to JSON or implement a ".toJSON()" method on it`})}</span>function <span class="fstat-no" title="function not covered" >Oi(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.$type)<span class="cstat-no" title="statement not covered" >return{$type:"Raw",value:t};l</span></span>et r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let n in t){let i=<span class="cstat-no" title="statement not covered" >t[n],</span>o=<span class="cstat-no" title="statement not covered" >e.nestArgument(n);<span class="cstat-no" title="statement not covered" >g</span>e(i)||(i!==void 0?r[n]=ki(i,o):e.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;e.throwValidationError({kind:"InvalidArgumentValue",argumentPath:o.getArgumentPath(),selectionPath:e.getSelectionPath(),argument:{name:e.getArgumentName(),typeNames:[]},underlyingError:Si}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >_a(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;n</span>&lt;t.length;n++){let i=<span class="cstat-no" title="statement not covered" >e.nestArgument(String(n)),o</span>=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(o===void 0||ge(o)){let s=<span class="cstat-no" title="statement not covered" >o===void 0?"undefined":"Prisma.skip";<span class="cstat-no" title="statement not covered" >e</span>.throwValidationError({kind:"InvalidArgumentValue",selectionPath:i.getSelectionPath(),argumentPath:i.getArgumentPath(),argument:{name:`${e.getArgumentName()}[${n}]`,typeNames:[]},underlyingError:`Can not use \`${s}\` value within array. Use \`null\` or filter out \`${s}\` values`})}<span class="cstat-no" title="statement not covered" ></span>r</span>.push(ki(o,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>function <span class="fstat-no" title="function not covered" >La(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t=="object"&amp;&amp;t!==null&amp;&amp;t.__prismaRawParameters__===!0}</span>function <span class="fstat-no" title="function not covered" >Fa(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t=="object"&amp;&amp;t!==null&amp;&amp;typeof t.toJSON=="function"}</span>function <span class="fstat-no" title="function not covered" >Vr(t</span>,e){<span class="cstat-no" title="statement not covered" >t===void 0&amp;&amp;e.isPreviewFeatureOn("strictUndefinedChecks")&amp;&amp;e.throwValidationError({kind:"InvalidSelectionValue",selectionPath:e.getSelectionPath(),underlyingError:Si})}</span>var $r=<span class="cstat-no" title="statement not covered" >class t{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.params=e;<span class="cstat-no" title="statement not covered" >t</span>his.params.modelName&amp;&amp;(this.modelOrType=this.params.runtimeDataModel.models[this.params.modelName]??this.params.runtimeDataModel.types[this.params.modelName]</span>)}modelOrType;<span class="fstat-no" title="function not covered" >throwValidationError(e</span>){<span class="cstat-no" title="statement not covered" >zt({errors:[e],originalMethod:this.params.originalMethod,args:this.params.rootArgs??{},callsite:this.params.callsite,errorFormat:this.params.errorFormat,clientVersion:this.params.clientVersion,globalOmit:this.params.globalOmit})}<span class="fstat-no" title="function not covered" ></span>getSelectionPath(){<span class="cstat-no" title="statement not covered" ></span>return this.params.selectionPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentPath(){<span class="cstat-no" title="statement not covered" ></span>return this.params.argumentPath}<span class="fstat-no" title="function not covered" >g</span>etArgumentName(){<span class="cstat-no" title="statement not covered" ></span>return this.params.argumentPath[this.params.argumentPath.length-1]}<span class="fstat-no" title="function not covered" >g</span>etOutputTypeDescription(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(!(!this.params.modelName||!this.modelOrType))<span class="cstat-no" title="statement not covered" >return{name:this.params.modelName,fields:this.modelOrType.fields.map(<span class="fstat-no" title="function not covered" >e=&gt;(<span class="cstat-no" title="statement not covered" >{</span>name:e.name,typeName:"boolean",isRelation:e.kind==="object"}))}</span>}<span class="fstat-no" title="function not covered" ></span></span>isRawAction(){<span class="cstat-no" title="statement not covered" ></span>return["executeRaw","queryRaw","runCommandRaw","findRaw","aggregateRaw"].includes(this.params.action)}<span class="fstat-no" title="function not covered" ></span>isPreviewFeatureOn(e</span>){<span class="cstat-no" title="statement not covered" >return this.params.previewFeatures.includes(e)}<span class="fstat-no" title="function not covered" ></span>getComputedFields(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(this.params.modelName)<span class="cstat-no" title="statement not covered" >return this.params.extensions.getAllComputedFields(this.params.modelName)}<span class="fstat-no" title="function not covered" ></span></span>findField(e</span>){<span class="cstat-no" title="statement not covered" >return this.modelOrType?.fields.find(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.name===e)}<span class="fstat-no" title="function not covered" ></span></span>nestSelection(e</span>){let r=<span class="cstat-no" title="statement not covered" >this.findField(e),n</span>=<span class="cstat-no" title="statement not covered" >r?.kind==="object"?r.type:void 0;<span class="cstat-no" title="statement not covered" >r</span>eturn new t({...this.params,modelName:n,selectionPath:this.params.selectionPath.concat(e)})}<span class="fstat-no" title="function not covered" ></span>getGlobalOmit(){<span class="cstat-no" title="statement not covered" ></span>return this.params.modelName&amp;&amp;this.shouldApplyGlobalOmit()?this.params.globalOmit?.[ve(this.params.modelName)]??{}:{}}<span class="fstat-no" title="function not covered" ></span>shouldApplyGlobalOmit(){<span class="cstat-no" title="statement not covered" ></span>switch(this.params.action){case"findFirst":case"findFirstOrThrow":case"findUniqueOrThrow":case"findMany":case"upsert":case"findUnique":case"createManyAndReturn":case"create":case"update":case"updateManyAndReturn":case"delete":<span class="cstat-no" title="statement not covered" >return!0;c</span>ase"executeRaw":case"aggregateRaw":case"runCommandRaw":case"findRaw":case"createMany":case"deleteMany":case"groupBy":case"updateMany":case"count":case"aggregate":case"queryRaw":<span class="cstat-no" title="statement not covered" >return!1;d</span>efault:<span class="cstat-no" title="statement not covered" >be(this.params.action,"Unknown action")}</span>}<span class="fstat-no" title="function not covered" ></span>nestArgument(e</span>){<span class="cstat-no" title="statement not covered" >return new t({...this.params,argumentPath:this.params.argumentPath.concat(e)})}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Mi(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t._hasPreviewFlag("metrics"))<span class="cstat-no" title="statement not covered" >throw new W("`metrics` preview feature must be enabled in order to access metrics API",{clientVersion:t._clientVersion})}</span></span>var Ye=<span class="cstat-no" title="statement not covered" >class{_client;<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this._client=e}<span class="fstat-no" title="function not covered" ></span>prometheus(e</span>){<span class="cstat-no" title="statement not covered" >return Mi(this._client),this._client._engine.metrics({format:"prometheus",...e})}<span class="fstat-no" title="function not covered" ></span>json(e</span>){<span class="cstat-no" title="statement not covered" >return Mi(this._client),this._client._engine.metrics({format:"json",...e})}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ii(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >ut(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >N</span>a(e));<span class="cstat-no" title="statement not covered" >O</span></span>bject.defineProperty(t,"dmmf",{get:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >r</span>.get()}</span>)}</span>function <span class="fstat-no" title="function not covered" >Na(t</span>){<span class="cstat-no" title="statement not covered" >throw new Error("Prisma.dmmf is not available when running in edge runtimes.")}</span>function <span class="fstat-no" title="function not covered" >jr(t</span>){<span class="cstat-no" title="statement not covered" >return Object.entries(t).map(<span class="fstat-no" title="function not covered" >([</span>e,r])=&gt;(<span class="cstat-no" title="statement not covered" >{name:e,...r}))}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Qr=<span class="cstat-no" title="statement not covered" >new WeakMap,t</span>r=<span class="cstat-no" title="statement not covered" >"$$PrismaTypedSql",P</span>t=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>,r){<span class="cstat-no" title="statement not covered" >Qr.set(this,{sql:e,values:r}),Object.defineProperty(this,tr,{value:tr})}<span class="fstat-no" title="function not covered" ></span>get s</span>ql(){<span class="cstat-no" title="statement not covered" >return Qr.get(this).sql}<span class="fstat-no" title="function not covered" >g</span>et v</span>alues(){<span class="cstat-no" title="statement not covered" >return Qr.get(this).values}}</span>;f</span>unction <span class="fstat-no" title="function not covered" >Di(t</span>){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..e)=&gt;<span class="cstat-no" title="statement not covered" >new Pt(t,e)}</span></span>function <span class="fstat-no" title="function not covered" >rr(t</span>){<span class="cstat-no" title="statement not covered" >return t!=null&amp;&amp;t[tr]===tr}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Jo=<span class="cstat-no" title="statement not covered" >nt(_i());<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >L</span>i();<span class="cstat-no" title="statement not covered" >U</span>n();<span class="cstat-no" title="statement not covered" >j</span>n();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Z=<span class="cstat-no" title="statement not covered" >class t{<span class="fstat-no" title="function not covered" >constructor(e</span>,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length-1!==r.length)<span class="cstat-no" title="statement not covered" >throw e.length===0?new TypeError("Expected at least 1 string"):new TypeError(`Expected ${e.length} strings to have ${e.length-1} values`);l</span></span>et n=<span class="cstat-no" title="statement not covered" >r.reduce(<span class="fstat-no" title="function not covered" >(s</span>,a)=&gt;<span class="cstat-no" title="statement not covered" >s+(a instanceof t?a.values.length:1),0</span>);<span class="cstat-no" title="statement not covered" >t</span>his.values=new Array(n),this.strings=new Array(n+1),this.strings[0]=e[0];l</span>et i=<span class="cstat-no" title="statement not covered" >0,o</span>=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;i&lt;r.length;){let s=<span class="cstat-no" title="statement not covered" >r[i++],</span>a=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>if(s instanceof t){<span class="cstat-no" title="statement not covered" >this.strings[o]+=s.strings[0];l</span>et f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;f&lt;s.values.length;)<span class="cstat-no" title="statement not covered" >this.values[o++]=s.values[f++],this.strings[o]=s.strings[f];<span class="cstat-no" title="statement not covered" >t</span></span>his.strings[o]+=a}</span>else <span class="cstat-no" title="statement not covered" >this.values[o++]=s,this.strings[o]=a}</span></span>}<span class="fstat-no" title="function not covered" ></span>get s</span>ql(){let e=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;e;)<span class="cstat-no" title="statement not covered" >n+=`?${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>get s</span>tatement(){let e=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;e;)<span class="cstat-no" title="statement not covered" >n+=`:${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>get t</span>ext(){let e=<span class="cstat-no" title="statement not covered" >this.strings.length,</span>r=<span class="cstat-no" title="statement not covered" >1,n</span>=<span class="cstat-no" title="statement not covered" >this.strings[0];<span class="cstat-no" title="statement not covered" ></span>for(;r&lt;e;)<span class="cstat-no" title="statement not covered" >n+=`$${r}${this.strings[r++]}`;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>inspect(){<span class="cstat-no" title="statement not covered" ></span>return{sql:this.sql,statement:this.statement,text:this.text,values:this.values}}</span>};f</span>unction <span class="fstat-no" title="function not covered" >Fi(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >",",</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >"",</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >"")</span>{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.length===0)<span class="cstat-no" title="statement not covered" >throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");<span class="cstat-no" title="statement not covered" >r</span></span>eturn new Z([r,...Array(t.length-1).fill(e),n],t)}</span>function <span class="fstat-no" title="function not covered" >Jr(t</span>){<span class="cstat-no" title="statement not covered" >return new Z([t],[])}</span>var Ni=<span class="cstat-no" title="statement not covered" >Jr("");f</span>unction <span class="fstat-no" title="function not covered" >Gr(t</span>,...e){<span class="cstat-no" title="statement not covered" >return new Z(t,e)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >vt(t</span>){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn Object.keys(t)}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(e</span>){<span class="cstat-no" title="statement not covered" >return t[e]}}</span>}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >K(t</span>,e){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn[t]},<span class="fstat-no" title="function not covered" >g</span>etPropertyValue(){<span class="cstat-no" title="statement not covered" >r</span>eturn e()}</span>}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ie(t</span>){let e=<span class="cstat-no" title="statement not covered" >new pe;<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn t.getKeys()}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(r</span>){<span class="cstat-no" title="statement not covered" >return e.getOrCreate(r,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>.getPropertyValue(r))}</span></span>,<span class="fstat-no" title="function not covered" >getPropertyDescriptor(r</span>){<span class="cstat-no" title="statement not covered" >return t.getPropertyDescriptor?.(r)}</span>}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ir=<span class="cstat-no" title="statement not covered" >{enumerable:!0,configurable:!0,writable:!0};f</span>unction <span class="fstat-no" title="function not covered" >or(t</span>){let e=<span class="cstat-no" title="statement not covered" >new Set(t);<span class="cstat-no" title="statement not covered" >r</span>eturn{getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>bject.prototype,</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >i</span>r,h</span>as:<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e.has(n),s</span>et:<span class="fstat-no" title="function not covered" >(r</span>,n,i)=&gt;<span class="cstat-no" title="statement not covered" >e.add(n)&amp;&amp;Reflect.set(r,n,i),o</span>wnKeys:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >[</span>...e]}}</span></span>var qi=<span class="cstat-no" title="statement not covered" >Symbol.for("nodejs.util.inspect.custom");f</span>unction <span class="fstat-no" title="function not covered" >le(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >Ua(e),n</span>=<span class="cstat-no" title="statement not covered" >new Set,i</span>=<span class="cstat-no" title="statement not covered" >new Proxy(t,{<span class="fstat-no" title="function not covered" >get(o</span>,s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.has(s))<span class="cstat-no" title="statement not covered" >return o[s];l</span></span>et a=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" >r</span>eturn a?a.getPropertyValue(s):o[s]},<span class="fstat-no" title="function not covered" >h</span>as(o</span>,s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n.has(s))<span class="cstat-no" title="statement not covered" >return!0;l</span></span>et a=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" >r</span>eturn a?a.has?.(s)??!0:Reflect.has(o,s)}</span>,<span class="fstat-no" title="function not covered" >ownKeys(o</span>){let s=<span class="cstat-no" title="statement not covered" >Ui(Reflect.ownKeys(o),r),a</span>=<span class="cstat-no" title="statement not covered" >Ui(Array.from(r.keys()),r);<span class="cstat-no" title="statement not covered" >r</span>eturn[...new Set([...s,...a,...n])]},<span class="fstat-no" title="function not covered" >s</span>et(o</span>,s,a){<span class="cstat-no" title="statement not covered" >return r.get(s)?.getPropertyDescriptor?.(s)?.writable===!1?!1:(n.add(s),Reflect.set(o,s,a))}</span>,<span class="fstat-no" title="function not covered" >getOwnPropertyDescriptor(o</span>,s){let a=<span class="cstat-no" title="statement not covered" >Reflect.getOwnPropertyDescriptor(o,s);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a&amp;&amp;!a.configurable)<span class="cstat-no" title="statement not covered" >return a;l</span></span>et f=<span class="cstat-no" title="statement not covered" >r.get(s);<span class="cstat-no" title="statement not covered" >r</span>eturn f?f.getPropertyDescriptor?{...ir,...f?.getPropertyDescriptor(s)}:ir:a}</span>,<span class="fstat-no" title="function not covered" >defineProperty(o</span>,s,a){<span class="cstat-no" title="statement not covered" >return n.add(s),Reflect.defineProperty(o,s,a)}</span>,getPrototypeOf:<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >O</span>bject.prototype}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn i[qi]=<span class="fstat-no" title="function not covered" >function(){l</span>et o=<span class="cstat-no" title="statement not covered" >{...this};<span class="cstat-no" title="statement not covered" >r</span>eturn delete o[qi],o}</span>,i}</span>function <span class="fstat-no" title="function not covered" >Ua(t</span>){let e=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" >f</span>or(let r of t){let n=<span class="cstat-no" title="statement not covered" >r.getKeys();<span class="cstat-no" title="statement not covered" >f</span>or(let i of n)<span class="cstat-no" title="statement not covered" >e.set(i,r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Ui(t</span>,e){<span class="cstat-no" title="statement not covered" >return t.filter(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >e</span>.get(r)?.has?.(r)??!0)}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Xe(t</span>){<span class="cstat-no" title="statement not covered" >return{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>,<span class="fstat-no" title="function not covered" >has(){<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(){}</span>}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >sr(t</span>,e){<span class="cstat-no" title="statement not covered" >return{batch:t,transaction:e?.kind==="batch"?{isolationLevel:e.options.isolationLevel}:void 0}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Bi(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t===void 0)<span class="cstat-no" title="statement not covered" >return"";l</span></span>et e=<span class="cstat-no" title="statement not covered" >He(t);<span class="cstat-no" title="statement not covered" >r</span>eturn new Qe(0,{colors:Qt}).write(e).toString()}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ba=<span class="cstat-no" title="statement not covered" >"P2037";f</span>unction <span class="fstat-no" title="function not covered" >ar({</span>error:t,user_facing_error:e},r,n){<span class="cstat-no" title="statement not covered" >return e.error_code?new X($a(e,n),{code:e.error_code,clientVersion:r,meta:e.meta,batchRequestIdx:e.batch_request_idx}):new j(t,{clientVersion:r,batchRequestIdx:e.batch_request_idx})}</span>function <span class="fstat-no" title="function not covered" >$a(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t.message;<span class="cstat-no" title="statement not covered" ></span>return(e==="postgresql"||e==="postgres"||e==="mysql")&amp;&amp;t.error_code===Ba&amp;&amp;(r+=`</span>
Prisma Accelerate has built-in connection pooling to prevent such errors: https://pris.ly/client/error-accelerate`),r}<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Wr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >getLocation(){<span class="cstat-no" title="statement not covered" ></span>return null}</span>};f</span>unction <span class="fstat-no" title="function not covered" >Ce(t</span>){<span class="cstat-no" title="statement not covered" >return typeof $EnabledCallSite=="function"&amp;&amp;t!=="minimal"?new $EnabledCallSite:new Wr}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar $i=<span class="cstat-no" title="statement not covered" >{_avg:!0,_count:!0,_sum:!0,_min:!0,_max:!0};f</span>unction <span class="fstat-no" title="function not covered" >Ze(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let e=<span class="cstat-no" title="statement not covered" >ja(t);<span class="cstat-no" title="statement not covered" >r</span>eturn Object.entries(e).reduce(<span class="fstat-no" title="function not covered" >(n</span>,[i,o])=&gt;(<span class="cstat-no" title="statement not covered" >$i[i]!==void 0?n.select[i]={select:o}:n[i]=o,n),{</span>select:{}})}</span>function <span class="fstat-no" title="function not covered" >ja(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof t._count=="boolean"?{...t,_count:{_all:t._count}}:t}</span>function <span class="fstat-no" title="function not covered" >lr(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=&gt;(<span class="cstat-no" title="statement not covered" >t</span>ypeof t._count=="boolean"&amp;&amp;(e._count=e._count._all),e)}</span></span>function <span class="fstat-no" title="function not covered" >Vi(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >lr(t);<span class="cstat-no" title="statement not covered" >r</span>eturn e({action:"aggregate",unpacker:r,argsMapper:Ze})(t)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Qa(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let{select:e,...r}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >r</span>eturn typeof e=="object"?Ze({...r,_count:e}):Ze({...r,_count:{_all:!0}})}</span>function <span class="fstat-no" title="function not covered" >Ja(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return typeof t.select=="object"?<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >l</span>r(t)(e)._count:<span class="fstat-no" title="function not covered" ></span>e=&gt;<span class="cstat-no" title="statement not covered" >l</span>r(t)(e)._count._all}</span>f</span>unction <span class="fstat-no" title="function not covered" >ji(t</span>,e){<span class="cstat-no" title="statement not covered" >return e({action:"count",unpacker:Ja(t),argsMapper:Qa})(t)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Ga(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let e=<span class="cstat-no" title="statement not covered" >Ze(t);<span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(e.by))<span class="cstat-no" title="statement not covered" >for(let r of e.by)<span class="cstat-no" title="statement not covered" >typeof r=="string"&amp;&amp;(e.select[r]=!0);else <span class="cstat-no" title="statement not covered" >t</span></span>ypeof e.by=="string"&amp;&amp;(e.select[e.by]=!0);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Wa(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=&gt;(<span class="cstat-no" title="statement not covered" >t</span>ypeof t?._count=="boolean"&amp;&amp;e.forEach(<span class="fstat-no" title="function not covered" >r=&gt;{<span class="cstat-no" title="statement not covered" >r</span>._count=r._count._all}),e</span>)}</span></span>function <span class="fstat-no" title="function not covered" >Qi(t</span>,e){<span class="cstat-no" title="statement not covered" >return e({action:"groupBy",unpacker:Wa(t),argsMapper:Ga})(t)}</span>function <span class="fstat-no" title="function not covered" >Ji(t</span>,e,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e==="aggregate")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >V</span>i(n,r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(e==="count")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >j</span>i(n,r);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(e==="groupBy")<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >Q</span>i(n,r)}<span class="cstat-no" title="statement not covered" ></span></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Gi(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >e.fields.filter(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >!</span>i.relationName)</span>,n</span>=<span class="cstat-no" title="statement not covered" >ri(r,"name");<span class="cstat-no" title="statement not covered" >r</span>eturn new Proxy({},{<span class="fstat-no" title="function not covered" >get(i</span>,o){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(o in i||typeof o=="symbol")<span class="cstat-no" title="statement not covered" >return i[o];l</span></span>et s=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(s)<span class="cstat-no" title="statement not covered" >return new gt(t,o,s.type,s.isList,s.kind==="enum")}</span></span>,...or(Object.keys(n))})}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Wi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >A</span>rray.isArray(t)?t:t.split("."),K</span></span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Wi(e).reduce(<span class="fstat-no" title="function not covered" >(r</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[n],</span>t),K</span></span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;<span class="cstat-no" title="statement not covered" >Wi(e).reduceRight(<span class="fstat-no" title="function not covered" >(n</span>,i,o,s)=&gt;<span class="cstat-no" title="statement not covered" >Object.assign({},Kr(t,s.slice(0,o)),{[i]:n}),r</span>);f</span></span>unction <span class="fstat-no" title="function not covered" >Ka(t</span>,e){<span class="cstat-no" title="statement not covered" >return t===void 0||e===void 0?[]:[...e,"select",t]}f</span>unction <span class="fstat-no" title="function not covered" >Ha(t</span>,e,r){<span class="cstat-no" title="statement not covered" >return e===void 0?t??{}:Ki(e,r,t||!0)}</span>function <span class="fstat-no" title="function not covered" >Hr(t</span>,e,r,n,i,o){let a=<span class="cstat-no" title="statement not covered" >t._runtimeDataModel.models[e].fields.reduce(<span class="fstat-no" title="function not covered" >(f</span>,h)=&gt;(<span class="cstat-no" title="statement not covered" >{...f,[h.name]:h}),{</span>});<span class="cstat-no" title="statement not covered" >r</span>eturn <span class="fstat-no" title="function not covered" >f=&gt;{l</span>et h=<span class="cstat-no" title="statement not covered" >Ce(t._errorFormat),T</span>=<span class="cstat-no" title="statement not covered" >Ka(n,i),C</span>=<span class="cstat-no" title="statement not covered" >Ha(f,o,T),k</span>=<span class="cstat-no" title="statement not covered" >r({dataPath:T,callsite:h})(C),A</span>=<span class="cstat-no" title="statement not covered" >za(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn new Proxy(k,{<span class="fstat-no" title="function not covered" >get(O</span>,S){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!A.includes(S))<span class="cstat-no" title="statement not covered" >return O[S];l</span></span>et oe=<span class="cstat-no" title="statement not covered" >[a[S].type,r,S],H</span>=<span class="cstat-no" title="statement not covered" >[T,C];<span class="cstat-no" title="statement not covered" >r</span>eturn Hr(t,...oe,...H)}</span>,...or([...A,...Object.getOwnPropertyNames(k)])})}</span>}</span>function <span class="fstat-no" title="function not covered" >za(t</span>,e){<span class="cstat-no" title="statement not covered" >return t._runtimeDataModel.models[e].fields.filter(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.kind==="object").m</span>ap(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>.name)</span>}</span>var Ya=<span class="cstat-no" title="statement not covered" >["findUnique","findUniqueOrThrow","findFirst","findFirstOrThrow","create","update","upsert","delete"],X</span>a=<span class="cstat-no" title="statement not covered" >["aggregate","count","groupBy"];f</span>unction <span class="fstat-no" title="function not covered" >zr(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >t._extensions.getAllModelExtensions(e)??{},n</span>=<span class="cstat-no" title="statement not covered" >[Za(t,e),tl(t,e),vt(r),K("name",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>),K</span>("$name",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>),K</span>("$parent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>._appliedParent)</span>];<span class="cstat-no" title="statement not covered" >r</span>eturn le({},n)}</span>function <span class="fstat-no" title="function not covered" >Za(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >fe(e),n</span>=<span class="cstat-no" title="statement not covered" >Object.keys(ct).concat("count");<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(i</span>){let o=<span class="cstat-no" title="statement not covered" >i,s</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >a=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >f</span>=&gt;{l</span>et h=<span class="cstat-no" title="statement not covered" >Ce(t._errorFormat);<span class="cstat-no" title="statement not covered" >r</span>eturn t._createPrismaPromise(<span class="fstat-no" title="function not covered" >T=&gt;{l</span>et C=<span class="cstat-no" title="statement not covered" >{args:f,dataPath:[],action:o,model:e,clientMethod:`${r}.${i}`,jsModelName:r,transaction:T,callsite:h};<span class="cstat-no" title="statement not covered" >r</span>eturn t._request({...C,...a})}</span>,{action:o,args:f,model:e})}</span>;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Ya.includes(o)?Hr(t,e,s):el(i)?Ji(t,i,s):s({})}</span>}}</span>function <span class="fstat-no" title="function not covered" >el(t</span>){<span class="cstat-no" title="statement not covered" >return Xa.includes(t)}</span>function <span class="fstat-no" title="function not covered" >tl(t</span>,e){<span class="cstat-no" title="statement not covered" >return Ie(K("fields",<span class="fstat-no" title="function not covered" >()=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >t._runtimeDataModel.models[e];<span class="cstat-no" title="statement not covered" ></span>return Gi(e,r)}</span>))}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Hi(t</span>){<span class="cstat-no" title="statement not covered" >return t.replace(/^./,<span class="fstat-no" title="function not covered" >e=&gt;<span class="cstat-no" title="statement not covered" >e</span>.toUpperCase())}</span></span>var Yr=<span class="cstat-no" title="statement not covered" >Symbol();f</span>unction <span class="fstat-no" title="function not covered" >Tt(t</span>){let e=<span class="cstat-no" title="statement not covered" >[rl(t),nl(t),K(Yr,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>),K</span>("$parent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>._appliedParent)</span>],r</span>=<span class="cstat-no" title="statement not covered" >t._extensions.getAllClientExtensions();<span class="cstat-no" title="statement not covered" >r</span>eturn r&amp;&amp;e.push(vt(r)),le(t,e)}</span>function <span class="fstat-no" title="function not covered" >rl(t</span>){let e=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(t._originalClient),r</span>=<span class="cstat-no" title="statement not covered" >[...new Set(Object.getOwnPropertyNames(e))];<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(n</span>){<span class="cstat-no" title="statement not covered" >return t[n]}}</span>}</span>function <span class="fstat-no" title="function not covered" >nl(t</span>){let e=<span class="cstat-no" title="statement not covered" >Object.keys(t._runtimeDataModel.models),r</span>=<span class="cstat-no" title="statement not covered" >e.map(fe),n</span>=<span class="cstat-no" title="statement not covered" >[...new Set(e.concat(r))];<span class="cstat-no" title="statement not covered" >r</span>eturn Ie({<span class="fstat-no" title="function not covered" >getKeys(){<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>,<span class="fstat-no" title="function not covered" >getPropertyValue(i</span>){let o=<span class="cstat-no" title="statement not covered" >Hi(i);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t._runtimeDataModel.models[o]!==void 0)<span class="cstat-no" title="statement not covered" >return zr(t,o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t._runtimeDataModel.models[i]!==void 0)<span class="cstat-no" title="statement not covered" >return zr(t,i)}</span></span>,<span class="fstat-no" title="function not covered" >getPropertyDescriptor(i</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!r.includes(i))<span class="cstat-no" title="statement not covered" >return{enumerable:!1}}</span></span>})}</span>function <span class="fstat-no" title="function not covered" >zi(t</span>){<span class="cstat-no" title="statement not covered" >return t[Yr]?t[Yr]:t}</span>function <span class="fstat-no" title="function not covered" >Yi(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t=="function")<span class="cstat-no" title="statement not covered" >return t(this);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t.client?.__AccelerateEngine){let r=<span class="cstat-no" title="statement not covered" >t.client.__AccelerateEngine;<span class="cstat-no" title="statement not covered" ></span>this._originalClient._engine=new r(this._originalClient._accelerateEngineConfig)}</span>l</span>et e=<span class="cstat-no" title="statement not covered" >Object.create(this._originalClient,{_extensions:{value:this._extensions.append(t)},_appliedParent:{value:this,configurable:!0},$use:{value:void 0},$on:{value:void 0}});<span class="cstat-no" title="statement not covered" >r</span>eturn Tt(e)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Xi({</span>result:t,modelName:e,select:r,omit:n,extensions:i}){let o=<span class="cstat-no" title="statement not covered" >i.getAllComputedFields(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o)<span class="cstat-no" title="statement not covered" >return t;l</span></span>et s=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let f of Object.values(o)){<span class="cstat-no" title="statement not covered" >if(n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n[f.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et h=<span class="cstat-no" title="statement not covered" >f.needs.filter(<span class="fstat-no" title="function not covered" >T=&gt;<span class="cstat-no" title="statement not covered" >n</span>[T])</span>;<span class="cstat-no" title="statement not covered" >h</span>.length&gt;0&amp;&amp;a.push(Xe(h))}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!r[f.name])<span class="cstat-no" title="statement not covered" >continue;l</span></span>et h=<span class="cstat-no" title="statement not covered" >f.needs.filter(<span class="fstat-no" title="function not covered" >T=&gt;<span class="cstat-no" title="statement not covered" >!</span>r[T])</span>;<span class="cstat-no" title="statement not covered" >h</span>.length&gt;0&amp;&amp;a.push(Xe(h))}<span class="cstat-no" title="statement not covered" ></span>i</span></span>l(t,f.needs)&amp;&amp;s.push(ol(f,le(t,s)))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.length&gt;0||a.length&gt;0?le(t,[...s,...a]):t}</span>function <span class="fstat-no" title="function not covered" >il(t</span>,e){<span class="cstat-no" title="statement not covered" >return e.every(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >D</span>r(t,r))}</span></span>function <span class="fstat-no" title="function not covered" >ol(t</span>,e){<span class="cstat-no" title="statement not covered" >return Ie(K(t.name,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>.compute(e)))}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >ur({</span>visitor:t,result:e,args:r,runtimeDataModel:n,modelName:i}){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(Array.isArray(e)){<span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;e.length;s++)<span class="cstat-no" title="statement not covered" >e[s]=ur({result:e[s],args:r,modelName:i,runtimeDataModel:n,visitor:t});<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>l</span>et o=<span class="cstat-no" title="statement not covered" >t(e,i,r)??e;<span class="cstat-no" title="statement not covered" >r</span>eturn r.include&amp;&amp;Zi({includeOrSelect:r.include,result:o,parentModelName:i,runtimeDataModel:n,visitor:t}),r.select&amp;&amp;Zi({includeOrSelect:r.select,result:o,parentModelName:i,runtimeDataModel:n,visitor:t}),o}</span>function <span class="fstat-no" title="function not covered" >Zi({</span>includeOrSelect:t,result:e,parentModelName:r,runtimeDataModel:n,visitor:i}){<span class="cstat-no" title="statement not covered" >for(let[o,s]of Object.entries(t)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!s||e[o]==null||ge(s))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et f=<span class="cstat-no" title="statement not covered" >n.models[r].fields.find(<span class="fstat-no" title="function not covered" >T=&gt;<span class="cstat-no" title="statement not covered" >T</span>.name===o);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!f||f.kind!=="object"||!f.relationName)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et h=<span class="cstat-no" title="statement not covered" >typeof s=="object"?s:{};<span class="cstat-no" title="statement not covered" >e</span>[o]=ur({visitor:i,result:e[o],args:h,modelName:f.type,runtimeDataModel:n})}</span>}</span>function <span class="fstat-no" title="function not covered" >eo({</span>result:t,modelName:e,args:r,extensions:n,runtimeDataModel:i,globalOmit:o}){<span class="cstat-no" title="statement not covered" >return n.isEmpty()||t==null||typeof t!="object"||!i.models[e]?t:ur({result:t,args:r??{},modelName:e,runtimeDataModel:i,visitor:<span class="fstat-no" title="function not covered" >(a</span>,f,h)=&gt;{let T=<span class="cstat-no" title="statement not covered" >fe(f);<span class="cstat-no" title="statement not covered" >r</span>eturn Xi({result:a,modelName:T,select:h.select,omit:h.select?void 0:{...o?.[T],...h.omit},extensions:n})}</span>})}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar sl=<span class="cstat-no" title="statement not covered" >["$connect","$disconnect","$on","$transaction","$use","$extends"],t</span>o=<span class="cstat-no" title="statement not covered" >sl;f</span>unction <span class="fstat-no" title="function not covered" >ro(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t instanceof Z)<span class="cstat-no" title="statement not covered" >return al(t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(rr(t))<span class="cstat-no" title="statement not covered" >return ll(t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(t)){let r=<span class="cstat-no" title="statement not covered" >[t[0]];<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >1;n</span>&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >r[n]=Ct(t[n]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>l</span>et e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r in t)<span class="cstat-no" title="statement not covered" >e[r]=Ct(t[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >al(t</span>){<span class="cstat-no" title="statement not covered" >return new Z(t.strings,t.values)}</span>function <span class="fstat-no" title="function not covered" >ll(t</span>){<span class="cstat-no" title="statement not covered" >return new Pt(t.sql,t.values)}</span>function <span class="fstat-no" title="function not covered" >Ct(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="object"||t==null||t instanceof xe||Ke(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(je(t))<span class="cstat-no" title="statement not covered" >return new ae(t.toFixed());<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Ve(t))<span class="cstat-no" title="statement not covered" >return new Date(+t);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(t))<span class="cstat-no" title="statement not covered" >return t.slice(0);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(t)){let e=<span class="cstat-no" title="statement not covered" >t.length,</span>r;<span class="cstat-no" title="statement not covered" >for(r=Array(e);e--;)<span class="cstat-no" title="statement not covered" >r[e]=Ct(t[e]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(typeof t=="object"){let e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r in t)<span class="cstat-no" title="statement not covered" >r==="__proto__"?Object.defineProperty(e,r,{value:Ct(t[r]),configurable:!0,enumerable:!0,writable:!0}):e[r]=Ct(t[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>b</span>e(t,"Unknown value")}</span>function <span class="fstat-no" title="function not covered" >io(t</span>,e,r,n=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>{<span class="cstat-no" title="statement not covered" >return t._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >e.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return"transaction"in e&amp;&amp;i!==void 0&amp;&amp;(e.transaction?.kind==="batch"&amp;&amp;e.transaction.lock.then(),e.transaction=i),n===r.length?t._executeRequest(e):r[n]({model:e.model,operation:e.model?e.action:e.clientMethod,args:ro(e.args??{}),__internalParams:e,query:<span class="fstat-no" title="function not covered" >(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>=&gt;{let f=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=lo(o,f),a.args=s,io(t,a,r,n+1)}</span>})}</span>)}</span>function <span class="fstat-no" title="function not covered" >oo(t</span>,e){let{jsModelName:r,action:n,clientMethod:i}=<span class="cstat-no" title="statement not covered" >e,o</span>=<span class="cstat-no" title="statement not covered" >r?n:i;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t._extensions.isEmpty())<span class="cstat-no" title="statement not covered" >return t._executeRequest(e);l</span></span>et s=<span class="cstat-no" title="statement not covered" >t._extensions.getAllQueryCallbacks(r??"$none",o);<span class="cstat-no" title="statement not covered" >r</span>eturn io(t,e,s)}</span>function <span class="fstat-no" title="function not covered" >so(t</span>){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=&gt;{l</span>et r=<span class="cstat-no" title="statement not covered" >{requests:e},n</span>=<span class="cstat-no" title="statement not covered" >e[0].extensions.getAllBatchQueryCallbacks();<span class="cstat-no" title="statement not covered" >r</span>eturn n.length?ao(r,n,0,t):t(r)}</span>}</span>function <span class="fstat-no" title="function not covered" >ao(t</span>,e,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r===e.length)<span class="cstat-no" title="statement not covered" >return n(t);l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.customDataProxyFetch,</span>o=<span class="cstat-no" title="statement not covered" >t.requests[0].transaction;<span class="cstat-no" title="statement not covered" ></span>return e[r]({args:{queries:t.requests.map(<span class="fstat-no" title="function not covered" >s=&gt;(<span class="cstat-no" title="statement not covered" >{</span>model:s.modelName,operation:s.action,args:s.args})),t</span>ransaction:o?{isolationLevel:o.kind==="batch"?o.isolationLevel:void 0}:void 0},__internalParams:t,<span class="fstat-no" title="function not covered" >query(s</span>,a=<span class="branch-0 cbranch-no" title="branch not covered" >t)</span>{let f=<span class="cstat-no" title="statement not covered" >a.customDataProxyFetch;<span class="cstat-no" title="statement not covered" ></span>return a.customDataProxyFetch=lo(i,f),ao(a,e,r+1,n)}</span>})}</span>var no=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>;f</span></span>unction <span class="fstat-no" title="function not covered" >lo(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >no,</span>e=<span class="branch-0 cbranch-no" title="branch not covered" >no)</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >t</span>(e(r))}<span class="cstat-no" title="statement not covered" ></span></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar uo=<span class="cstat-no" title="statement not covered" >J("prisma:client"),c</span>o=<span class="cstat-no" title="statement not covered" >{Vercel:"vercel","Netlify CI":"netlify"};f</span>unction <span class="fstat-no" title="function not covered" >mo({</span>postinstall:t,ciName:e,clientVersion:r}){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(uo("checkPlatformCaching:postinstall",t),uo("checkPlatformCaching:ciName",e),t===!0&amp;&amp;e&amp;&amp;e in co){let n=<span class="cstat-no" title="statement not covered" >`Prisma has detected that this project was built on ${e}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.</span></span>
&nbsp;
Learn how: https://pris.ly/d/${co[e]}-build`;<span class="cstat-no" title="statement not covered" >throw console.error(n),new I(n,r)}</span>}<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >po(t</span>,e){<span class="cstat-no" title="statement not covered" >return t?t.datasources?t.datasources:t.datasourceUrl?{[e[0]]:{url:t.datasourceUrl}}:{}:{}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar ul=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>lobalThis.process?.release?.name==="node",c</span></span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>!globalThis.Bun||!!globalThis.process?.versions?.bun,m</span></span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >!</span>!globalThis.Deno,</span></span>pl=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis.Netlify=="object",d</span></span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis.EdgeRuntime=="object",f</span></span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >g</span>lobalThis.navigator?.userAgent==="Cloudflare-Workers";f</span></span>unction <span class="fstat-no" title="function not covered" >gl(){<span class="cstat-no" title="statement not covered" >r</span>eturn[[pl,"netlify"],[dl,"edge-light"],[fl,"workerd"],[ml,"deno"],[cl,"bun"],[ul,"node"]].flatMap(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >r</span>[0]()?[r[1]]:[])</span>.at(0)??""}</span>var yl=<span class="cstat-no" title="statement not covered" >{node:"Node.js",workerd:"Cloudflare Workers",deno:"Deno and Deno Deploy",netlify:"Netlify Edge Functions","edge-light":"Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)"};f</span>unction <span class="fstat-no" title="function not covered" >Re(){l</span>et t=<span class="cstat-no" title="statement not covered" >gl();<span class="cstat-no" title="statement not covered" >r</span>eturn{id:t,prettyName:yl[t]||t,isEdge:["workerd","deno","netlify","edge-light"].includes(t)}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Xr(t</span>){<span class="cstat-no" title="statement not covered" >return t.name==="DriverAdapterError"&amp;&amp;typeof t.cause=="object"}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >cr(t</span>){<span class="cstat-no" title="statement not covered" >return{ok:!0,value:t,<span class="fstat-no" title="function not covered" >map(e</span>){<span class="cstat-no" title="statement not covered" >return cr(e(t))}</span>,<span class="fstat-no" title="function not covered" >flatMap(e</span>){<span class="cstat-no" title="statement not covered" >return e(t)}</span>}}</span>function <span class="fstat-no" title="function not covered" >De(t</span>){<span class="cstat-no" title="statement not covered" >return{ok:!1,error:t,<span class="fstat-no" title="function not covered" >map(){<span class="cstat-no" title="statement not covered" >r</span>eturn De(t)}</span>,<span class="fstat-no" title="function not covered" >flatMap(){<span class="cstat-no" title="statement not covered" >r</span>eturn De(t)}</span>}}</span>var fo=<span class="cstat-no" title="statement not covered" >J("driver-adapter-utils"),Z</span>r=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >registeredErrors=[];<span class="fstat-no" title="function not covered" >c</span>onsumeError(e</span>){<span class="cstat-no" title="statement not covered" >return this.registeredErrors[e]}<span class="fstat-no" title="function not covered" >r</span>egisterNewError(e</span>){let r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" >f</span>or(;this.registeredErrors[r]!==void 0;)<span class="cstat-no" title="statement not covered" >r++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.registeredErrors[r]={error:e},r}</span>};v</span>ar en=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >new Zr)</span>=&gt;{let r=<span class="cstat-no" title="statement not covered" >{adapterName:t.adapterName,errorRegistry:e,queryRaw:Ee(e,t.queryRaw.bind(t)),executeRaw:Ee(e,t.executeRaw.bind(t)),executeScript:Ee(e,t.executeScript.bind(t)),dispose:Ee(e,t.dispose.bind(t)),provider:t.provider,startTransaction:<span class="fstat-no" title="function not covered" >async(.</span>..n)=&gt;<span class="cstat-no" title="statement not covered" >(await Ee(e,t.startTransaction.bind(t))(...n)).map(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >h</span>l(e,o))}</span></span>;<span class="cstat-no" title="statement not covered" >r</span>eturn t.getConnectionInfo&amp;&amp;(r.getConnectionInfo=bl(e,t.getConnectionInfo.bind(t))),r}</span>,h</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;(<span class="cstat-no" title="statement not covered" >{adapterName:e.adapterName,provider:e.provider,options:e.options,queryRaw:Ee(t,e.queryRaw.bind(e)),executeRaw:Ee(t,e.executeRaw.bind(e)),commit:Ee(t,e.commit.bind(e)),rollback:Ee(t,e.rollback.bind(e))});f</span></span>unction <span class="fstat-no" title="function not covered" >Ee(t</span>,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >async(.</span>..r)=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return cr(await e(...r))}</span>catch(n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(fo("[error@wrapAsync]",n),Xr(n))<span class="cstat-no" title="statement not covered" >return De(n.cause);l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.registerNewError(n);<span class="cstat-no" title="statement not covered" >r</span>eturn De({kind:"GenericJs",id:i})}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >bl(t</span>,e){<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(.</span>..r)=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return cr(e(...r))}</span>catch(n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(fo("[error@wrapSync]",n),Xr(n))<span class="cstat-no" title="statement not covered" >return De(n.cause);l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.registerNewError(n);<span class="cstat-no" title="statement not covered" >r</span>eturn De({kind:"GenericJs",id:i})}</span>}</span>}</span>var go=<span class="cstat-no" title="statement not covered" >"6.8.2";<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >mr({</span>inlineDatasources:t,overrideDatasources:e,env:r,clientVersion:n}){let i,o=<span class="cstat-no" title="statement not covered" >Object.keys(t)[0],</span>s=<span class="cstat-no" title="statement not covered" >t[o]?.url,a</span>=<span class="cstat-no" title="statement not covered" >e[o]?.url;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o===void 0?i=void 0:a?i=a:s?.value?i=s.value:s?.fromEnvVar&amp;&amp;(i=r[s.fromEnvVar]),s?.fromEnvVar!==void 0&amp;&amp;i===void 0)<span class="cstat-no" title="statement not covered" >throw Re().id==="workerd"?new I(`error: Environment variable not found: ${s.fromEnvVar}.</span></span>
&nbsp;
In Cloudflare module Workers, environment variables are available only in the Worker's \`env\` parameter of \`fetch\`.
To solve this, provide the connection string directly: https://pris.ly/d/cloudflare-datasource-url`,n):new I(`error: Environment variable not found: ${s.fromEnvVar}.`,n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i===void 0)<span class="cstat-no" title="statement not covered" >throw new I("error: Missing URL environment variable, value, or override.",n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >yo(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t?.kind==="itx")<span class="cstat-no" title="statement not covered" >return t.options.id}<span class="cstat-no" title="statement not covered" >u</span></span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar tn,ho=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >async l</span>oadLibrary(t){let{clientVersion:e,adapter:r,engineWasm:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r===void 0)<span class="cstat-no" title="statement not covered" >throw new I(`The \`adapter\` option for \`PrismaClient\` is required in this context (${Re().prettyName})`,e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n===void 0)<span class="cstat-no" title="statement not covered" >throw new I("WASM engine was unexpectedly `undefined`",e);<span class="cstat-no" title="statement not covered" >t</span></span>n===void 0&amp;&amp;(tn=(<span class="fstat-no" title="function not covered" >async()=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >await n.getRuntime(),s</span>=<span class="cstat-no" title="statement not covered" >await n.getQueryEngineWasmModule();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(s==null)<span class="cstat-no" title="statement not covered" >throw new I("The loaded wasm module was unexpectedly `undefined` or `null` once loaded",e);l</span></span>et a=<span class="cstat-no" title="statement not covered" >{"./query_engine_bg.js":o},f</span>=<span class="cstat-no" title="statement not covered" >new WebAssembly.Instance(s,a),h</span>=<span class="cstat-no" title="statement not covered" >f.exports.__wbindgen_start;<span class="cstat-no" title="statement not covered" ></span>return o.__wbg_set_wasm(f.exports),h(),o.QueryEngine})()</span>);l</span>et i=<span class="cstat-no" title="statement not covered" >await tn;<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >debugPanic(){<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.reject("{}")}</span>,<span class="fstat-no" title="function not covered" >dmmf(){<span class="cstat-no" title="statement not covered" >r</span>eturn Promise.resolve("{}")}</span>,<span class="fstat-no" title="function not covered" >version(){<span class="cstat-no" title="statement not covered" >r</span>eturn{commit:"unknown",version:"unknown"}}</span>,QueryEngine:i}}</span>};v</span>ar xl=<span class="cstat-no" title="statement not covered" >"P2036",y</span>e=<span class="cstat-no" title="statement not covered" >J("prisma:client:libraryEngine");f</span>unction <span class="fstat-no" title="function not covered" >El(t</span>){<span class="cstat-no" title="statement not covered" >return t.item_type==="query"&amp;&amp;"query"in t}</span>function <span class="fstat-no" title="function not covered" >Pl(t</span>){<span class="cstat-no" title="statement not covered" >return"level"in t?t.level==="error"&amp;&amp;t.message==="PANIC":!1}</span>var OS=<span class="cstat-no" title="statement not covered" >[...kr,"native"],v</span>l=<span class="cstat-no" title="statement not covered" >0xffffffffffffffffn,</span>rn=<span class="cstat-no" title="statement not covered" >1n;</span>function <span class="fstat-no" title="function not covered" >Tl(){l</span>et t=<span class="cstat-no" title="statement not covered" >rn++;<span class="cstat-no" title="statement not covered" >r</span>eturn rn&gt;vl&amp;&amp;(rn=1n),t}</span>var Rt=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >name="LibraryEngine";engine;libraryInstantiationPromise;libraryStartingPromise;libraryStoppingPromise;libraryStarted;executingQueryPromise;config;QueryEngineConstructor;libraryLoader;library;logEmitter;libQueryEnginePath;binaryTarget;datasourceOverrides;datamodel;logQueries;logLevel;lastQuery;loggerRustPanic;tracingHelper;adapterPromise;versionInfo;<span class="fstat-no" title="function not covered" >c</span>onstructor(e</span>,r){<span class="cstat-no" title="statement not covered" >this.libraryLoader=r??ho,this.config=e,this.libraryStarted=!1,this.logQueries=e.logQueries??!1,this.logLevel=e.logLevel??"error",this.logEmitter=e.logEmitter,this.datamodel=e.inlineSchema,this.tracingHelper=e.tracingHelper,e.enableDebugLogs&amp;&amp;(this.logLevel="debug");l</span>et n=<span class="cstat-no" title="statement not covered" >Object.keys(e.overrideDatasources)[0],</span>i=<span class="cstat-no" title="statement not covered" >e.overrideDatasources[n]?.url;<span class="cstat-no" title="statement not covered" >n</span>!==void 0&amp;&amp;i!==void 0&amp;&amp;(this.datasourceOverrides={[n]:i}),this.libraryInstantiationPromise=this.instantiateLibrary()}<span class="fstat-no" title="function not covered" ></span>wrapEngine(e</span>){<span class="cstat-no" title="statement not covered" >return{applyPendingMigrations:e.applyPendingMigrations?.bind(e),commitTransaction:this.withRequestId(e.commitTransaction.bind(e)),connect:this.withRequestId(e.connect.bind(e)),disconnect:this.withRequestId(e.disconnect.bind(e)),metrics:e.metrics?.bind(e),query:this.withRequestId(e.query.bind(e)),rollbackTransaction:this.withRequestId(e.rollbackTransaction.bind(e)),sdlSchema:e.sdlSchema?.bind(e),startTransaction:this.withRequestId(e.startTransaction.bind(e)),trace:e.trace.bind(e)}}<span class="fstat-no" title="function not covered" ></span>withRequestId(e</span>){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >async(.</span>..r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >Tl().toString();<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return await e(...r,n)}</span>finally{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(this.tracingHelper.isEnabled()){let i=<span class="cstat-no" title="statement not covered" >await this.engine?.trace(n);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(i){let o=<span class="cstat-no" title="statement not covered" >JSON.parse(i);<span class="cstat-no" title="statement not covered" >t</span>his.tracingHelper.dispatchEngineSpans(o.spans)}</span>}</span>}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>async a</span>pplyPendingMigrations(){<span class="cstat-no" title="statement not covered" >throw new Error("Cannot call this method from this type of engine instance")}<span class="fstat-no" title="function not covered" ></span>async t</span>ransaction(e,r,n){<span class="cstat-no" title="statement not covered" >await this.start();l</span>et i=<span class="cstat-no" title="statement not covered" >await this.adapterPromise,</span>o=<span class="cstat-no" title="statement not covered" >JSON.stringify(r),s</span>;<span class="cstat-no" title="statement not covered" >if(e==="start"){let f=<span class="cstat-no" title="statement not covered" >JSON.stringify({max_wait:n.maxWait,timeout:n.timeout,isolation_level:n.isolationLevel});<span class="cstat-no" title="statement not covered" >s</span>=await this.engine?.startTransaction(f,o)}</span>else <span class="cstat-no" title="statement not covered" >e==="commit"?s=await this.engine?.commitTransaction(n.id,o):e==="rollback"&amp;&amp;(s=await this.engine?.rollbackTransaction(n.id,o));l</span></span>et a=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(s);<span class="cstat-no" title="statement not covered" >i</span>f(Cl(a)){let f=<span class="cstat-no" title="statement not covered" >this.getExternalAdapterError(a,i?.errorRegistry);<span class="cstat-no" title="statement not covered" >t</span>hrow f?f.error:new X(a.message,{code:a.error_code,clientVersion:this.config.clientVersion,meta:a.meta})}</span>else <span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof a.message=="string")<span class="cstat-no" title="statement not covered" >throw new j(a.message,{clientVersion:this.config.clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn a}<span class="fstat-no" title="function not covered" ></span>async i</span>nstantiateLibrary(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(ye("internalSetup"),this.libraryInstantiationPromise)<span class="cstat-no" title="statement not covered" >return this.libraryInstantiationPromise;<span class="cstat-no" title="statement not covered" >t</span></span>his.binaryTarget=await this.getCurrentBinaryTarget(),await this.tracingHelper.runInChildSpan("load_engine",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.loadEngine()),t</span>his.version()}<span class="fstat-no" title="function not covered" ></span>async g</span>etCurrentBinaryTarget(){}<span class="fstat-no" title="function not covered" >parseEngineResponse(e</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e)<span class="cstat-no" title="statement not covered" >throw new j("Response from the Engine was empty",{clientVersion:this.config.clientVersion});<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return JSON.parse(e)}</span>catch{<span class="cstat-no" title="statement not covered" >throw new j("Unable to JSON.parse response from engine",{clientVersion:this.config.clientVersion})}</span>}<span class="fstat-no" title="function not covered" ></span>async l</span>oadEngine(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!this.engine){<span class="cstat-no" title="statement not covered" >this.QueryEngineConstructor||(this.library=await this.libraryLoader.loadLibrary(this.config),this.QueryEngineConstructor=this.library.QueryEngine</span>);<span class="cstat-no" title="statement not covered" >try{let e=<span class="cstat-no" title="statement not covered" >new w(this);<span class="cstat-no" title="statement not covered" >t</span>his.adapterPromise||(this.adapterPromise=this.config.adapter?.connect()?.then(en));l</span>et r=<span class="cstat-no" title="statement not covered" >await this.adapterPromise;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;ye("Using driver adapter: %O",r),this.engine=this.wrapEngine(new this.QueryEngineConstructor({datamodel:this.datamodel,env:g.env,logQueries:this.config.logQueries??!1,ignoreEnvVarErrors:!0,datasourceOverrides:this.datasourceOverrides??{},logLevel:this.logLevel,configDir:this.config.cwd,engineProtocol:"json",enableTracing:this.tracingHelper.isEnabled()},<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >e</span>.deref()?.logger(n)}</span>,r))}</span>catch(e){let r=<span class="cstat-no" title="statement not covered" >e,n</span>=<span class="cstat-no" title="statement not covered" >this.parseInitError(r.message);<span class="cstat-no" title="statement not covered" >t</span>hrow typeof n=="string"?r:new I(n.message,this.config.clientVersion,n.error_code)}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>logger(e</span>){let r=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(e);<span class="cstat-no" title="statement not covered" >r</span>&amp;&amp;(r.level=r?.level.toLowerCase()??"unknown",El(r)?this.logEmitter.emit("query",{timestamp:new Date,query:r.query,params:r.params,duration:Number(r.duration_ms),target:r.module_path}):(Pl(r),this.logEmitter.emit(r.level,{timestamp:new Date,message:r.message,target:r.module_path})))}<span class="fstat-no" title="function not covered" ></span>parseInitError(e</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(e)}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>parseRequestError(e</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(e)}</span>catch{}<span class="cstat-no" title="statement not covered" >r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>onBeforeExit(){<span class="cstat-no" title="statement not covered" ></span>throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.')}<span class="fstat-no" title="function not covered" ></span>async s</span>tart(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(await this.libraryInstantiationPromise,await this.libraryStoppingPromise,this.libraryStartingPromise)<span class="cstat-no" title="statement not covered" >return ye(`library already starting, this.libraryStarted: ${this.libraryStarted}`),this.libraryStartingPromise;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(this.libraryStarted)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >async()=&gt;{<span class="cstat-no" title="statement not covered" >y</span>e("library starting");<span class="cstat-no" title="statement not covered" >t</span>ry{let r=<span class="cstat-no" title="statement not covered" >{traceparent:this.tracingHelper.getTraceParent()};<span class="cstat-no" title="statement not covered" >a</span>wait this.engine?.connect(JSON.stringify(r)),this.libraryStarted=!0,ye("library started")}</span>catch(r){let n=<span class="cstat-no" title="statement not covered" >this.parseInitError(r.message);<span class="cstat-no" title="statement not covered" >t</span>hrow typeof n=="string"?r:new I(n.message,this.config.clientVersion,n.error_code)}</span>finally{<span class="cstat-no" title="statement not covered" >this.libraryStartingPromise=void 0}</span>}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this.libraryStartingPromise=this.tracingHelper.runInChildSpan("connect",e),this.libraryStartingPromise}<span class="fstat-no" title="function not covered" >a</span>sync s</span>top(){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(await this.libraryInstantiationPromise,await this.libraryStartingPromise,await this.executingQueryPromise,this.libraryStoppingPromise)<span class="cstat-no" title="statement not covered" >return ye("library is already stopping"),this.libraryStoppingPromise;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!this.libraryStarted)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >async()=&gt;{<span class="cstat-no" title="statement not covered" >a</span>wait new Promise(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >s</span>etTimeout(n,5)),y</span>e("library stopping");l</span>et r=<span class="cstat-no" title="statement not covered" >{traceparent:this.tracingHelper.getTraceParent()};<span class="cstat-no" title="statement not covered" >a</span>wait this.engine?.disconnect(JSON.stringify(r)),this.libraryStarted=!1,this.libraryStoppingPromise=void 0,await(await this.adapterPromise)?.dispose(),this.adapterPromise=void 0,ye("library stopped")}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this.libraryStoppingPromise=this.tracingHelper.runInChildSpan("disconnect",e),this.libraryStoppingPromise}<span class="fstat-no" title="function not covered" >v</span>ersion(){<span class="cstat-no" title="statement not covered" ></span>return this.versionInfo=this.library?.version(),this.versionInfo?.version??"unknown"}<span class="fstat-no" title="function not covered" ></span>debugPanic(e</span>){<span class="cstat-no" title="statement not covered" >return this.library?.debugPanic(e)}<span class="fstat-no" title="function not covered" ></span>async r</span>equest(e,{traceparent:r,interactiveTransaction:n}){<span class="cstat-no" title="statement not covered" >ye(`sending request, this.libraryStarted: ${this.libraryStarted}`);l</span>et i=<span class="cstat-no" title="statement not covered" >JSON.stringify({traceparent:r}),o</span>=<span class="cstat-no" title="statement not covered" >JSON.stringify(e);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >await this.start();l</span>et s=<span class="cstat-no" title="statement not covered" >await this.adapterPromise;<span class="cstat-no" title="statement not covered" ></span>this.executingQueryPromise=this.engine?.query(o,i,n?.id),this.lastQuery=o;l</span>et a=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(await this.executingQueryPromise);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a.errors)<span class="cstat-no" title="statement not covered" >throw a.errors.length===1?this.buildQueryError(a.errors[0],s?.errorRegistry):new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(this.loggerRustPanic)<span class="cstat-no" title="statement not covered" >throw this.loggerRustPanic;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{data:a}}</span>catch(s){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s instanceof I)<span class="cstat-no" title="statement not covered" >throw s;<span class="cstat-no" title="statement not covered" >s</span></span>.code==="GenericFailure"&amp;&amp;s.message?.startsWith("PANIC:");l</span>et a=<span class="cstat-no" title="statement not covered" >this.parseRequestError(s.message);<span class="cstat-no" title="statement not covered" >t</span>hrow typeof a=="string"?s:new j(`${a.message}</span></span></span>
${a.backtrace}`,{clientVersion:this.config.clientVersion})}}<span class="fstat-no" title="function not covered" >async r</span>equestBatch(e,{transaction:r,traceparent:n}){<span class="cstat-no" title="statement not covered" >ye("requestBatch");l</span>et i=<span class="cstat-no" title="statement not covered" >sr(e,r);<span class="cstat-no" title="statement not covered" >a</span>wait this.start();l</span>et o=<span class="cstat-no" title="statement not covered" >await this.adapterPromise;<span class="cstat-no" title="statement not covered" ></span>this.lastQuery=JSON.stringify(i),this.executingQueryPromise=this.engine.query(this.lastQuery,JSON.stringify({traceparent:n}),yo(r));l</span>et s=<span class="cstat-no" title="statement not covered" >await this.executingQueryPromise,</span>a=<span class="cstat-no" title="statement not covered" >this.parseEngineResponse(s);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(a.errors)<span class="cstat-no" title="statement not covered" >throw a.errors.length===1?this.buildQueryError(a.errors[0],o?.errorRegistry):new j(JSON.stringify(a.errors),{clientVersion:this.config.clientVersion});l</span></span>et{batchResult:f,errors:h}=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(Array.isArray(f))<span class="cstat-no" title="statement not covered" >return f.map(<span class="fstat-no" title="function not covered" >T=&gt;<span class="cstat-no" title="statement not covered" >T</span>.errors&amp;&amp;T.errors.length&gt;0?this.loggerRustPanic??this.buildQueryError(T.errors[0],o?.errorRegistry):{data:T});<span class="cstat-no" title="statement not covered" >t</span></span></span>hrow h&amp;&amp;h.length===1?new Error(h[0].error):new Error(JSON.stringify(a))}<span class="fstat-no" title="function not covered" ></span>buildQueryError(e</span>,r){<span class="cstat-no" title="statement not covered" >e.user_facing_error.is_panic;l</span>et n=<span class="cstat-no" title="statement not covered" >this.getExternalAdapterError(e.user_facing_error,r);<span class="cstat-no" title="statement not covered" >r</span>eturn n?n.error:ar(e,this.config.clientVersion,this.config.activeProvider)}<span class="fstat-no" title="function not covered" ></span>getExternalAdapterError(e</span>,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.error_code===xl&amp;&amp;r){let n=<span class="cstat-no" title="statement not covered" >e.meta?.id;<span class="cstat-no" title="statement not covered" >q</span>t(typeof n=="number","Malformed external JS error received from the engine");l</span>et i=<span class="cstat-no" title="statement not covered" >r.consumeError(n);<span class="cstat-no" title="statement not covered" >r</span>eturn qt(i,"External error with reported id was not registered"),i}</span>}<span class="fstat-no" title="function not covered" ></span>async m</span>etrics(e){<span class="cstat-no" title="statement not covered" >await this.start();l</span>et r=<span class="cstat-no" title="statement not covered" >await this.engine.metrics(JSON.stringify(e));<span class="cstat-no" title="statement not covered" >r</span>eturn e.format==="prometheus"?r:this.parseEngineResponse(r)}</span>};function <span class="fstat-no" title="function not covered" >Cl(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t=="object"&amp;&amp;t!==null&amp;&amp;t.error_code!==void 0}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar At=<span class="cstat-no" title="statement not covered" >"Accelerate has not been setup correctly. Make sure your client is using `.$extends(withAccelerate())`. See https://pris.ly/d/accelerate-getting-started",p</span>r=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.config=e;<span class="cstat-no" title="statement not covered" >t</span>his.resolveDatasourceUrl=this.config.accelerateUtils?.resolveDatasourceUrl,this.getBatchRequestPayload=this.config.accelerateUtils?.getBatchRequestPayload,this.prismaGraphQLToJSError=this.config.accelerateUtils?.prismaGraphQLToJSError,this.PrismaClientUnknownRequestError=this.config.accelerateUtils?.PrismaClientUnknownRequestError,this.PrismaClientInitializationError=this.config.accelerateUtils?.PrismaClientInitializationError,this.PrismaClientKnownRequestError=this.config.accelerateUtils?.PrismaClientKnownRequestError,this.debug=this.config.accelerateUtils?.debug,this.engineVersion=this.config.accelerateUtils?.engineVersion,this.clientVersion=this.config.accelerateUtils?.clientVersion}<span class="cstat-no" title="statement not covered" ></span>name="AccelerateEngine";resolveDatasourceUrl;getBatchRequestPayload;prismaGraphQLToJSError;PrismaClientUnknownRequestError;PrismaClientInitializationError;PrismaClientKnownRequestError;debug;engineVersion;clientVersion;<span class="fstat-no" title="function not covered" >o</span>nBeforeExit(e</span>){}<span class="fstat-no" title="function not covered" >async s</span>tart(){}<span class="fstat-no" title="function not covered" >async s</span>top(){}<span class="fstat-no" title="function not covered" >version(e</span>){<span class="cstat-no" title="statement not covered" >return"unknown"}<span class="fstat-no" title="function not covered" ></span>transaction(e</span>,r,n){<span class="cstat-no" title="statement not covered" >throw new I(At,this.config.clientVersion)}<span class="fstat-no" title="function not covered" ></span>metrics(e</span>){<span class="cstat-no" title="statement not covered" >throw new I(At,this.config.clientVersion)}<span class="fstat-no" title="function not covered" ></span>request(e</span>,r){<span class="cstat-no" title="statement not covered" >throw new I(At,this.config.clientVersion)}<span class="fstat-no" title="function not covered" ></span>requestBatch(e</span>,r){<span class="cstat-no" title="statement not covered" >throw new I(At,this.config.clientVersion)}<span class="fstat-no" title="function not covered" ></span>applyPendingMigrations(){<span class="cstat-no" title="statement not covered" ></span>throw new I(At,this.config.clientVersion)}</span>};f</span>unction <span class="fstat-no" title="function not covered" >bo({</span>copyEngine:t=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>,e){let r;<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r=mr({inlineDatasources:e.inlineDatasources,overrideDatasources:e.overrideDatasources,env:{...e.env,...g.env},clientVersion:e.clientVersion})}</span>catch{}l</span>et n=<span class="cstat-no" title="statement not covered" >!!(r?.startsWith("prisma://")||Mr(r));<span class="cstat-no" title="statement not covered" >t</span>&amp;&amp;n&amp;&amp;lt("recommend--no-engine","In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");l</span>et i=<span class="cstat-no" title="statement not covered" >Ue(e.generator),o</span>=<span class="cstat-no" title="statement not covered" >n||!t,s</span>=<span class="cstat-no" title="statement not covered" >!!e.adapter,</span>a=<span class="cstat-no" title="statement not covered" >i==="library",f</span>=<span class="cstat-no" title="statement not covered" >i==="binary",h</span>=<span class="cstat-no" title="statement not covered" >i==="client";<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(o&amp;&amp;s||s&amp;&amp;!1){let T;<span class="cstat-no" title="statement not covered" >throw t?r?.startsWith("prisma://")?T=["Prisma Client was configured to use the `adapter` option but the URL was a `prisma://` URL.","Please either use the `prisma://` URL or remove the `adapter` from the Prisma Client constructor."]:T=["Prisma Client was configured to use both the `adapter` and Accelerate, please chose one."]:T=["Prisma Client was configured to use the `adapter` option but `prisma generate` was run with `--no-engine`.","Please run `prisma generate` without `--no-engine` to be able to use Prisma Client with the adapter."],new W(T.join(`</span></span>
`),{clientVersion:e.clientVersion})}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(s)<span class="cstat-no" title="statement not covered" >return new Rt(e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(o)<span class="cstat-no" title="statement not covered" >return new pr(e);{</span></span>let T=<span class="cstat-no" title="statement not covered" >[`PrismaClient failed to initialize because it wasn't configured to run in this environment (${Re().prettyName}).`,"In order to run Prisma Client in an edge runtime, you will need to configure one of the following options:","- Enable Driver Adapters: https://pris.ly/d/driver-adapters","- Enable Accelerate: https://pris.ly/d/accelerate"];<span class="cstat-no" title="statement not covered" >t</span>hrow new W(T.join(`</span>
`),{clientVersion:e.clientVersion})}<span class="cstat-no" title="statement not covered" >return"wasm"}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >dr({</span>generator:t}){<span class="cstat-no" title="statement not covered" >return t?.previewFeatures??[]}<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar wo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;(<span class="cstat-no" title="statement not covered" >{</span>command:t});<span class="cstat-no" title="statement not covered" >u</span></span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar xo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>.strings.reduce(<span class="fstat-no" title="function not covered" >(e</span>,r,n)=&gt;<span class="cstat-no" title="statement not covered" >`${e}@P${n}${r}`)</span>;<span class="cstat-no" title="statement not covered" >u</span></span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >et(t</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Eo(t,"fast")}</span>catch{<span class="cstat-no" title="statement not covered" >return Eo(t,"slow")}</span>}</span>function <span class="fstat-no" title="function not covered" >Eo(t</span>,e){<span class="cstat-no" title="statement not covered" >return JSON.stringify(t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >v</span>o(r,e)))}</span></span>function <span class="fstat-no" title="function not covered" >vo(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return t.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >v</span>o(r,e));<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span></span>f(typeof t=="bigint")<span class="cstat-no" title="statement not covered" >return{prisma__type:"bigint",prisma__value:t.toString()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Ve(t))<span class="cstat-no" title="statement not covered" >return{prisma__type:"date",prisma__value:t.toJSON()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ae.isDecimal(t))<span class="cstat-no" title="statement not covered" >return{prisma__type:"decimal",prisma__value:t.toJSON()};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(b.isBuffer(t))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:t.toString("base64")};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Rl(t))<span class="cstat-no" title="statement not covered" >return{prisma__type:"bytes",prisma__value:b.from(t).toString("base64")};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(ArrayBuffer.isView(t)){let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >r</span>eturn{prisma__type:"bytes",prisma__value:b.from(r,n,i).toString("base64")}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn typeof t=="object"&amp;&amp;e==="slow"?To(t):t}</span>function <span class="fstat-no" title="function not covered" >Rl(t</span>){<span class="cstat-no" title="statement not covered" >return t instanceof ArrayBuffer||t instanceof SharedArrayBuffer?!0:typeof t=="object"&amp;&amp;t!==null?t[Symbol.toStringTag]==="ArrayBuffer"||t[Symbol.toStringTag]==="SharedArrayBuffer":!1}</span>function <span class="fstat-no" title="function not covered" >To(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="object"||t===null)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(typeof t.toJSON=="function")<span class="cstat-no" title="statement not covered" >return t.toJSON();<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(t))<span class="cstat-no" title="statement not covered" >return t.map(Po);l</span></span>et e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r of Object.keys(t))<span class="cstat-no" title="statement not covered" >e[r]=Po(t[r]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Po(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t=="bigint"?t.toString():To(t)}</span>var Al=<span class="cstat-no" title="statement not covered" >/^(\s*alter\s)/i,C</span>o=<span class="cstat-no" title="statement not covered" >J("prisma:client");f</span>unction <span class="fstat-no" title="function not covered" >nn(t</span>,e,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!(t!=="postgresql"&amp;&amp;t!=="cockroachdb")&amp;&amp;r.length&gt;0&amp;&amp;Al.exec(e))<span class="cstat-no" title="statement not covered" >throw new Error(`Running ALTER using ${n} is not supported</span></span>
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.
&nbsp;
Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)
&nbsp;
More Information: https://pris.ly/d/execute-raw
`)}var on=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>clientMethod:t,activeProvider:e})=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >r=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >"",i</span>;<span class="cstat-no" title="statement not covered" >if(rr(r))<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:et(r.values),__prismaRawParameters__:!0};else <span class="cstat-no" title="statement not covered" >i</span>f(Array.isArray(r)){let[o,...s]=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" >n</span>=o,i={values:et(s||[]),__prismaRawParameters__:!0}}</span>else <span class="cstat-no" title="statement not covered" >switch(e){case"sqlite":case"mysql":{<span class="cstat-no" title="statement not covered" >n=r.sql,i={values:et(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"cockroachdb":case"postgresql":case"postgres":{<span class="cstat-no" title="statement not covered" >n=r.text,i={values:et(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>case"sqlserver":{<span class="cstat-no" title="statement not covered" >n=xo(r),i={values:et(r.values),__prismaRawParameters__:!0};<span class="cstat-no" title="statement not covered" >b</span>reak}</span>default:<span class="cstat-no" title="statement not covered" >throw new Error(`The ${e} provider does not support ${t}`)}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn i?.values?Co(`prisma.${t}(${n}, ${i.values})`):Co(`prisma.${t}(${n})`),{query:n,parameters:i}}</span>,R</span></span>o=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(t</span>){<span class="cstat-no" title="statement not covered" >return[t.strings,...t.values]},<span class="fstat-no" title="function not covered" >m</span>iddlewareArgsToRequestArgs(t</span>){let[e,...r]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" >r</span>eturn new Z(e,r)}</span>},A</span>o=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >requestArgsToMiddlewareArgs(t</span>){<span class="cstat-no" title="statement not covered" >return[t]},<span class="fstat-no" title="function not covered" >m</span>iddlewareArgsToRequestArgs(t</span>){<span class="cstat-no" title="statement not covered" >return t[0]}}</span>;<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >sn(t</span>){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >function(r</span>,n){let i,o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>=<span class="branch-0 cbranch-no" title="branch not covered" >t)</span>=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return s===void 0||s?.kind==="itx"?i??=So(r(s)):So(r(s))}</span>catch(a){<span class="cstat-no" title="statement not covered" >return Promise.reject(a)}</span>}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn{<span class="fstat-no" title="function not covered" >get s</span>pec(){<span class="cstat-no" title="statement not covered" >return n}</span>,<span class="fstat-no" title="function not covered" >then(s</span>,a){<span class="cstat-no" title="statement not covered" >return o().then(s,a)}</span>,<span class="fstat-no" title="function not covered" >catch(s</span>){<span class="cstat-no" title="statement not covered" >return o().catch(s)}</span>,<span class="fstat-no" title="function not covered" >finally(s</span>){<span class="cstat-no" title="statement not covered" >return o().finally(s)}</span>,<span class="fstat-no" title="function not covered" >requestTransaction(s</span>){let a=<span class="cstat-no" title="statement not covered" >o(s);<span class="cstat-no" title="statement not covered" >r</span>eturn a.requestTransaction?a.requestTransaction(s):a}</span>,[Symbol.toStringTag]:"PrismaPromise"}}</span>}</span>function <span class="fstat-no" title="function not covered" >So(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t.then=="function"?t:Promise.resolve(t)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Sl=<span class="cstat-no" title="statement not covered" >Or.split(".")[0],</span>kl=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >isEnabled(){<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>,<span class="fstat-no" title="function not covered" >getTraceParent(){<span class="cstat-no" title="statement not covered" >r</span>eturn"00-10-10-00"}</span>,<span class="fstat-no" title="function not covered" >dispatchEngineSpans(){}</span>,<span class="fstat-no" title="function not covered" >getActiveContext(){}</span>,<span class="fstat-no" title="function not covered" >runInChildSpan(t</span>,e){<span class="cstat-no" title="statement not covered" >return e()}</span>},a</span>n=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >isEnabled(){<span class="cstat-no" title="statement not covered" ></span>return this.getGlobalTracingHelper().isEnabled()}<span class="fstat-no" title="function not covered" ></span>getTraceParent(e</span>){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().getTraceParent(e)}<span class="fstat-no" title="function not covered" ></span>dispatchEngineSpans(e</span>){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().dispatchEngineSpans(e)}<span class="fstat-no" title="function not covered" ></span>getActiveContext(){<span class="cstat-no" title="statement not covered" ></span>return this.getGlobalTracingHelper().getActiveContext()}<span class="fstat-no" title="function not covered" ></span>runInChildSpan(e</span>,r){<span class="cstat-no" title="statement not covered" >return this.getGlobalTracingHelper().runInChildSpan(e,r)}<span class="fstat-no" title="function not covered" ></span>getGlobalTracingHelper(){</span>let e=<span class="cstat-no" title="statement not covered" >globalThis[`V${Sl}_PRISMA_INSTRUMENTATION`],</span>r=<span class="cstat-no" title="statement not covered" >globalThis.PRISMA_INSTRUMENTATION;<span class="cstat-no" title="statement not covered" ></span>return e?.helper??r?.helper??kl}</span>};f</span>unction <span class="fstat-no" title="function not covered" >ko(){<span class="cstat-no" title="statement not covered" >r</span>eturn new an}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Oo(t</span>,e=<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()=&gt;{}</span>)</span>{let r,n=<span class="cstat-no" title="statement not covered" >new Promise(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >r</span>=i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{<span class="fstat-no" title="function not covered" >then(i</span>){<span class="cstat-no" title="statement not covered" >return--t===0&amp;&amp;r(e()),i?.(n)}</span>}}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Mo(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t=="string"?t:t.reduce(<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >typeof r=="string"?r:r.level;<span class="cstat-no" title="statement not covered" ></span>return n==="query"?e:e&amp;&amp;(r==="info"||e==="info")?"info":n}</span>,void 0)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar fr=<span class="cstat-no" title="statement not covered" >class{<span class="cstat-no" title="statement not covered" >_middlewares=[];<span class="fstat-no" title="function not covered" >u</span>se(e</span>){<span class="cstat-no" title="statement not covered" >this._middlewares.push(e)}<span class="fstat-no" title="function not covered" ></span>get(e</span>){<span class="cstat-no" title="statement not covered" >return this._middlewares[e]}<span class="fstat-no" title="function not covered" >h</span>as(e</span>){<span class="cstat-no" title="statement not covered" >return!!this._middlewares[e]}<span class="fstat-no" title="function not covered" >l</span>ength(){<span class="cstat-no" title="statement not covered" ></span>return this._middlewares.length}}</span>;<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Do=<span class="cstat-no" title="statement not covered" >nt(Zn());<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >gr(t</span>){<span class="cstat-no" title="statement not covered" >return typeof t.batchRequestIdx=="number"}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >Io(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.action!=="findUnique"&amp;&amp;t.action!=="findUniqueOrThrow")<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return t.modelName&amp;&amp;e.push(t.modelName),t.query.arguments&amp;&amp;e.push(ln(t.query.arguments)),e.push(ln(t.query.selection)),e.join("")}</span>function <span class="fstat-no" title="function not covered" >ln(t</span>){<span class="cstat-no" title="statement not covered" >return`(${Object.keys(t).sort().map(<span class="fstat-no" title="function not covered" >r=&gt;{l</span>et n=<span class="cstat-no" title="statement not covered" >t[r];<span class="cstat-no" title="statement not covered" ></span>return typeof n=="object"&amp;&amp;n!==null?`(${r} ${ln(n)})`:r}</span>).join(" ")})`}<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ol=<span class="cstat-no" title="statement not covered" >{aggregate:!1,aggregateRaw:!1,createMany:!0,createManyAndReturn:!0,createOne:!0,deleteMany:!0,deleteOne:!0,executeRaw:!0,findFirst:!1,findFirstOrThrow:!1,findMany:!1,findRaw:!1,findUnique:!1,findUniqueOrThrow:!1,groupBy:!1,queryRaw:!1,runCommandRaw:!0,updateMany:!0,updateManyAndReturn:!0,updateOne:!0,upsertOne:!0};f</span>unction <span class="fstat-no" title="function not covered" >un(t</span>){<span class="cstat-no" title="statement not covered" >return Ol[t]}<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar yr=<span class="cstat-no" title="statement not covered" >class{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >this.options=e;<span class="cstat-no" title="statement not covered" >t</span>his.batches={}}</span>batches;<span class="cstat-no" title="statement not covered" >tickActive=!1;<span class="fstat-no" title="function not covered" >r</span>equest(e</span>){let r=<span class="cstat-no" title="statement not covered" >this.options.batchBy(e);<span class="cstat-no" title="statement not covered" >r</span>eturn r?(this.batches[r]||(this.batches[r]=[],this.tickActive||(this.tickActive=!0,g.nextTick(<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>his.dispatchBatches(),this.tickActive=!1}</span>))),new Promise(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >this.batches[r].push({request:e,resolve:n,reject:i})}</span>)):this.options.singleLoader(e)}<span class="fstat-no" title="function not covered" ></span>dispatchBatches(){<span class="cstat-no" title="statement not covered" ></span>for(let e in this.batches){let r=<span class="cstat-no" title="statement not covered" >this.batches[e];<span class="cstat-no" title="statement not covered" ></span>delete this.batches[e],r.length===1?this.options.singleLoader(r[0].request).then(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >n</span> instanceof Error?r[0].reject(n):r[0].resolve(n)}</span>).catch(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >r</span>[0].reject(n)}</span>):(r.sort(<span class="fstat-no" title="function not covered" >(n</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >this.options.batchOrder(n.request,i.request)),t</span>his.options.batchLoader(r.map(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.request)</span>).then(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >i</span>f(n instanceof Error)<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n);else <span class="cstat-no" title="statement not covered" >f</span></span>or(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;r.length;i++){let o=<span class="cstat-no" title="statement not covered" >n[i];<span class="cstat-no" title="statement not covered" ></span>o instanceof Error?r[i].reject(o):r[i].resolve(o)}</span>}</span></span>).catch(<span class="fstat-no" title="function not covered" >n=&gt;{<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;i</span>&lt;r.length;i++)<span class="cstat-no" title="statement not covered" >r[i].reject(n)}</span></span>))}</span>}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"DataLoader"}</span>};<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >_e(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e===null)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >s</span></span>witch(t){case"bigint":<span class="cstat-no" title="statement not covered" >return BigInt(e);c</span>ase"bytes":{let{buffer:r,byteOffset:n,byteLength:i}=<span class="cstat-no" title="statement not covered" >b.from(e,"base64");<span class="cstat-no" title="statement not covered" >r</span>eturn new Uint8Array(r,n,i)}</span>case"decimal":<span class="cstat-no" title="statement not covered" >return new ae(e);c</span>ase"datetime":case"date":<span class="cstat-no" title="statement not covered" >return new Date(e);c</span>ase"time":<span class="cstat-no" title="statement not covered" >return new Date(`1970-01-01T${e}Z`);c</span>ase"bigint-array":<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >_</span>e("bigint",r));c</span></span>ase"bytes-array":<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >_</span>e("bytes",r));c</span></span>ase"decimal-array":<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >_</span>e("decimal",r));c</span></span>ase"datetime-array":<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >_</span>e("datetime",r));c</span></span>ase"date-array":<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >_</span>e("date",r));c</span></span>ase"time-array":<span class="cstat-no" title="statement not covered" >return e.map(<span class="fstat-no" title="function not covered" >r=&gt;<span class="cstat-no" title="statement not covered" >_</span>e("time",r));d</span></span>efault:<span class="cstat-no" title="statement not covered" >return e}</span>}</span>function <span class="fstat-no" title="function not covered" >hr(t</span>){let e=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >Ml(t);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;n</span>&lt;t.rows.length;n++){let i=<span class="cstat-no" title="statement not covered" >t.rows[n],</span>o=<span class="cstat-no" title="statement not covered" >{...r};<span class="cstat-no" title="statement not covered" >f</span>or(let s=<span class="cstat-no" title="statement not covered" >0;s</span>&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >o[t.columns[s]]=_e(t.types[s],i[s]);<span class="cstat-no" title="statement not covered" >e</span></span>.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Ml(t</span>){let e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;r</span>&lt;t.columns.length;r++)<span class="cstat-no" title="statement not covered" >e[t.columns[r]]=null;<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>var Il=<span class="cstat-no" title="statement not covered" >J("prisma:client:request_handler"),b</span>r=<span class="cstat-no" title="statement not covered" >class{client;dataloader;logEmitter;<span class="fstat-no" title="function not covered" >constructor(e</span>,r){<span class="cstat-no" title="statement not covered" >this.logEmitter=r,this.client=e,this.dataloader=new yr({batchLoader:so(<span class="fstat-no" title="function not covered" >async({</span>requests:n,customDataProxyFetch:i})=&gt;{let{transaction:o,otelParentCtx:s}=<span class="cstat-no" title="statement not covered" >n[0],</span>a=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >C=&gt;<span class="cstat-no" title="statement not covered" >C</span>.protocolQuery)</span>,f</span>=<span class="cstat-no" title="statement not covered" >this.client._tracingHelper.getTraceParent(s),h</span>=<span class="cstat-no" title="statement not covered" >n.some(<span class="fstat-no" title="function not covered" >C=&gt;<span class="cstat-no" title="statement not covered" >u</span>n(C.protocolQuery.action));<span class="cstat-no" title="statement not covered" >r</span></span>eturn(await this.client._engine.requestBatch(a,{traceparent:f,transaction:Dl(o),containsWrite:h,customDataProxyFetch:i})).map(<span class="fstat-no" title="function not covered" >(C</span>,k)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(C instanceof Error)<span class="cstat-no" title="statement not covered" >return C;<span class="cstat-no" title="statement not covered" >t</span></span>ry{<span class="cstat-no" title="statement not covered" >return this.mapQueryEngineResult(n[k],C)}</span>catch(A){<span class="cstat-no" title="statement not covered" >return A}</span>}</span>)}</span>),singleLoader:<span class="fstat-no" title="function not covered" >async n</span>=&gt;{let i=<span class="cstat-no" title="statement not covered" >n.transaction?.kind==="itx"?_o(n.transaction):void 0,o</span>=<span class="cstat-no" title="statement not covered" >await this.client._engine.request(n.protocolQuery,{traceparent:this.client._tracingHelper.getTraceParent(),interactiveTransaction:i,isWrite:un(n.protocolQuery.action),customDataProxyFetch:n.customDataProxyFetch});<span class="cstat-no" title="statement not covered" >r</span>eturn this.mapQueryEngineResult(n,o)}</span>,batchBy:<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >n</span>.transaction?.id?`transaction-${n.transaction.id}`:Io(n.protocolQuery),<span class="fstat-no" title="function not covered" >b</span>atchOrder(n</span>,i){<span class="cstat-no" title="statement not covered" >return n.transaction?.kind==="batch"&amp;&amp;i.transaction?.kind==="batch"?n.transaction.index-i.transaction.index:0}</span>})}<span class="fstat-no" title="function not covered" ></span>async r</span>equest(e){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return await this.dataloader.request(e)}</span>catch(r){let{clientMethod:n,callsite:i,transaction:o,args:s,modelName:a}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" >t</span>his.handleAndLogRequestError({error:r,clientMethod:n,callsite:i,transaction:o,args:s,modelName:a,globalOmit:e.globalOmit})}</span>}<span class="fstat-no" title="function not covered" ></span>mapQueryEngineResult({</span>dataPath:e,unpacker:r},n){let i=<span class="cstat-no" title="statement not covered" >n?.data,o</span>=<span class="cstat-no" title="statement not covered" >this.unpack(i,e,r);<span class="cstat-no" title="statement not covered" >r</span>eturn g.env.PRISMA_CLIENT_GET_TIME?{data:o}:o}<span class="fstat-no" title="function not covered" ></span>handleAndLogRequestError(e</span>){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.handleRequestError(e)}</span>catch(r){<span class="cstat-no" title="statement not covered" >throw this.logEmitter&amp;&amp;this.logEmitter.emit("error",{message:r.message,target:e.clientMethod,timestamp:new Date}),r}</span>}<span class="fstat-no" title="function not covered" ></span>handleRequestError({</span>error:e,clientMethod:r,callsite:n,transaction:i,args:o,modelName:s,globalOmit:a}){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(Il(e),_l(e,i))<span class="cstat-no" title="statement not covered" >throw e;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e instanceof X&amp;&amp;Ll(e)){let h=<span class="cstat-no" title="statement not covered" >Lo(e.meta);<span class="cstat-no" title="statement not covered" >z</span>t({args:o,errors:[h],callsite:n,errorFormat:this.client._errorFormat,originalMethod:r,clientVersion:this.client._clientVersion,globalOmit:a})}</span>l</span>et f=<span class="cstat-no" title="statement not covered" >e.message;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;(f=Bt({callsite:n,originalMethod:r,isPanic:e.isPanic,showColors:this.client._errorFormat==="pretty",message:f})),f=this.sanitizeMessage(f),e.code){let h=<span class="cstat-no" title="statement not covered" >s?{modelName:s,...e.meta}:e.meta;<span class="cstat-no" title="statement not covered" ></span>throw new X(f,{code:e.code,clientVersion:this.client._clientVersion,meta:h,batchRequestIdx:e.batchRequestIdx})}</span>else{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.isPanic)<span class="cstat-no" title="statement not covered" >throw new we(f,this.client._clientVersion);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e instanceof j)<span class="cstat-no" title="statement not covered" >throw new j(f,{clientVersion:this.client._clientVersion,batchRequestIdx:e.batchRequestIdx});<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e instanceof I)<span class="cstat-no" title="statement not covered" >throw new I(f,this.client._clientVersion);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(e instanceof we)<span class="cstat-no" title="statement not covered" >throw new we(f,this.client._clientVersion)}<span class="cstat-no" title="statement not covered" ></span></span>t</span>hrow e.clientVersion=this.client._clientVersion,e}<span class="fstat-no" title="function not covered" ></span>sanitizeMessage(e</span>){<span class="cstat-no" title="statement not covered" >return this.client._errorFormat&amp;&amp;this.client._errorFormat!=="pretty"?(0,Do.default)(e):e}<span class="fstat-no" title="function not covered" ></span>unpack(e</span>,r,n){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e||(e.data&amp;&amp;(e=e.data),!e))<span class="cstat-no" title="statement not covered" >return e;l</span></span>et i=<span class="cstat-no" title="statement not covered" >Object.keys(e)[0],</span>o=<span class="cstat-no" title="statement not covered" >Object.values(e)[0],</span>s=<span class="cstat-no" title="statement not covered" >r.filter(<span class="fstat-no" title="function not covered" >h=&gt;<span class="cstat-no" title="statement not covered" >h</span>!=="select"&amp;&amp;h!=="include"),a</span></span>=<span class="cstat-no" title="statement not covered" >Kr(o,s),f</span>=<span class="cstat-no" title="statement not covered" >i==="queryRaw"?hr(a):$e(a);<span class="cstat-no" title="statement not covered" >r</span>eturn n?n(f):f}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"RequestHandler"}</span>};f</span>unction <span class="fstat-no" title="function not covered" >Dl(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.kind==="batch")<span class="cstat-no" title="statement not covered" >return{kind:"batch",options:{isolationLevel:t.isolationLevel}};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t.kind==="itx")<span class="cstat-no" title="statement not covered" >return{kind:"itx",options:_o(t)};<span class="cstat-no" title="statement not covered" >b</span></span>e(t,"Unknown transaction kind")}</span>}</span>function <span class="fstat-no" title="function not covered" >_o(t</span>){<span class="cstat-no" title="statement not covered" >return{id:t.id,payload:t.payload}}</span>function <span class="fstat-no" title="function not covered" >_l(t</span>,e){<span class="cstat-no" title="statement not covered" >return gr(t)&amp;&amp;e?.kind==="batch"&amp;&amp;t.batchRequestIdx!==e.index}f</span>unction <span class="fstat-no" title="function not covered" >Ll(t</span>){<span class="cstat-no" title="statement not covered" >return t.code==="P2009"||t.code==="P2012"}</span>function <span class="fstat-no" title="function not covered" >Lo(t</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.kind==="Union")<span class="cstat-no" title="statement not covered" >return{kind:"Union",errors:t.errors.map(Lo)};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Array.isArray(t.selectionPath)){let[,...e]=<span class="cstat-no" title="statement not covered" >t.selectionPath;<span class="cstat-no" title="statement not covered" ></span>return{...t,selectionPath:e}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Fo=<span class="cstat-no" title="statement not covered" >go;<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar $o=<span class="cstat-no" title="statement not covered" >nt(Fr());<span class="cstat-no" title="statement not covered" >u</span>();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar D=<span class="cstat-no" title="statement not covered" >class extends Error{<span class="fstat-no" title="function not covered" >constructor(e</span>){<span class="cstat-no" title="statement not covered" >super(e+`</span></span>
Read more at https://pris.ly/d/client-constructor`),this.name="PrismaClientConstructorValidationError"}<span class="fstat-no" title="function not covered" >get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClientConstructorValidationError"}</span>};<span class="cstat-no" title="statement not covered" >te(D,"PrismaClientConstructorValidationError");v</span>ar No=<span class="cstat-no" title="statement not covered" >["datasources","datasourceUrl","errorFormat","adapter","log","transactionOptions","omit","__internal"],q</span>o=<span class="cstat-no" title="statement not covered" >["pretty","colorless","minimal"],U</span>o=<span class="cstat-no" title="statement not covered" >["info","query","warn","error"],F</span>l=<span class="cstat-no" title="statement not covered" >{datasources:<span class="fstat-no" title="function not covered" >(t</span>,{datasourceNames:e})=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="object"||Array.isArray(t))<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(t)} for "datasources" provided to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[r,n]of Object.entries(t)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e.includes(r)){let i=<span class="cstat-no" title="statement not covered" >tt(r,e)||` Available datasources: ${e.join(", ")}`;<span class="cstat-no" title="statement not covered" ></span>throw new D(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(typeof n!="object"||Array.isArray(n))<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(t)} for datasource "${r}" provided to PrismaClient constructor.</span></span></span></span></span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n&amp;&amp;typeof n=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(n)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(i!=="url")<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(t)} for datasource "${r}" provided to PrismaClient constructor.</span></span></span></span>
It should have this form: { url: "CONNECTION_STRING" }`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof o!="string")<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.</span></span>
It should have this form: { url: "CONNECTION_STRING" }`)}}}},adapter:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!t&amp;&amp;Ue(e.generator)==="client")<span class="cstat-no" title="statement not covered" >throw new D('Using engine type "client" requires a driver adapter to be provided to PrismaClient constructor.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t===null)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t===void 0)<span class="cstat-no" title="statement not covered" >throw new D('"adapter" property must not be undefined, use null to conditionally disable driver adapters.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!dr(e).includes("driverAdapters"))<span class="cstat-no" title="statement not covered" >throw new D('"adapter" property can only be provided to PrismaClient constructor when "driverAdapters" preview feature is enabled.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(Ue(e.generator)==="binary")<span class="cstat-no" title="statement not covered" >throw new D('Cannot use a driver adapter with the "binary" Query Engine. Please use the "library" Query Engine.')}</span></span>,datasourceUrl:<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(typeof t&lt;"u"&amp;&amp;typeof t!="string")<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(t)} for "datasourceUrl" provided to PrismaClient constructor.</span></span>
Expected string or undefined.`)},errorFormat:<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(t){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="string")<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(t)} for "errorFormat" provided to PrismaClient constructor.`);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!qo.includes(t)){let e=<span class="cstat-no" title="statement not covered" >tt(t,qo);<span class="cstat-no" title="statement not covered" >t</span>hrow new D(`Invalid errorFormat ${t} provided to PrismaClient constructor.${e}`)}</span>}</span>}</span>,log:<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!t)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!Array.isArray(t))<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(t)} for "log" provided to PrismaClient constructor.`);f</span></span>unction <span class="fstat-no" title="function not covered" >e(r</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof r=="string"&amp;&amp;!Uo.includes(r)){let n=<span class="cstat-no" title="statement not covered" >tt(r,Uo);<span class="cstat-no" title="statement not covered" >t</span>hrow new D(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`)}</span>}<span class="cstat-no" title="statement not covered" ></span>for(let r of t){<span class="cstat-no" title="statement not covered" >e(r);l</span>et n=<span class="cstat-no" title="statement not covered" >{level:e,emit:<span class="fstat-no" title="function not covered" >i=&gt;{l</span>et o=<span class="cstat-no" title="statement not covered" >["stdout","event"];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o.includes(i)){let s=<span class="cstat-no" title="statement not covered" >tt(i,o);<span class="cstat-no" title="statement not covered" >t</span>hrow new D(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`)}</span>}</span>};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(r&amp;&amp;typeof r=="object")<span class="cstat-no" title="statement not covered" >for(let[i,o]of Object.entries(r))<span class="cstat-no" title="statement not covered" >if(n[i])<span class="cstat-no" title="statement not covered" >n[i](o);else <span class="cstat-no" title="statement not covered" >t</span>hrow new D(`Invalid property ${i} for "log" provided to PrismaClient constructor`)}</span></span></span></span>}</span>,transactionOptions:<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >t.maxWait;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(e!=null&amp;&amp;e&lt;=0)<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${e} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);l</span></span>et r=<span class="cstat-no" title="statement not covered" >t.timeout;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(r!=null&amp;&amp;r&lt;=0)<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${r} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`)}</span></span>,omit:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(typeof t!="object")<span class="cstat-no" title="statement not covered" >throw new D('"omit" option is expected to be an object.');<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(t===null)<span class="cstat-no" title="statement not covered" >throw new D('"omit" option can not be `null`');l</span></span>et r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let[n,i]of Object.entries(t)){let o=<span class="cstat-no" title="statement not covered" >ql(n,e.runtimeDataModel);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!o){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownModel",modelKey:n});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let[s,a]of Object.entries(i)){let f=<span class="cstat-no" title="statement not covered" >o.fields.find(<span class="fstat-no" title="function not covered" >h=&gt;<span class="cstat-no" title="statement not covered" >h</span>.name===s);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!f){<span class="cstat-no" title="statement not covered" >r.push({kind:"UnknownField",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(f.relationName){<span class="cstat-no" title="statement not covered" >r.push({kind:"RelationInOmit",modelKey:n,fieldName:s});<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>t</span>ypeof a!="boolean"&amp;&amp;r.push({kind:"InvalidFieldValue",modelKey:n,fieldName:s})}</span>}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(r.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new D(Ul(t,r))}</span></span>,__internal:<span class="fstat-no" title="function not covered" >t=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >["debug","engine","configOverride"];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(typeof t!="object")<span class="cstat-no" title="statement not covered" >throw new D(`Invalid value ${JSON.stringify(t)} for "__internal" to PrismaClient constructor`);<span class="cstat-no" title="statement not covered" >f</span></span>or(let[r]of Object.entries(t))<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!e.includes(r)){let n=<span class="cstat-no" title="statement not covered" >tt(r,e);<span class="cstat-no" title="statement not covered" >t</span>hrow new D(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`)}</span>}</span></span>};function <span class="fstat-no" title="function not covered" >Vo(t</span>,e){<span class="cstat-no" title="statement not covered" >for(let[r,n]of Object.entries(t)){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(!No.includes(r)){let i=<span class="cstat-no" title="statement not covered" >tt(r,No);<span class="cstat-no" title="statement not covered" >t</span>hrow new D(`Unknown property ${r} provided to PrismaClient constructor.${i}`)}<span class="cstat-no" title="statement not covered" ></span>F</span>l[r](n,e)}<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>i</span>f(t.datasourceUrl&amp;&amp;t.datasources)<span class="cstat-no" title="statement not covered" >throw new D('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them')}</span></span>function <span class="fstat-no" title="function not covered" >tt(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===0||typeof t!="string")<span class="cstat-no" title="statement not covered" >return"";l</span></span>et r=<span class="cstat-no" title="statement not covered" >Nl(t,e);<span class="cstat-no" title="statement not covered" >r</span>eturn r?` Did you mean "${r}"?`:""}</span>function <span class="fstat-no" title="function not covered" >Nl(t</span>,e){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(e.length===0)<span class="cstat-no" title="statement not covered" >return null;l</span></span>et r=<span class="cstat-no" title="statement not covered" >e.map(<span class="fstat-no" title="function not covered" >i=&gt;(<span class="cstat-no" title="statement not covered" >{</span>value:i,distance:(0,$o.default)(t,i)}));<span class="cstat-no" title="statement not covered" >r</span></span>.sort(<span class="fstat-no" title="function not covered" >(i</span>,o)=&gt;<span class="cstat-no" title="statement not covered" >i.distance&lt;o.distance?-1:1);l</span></span>et n=<span class="cstat-no" title="statement not covered" >r[0];<span class="cstat-no" title="statement not covered" ></span>return n.distance&lt;3?n.value:null}</span>function <span class="fstat-no" title="function not covered" >ql(t</span>,e){<span class="cstat-no" title="statement not covered" >return Bo(e.models,t)??Bo(e.types,t)}</span>function <span class="fstat-no" title="function not covered" >Bo(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >Object.keys(t).find(<span class="fstat-no" title="function not covered" >n=&gt;<span class="cstat-no" title="statement not covered" >v</span>e(n)===e);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(r)<span class="cstat-no" title="statement not covered" >return t[r]}f</span></span>unction <span class="fstat-no" title="function not covered" >Ul(t</span>,e){let r=<span class="cstat-no" title="statement not covered" >He(t);<span class="cstat-no" title="statement not covered" >f</span>or(let o of e)<span class="cstat-no" title="statement not covered" >switch(o.kind){case"UnknownModel":<span class="cstat-no" title="statement not covered" >r.arguments.getField(o.modelKey)?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Unknown model name: ${o.modelKey}.`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"UnknownField":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >`</span>Model "${o.modelKey}" does not have a field named "${o.fieldName}".`)</span>;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"RelationInOmit":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepField([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >'</span>Relations are already excluded by default and can not be specified in "omit".');<span class="cstat-no" title="statement not covered" >b</span></span>reak;c</span>ase"InvalidFieldValue":<span class="cstat-no" title="statement not covered" >r.arguments.getDeepFieldValue([o.modelKey,o.fieldName])?.markAsError(),r.addErrorMessage(<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >"</span>Omit field option value must be a boolean.");<span class="cstat-no" title="statement not covered" >b</span></span>reak}</span>l</span></span>et{message:n,args:i}=<span class="cstat-no" title="statement not covered" >Ht(r,"colorless");<span class="cstat-no" title="statement not covered" >r</span>eturn`Error validating "omit" option:</span>
&nbsp;
${i}
&nbsp;
${n}`}<span class="cstat-no" title="statement not covered" >u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();f</span>unction <span class="fstat-no" title="function not covered" >jo(t</span>){<span class="cstat-no" title="statement not covered" >return t.length===0?Promise.resolve([]):new Promise(<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{let n=<span class="cstat-no" title="statement not covered" >new Array(t.length),i</span>=<span class="cstat-no" title="statement not covered" >null,o</span>=<span class="cstat-no" title="statement not covered" >!1,s</span>=<span class="cstat-no" title="statement not covered" >0,a</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >o</span>||(s++,s===t.length&amp;&amp;(o=!0,i?r(i):e(n)))}</span>,f</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >h=&gt;{<span class="cstat-no" title="statement not covered" >o</span>||(o=!0,r(h))}</span>;<span class="cstat-no" title="statement not covered" >f</span>or(let h=<span class="cstat-no" title="statement not covered" >0;h</span>&lt;t.length;h++)<span class="cstat-no" title="statement not covered" >t[h].then(<span class="fstat-no" title="function not covered" >T=&gt;{<span class="cstat-no" title="statement not covered" >n</span>[h]=T,a()}</span>,<span class="fstat-no" title="function not covered" >T=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!gr(T)){<span class="cstat-no" title="statement not covered" >f(T);<span class="cstat-no" title="statement not covered" >r</span>eturn}<span class="cstat-no" title="statement not covered" ></span>T</span>.batchRequestIdx===h?f(T):(i||(i=T),a())}</span>)}</span></span>)}</span>var Ae=<span class="cstat-no" title="statement not covered" >J("prisma:client");<span class="cstat-no" title="statement not covered" >t</span>ypeof globalThis=="object"&amp;&amp;(globalThis.NODE_CLIENT=!0);v</span>ar Bl=<span class="cstat-no" title="statement not covered" >{requestArgsToMiddlewareArgs:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>,m</span>iddlewareArgsToRequestArgs:<span class="fstat-no" title="function not covered" >t=&gt;<span class="cstat-no" title="statement not covered" >t</span>}</span>,$</span>l=<span class="cstat-no" title="statement not covered" >Symbol.for("prisma.client.transaction.id"),V</span>l=<span class="cstat-no" title="statement not covered" >{id:0,<span class="fstat-no" title="function not covered" >nextId(){<span class="cstat-no" title="statement not covered" >r</span>eturn++this.id}}</span>;f</span>unction <span class="fstat-no" title="function not covered" >Go(t</span>){class e{<span class="cstat-no" title="statement not covered" >_originalClient=this;_runtimeDataModel;_requestHandler;_connectionPromise;_disconnectionPromise;_engineConfig;_accelerateEngineConfig;_clientVersion;_errorFormat;_tracingHelper;<span class="cstat-no" title="statement not covered" >_</span>middlewares=new fr;_previewFeatures;_activeProvider;_globalOmit;_extensions;_engine;_appliedParent;<span class="cstat-no" title="statement not covered" >_</span>createPrismaPromise=sn();<span class="fstat-no" title="function not covered" >c</span>onstructor(n</span>){<span class="cstat-no" title="statement not covered" >t=n?.__internal?.configOverride?.(t)??t,mo(t),n&amp;&amp;Vo(n,t);l</span>et i=<span class="cstat-no" title="statement not covered" >new nr().on("error",<span class="fstat-no" title="function not covered" >()=&gt;{}</span>);<span class="cstat-no" title="statement not covered" >t</span>his._extensions=ze.empty(),this._previewFeatures=dr(t),this._clientVersion=t.clientVersion??Fo,this._activeProvider=t.activeProvider,this._globalOmit=n?.omit,this._tracingHelper=ko();l</span>et o=<span class="cstat-no" title="statement not covered" >t.relativeEnvPaths&amp;&amp;{rootEnvPath:t.relativeEnvPaths.rootEnvPath&amp;&amp;Nt.resolve(t.dirname,t.relativeEnvPaths.rootEnvPath),schemaEnvPath:t.relativeEnvPaths.schemaEnvPath&amp;&amp;Nt.resolve(t.dirname,t.relativeEnvPaths.schemaEnvPath)},s</span>;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(n?.adapter){<span class="cstat-no" title="statement not covered" >s=n.adapter;l</span>et f=<span class="cstat-no" title="statement not covered" >t.activeProvider==="postgresql"?"postgres":t.activeProvider;<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span></span>if(s.provider!==f)<span class="cstat-no" title="statement not covered" >throw new I(`The Driver Adapter \`${s.adapterName}\`, based on \`${s.provider}\`, is not compatible with the provider \`${f}\` specified in the Prisma schema.`,this._clientVersion);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(n.datasources||n.datasourceUrl!==void 0)<span class="cstat-no" title="statement not covered" >throw new I("Custom datasource configuration is not compatible with Prisma Driver Adapters. Please define the database connection string directly in the Driver Adapter configuration.",this._clientVersion)}</span></span>l</span>et a=<span class="cstat-no" title="statement not covered" >t.injectableEdgeEnv?.();<span class="cstat-no" title="statement not covered" >t</span>ry{let f=<span class="cstat-no" title="statement not covered" >n??{},h</span>=<span class="cstat-no" title="statement not covered" >f.__internal??{},T</span>=<span class="cstat-no" title="statement not covered" >h.debug===!0;<span class="cstat-no" title="statement not covered" >T</span>&amp;&amp;J.enable("prisma:client");l</span>et C=<span class="cstat-no" title="statement not covered" >Nt.resolve(t.dirname,t.relativePath);<span class="cstat-no" title="statement not covered" >q</span>n.existsSync(C)||(C=t.dirname),Ae("dirname",t.dirname),Ae("relativePath",t.relativePath),Ae("cwd",C);l</span>et k=<span class="cstat-no" title="statement not covered" >h.engine||{};<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(f.errorFormat?this._errorFormat=f.errorFormat:g.env.NODE_ENV==="production"?this._errorFormat="minimal":g.env.NO_COLOR?this._errorFormat="colorless":this._errorFormat="colorless",this._runtimeDataModel=t.runtimeDataModel,this._engineConfig={cwd:C,dirname:t.dirname,enableDebugLogs:T,allowTriggerPanic:k.allowTriggerPanic,prismaPath:k.binaryPath??void 0,engineEndpoint:k.endpoint,generator:t.generator,showColors:this._errorFormat==="pretty",logLevel:f.log&amp;&amp;Mo(f.log),logQueries:f.log&amp;&amp;!!(typeof f.log=="string"?f.log==="query":f.log.find(<span class="fstat-no" title="function not covered" >A=&gt;<span class="cstat-no" title="statement not covered" >t</span>ypeof A=="string"?A==="query":A.level==="query")</span>),env:a?.parsed??{},flags:[],engineWasm:t.engineWasm,compilerWasm:t.compilerWasm,clientVersion:t.clientVersion,engineVersion:t.engineVersion,previewFeatures:this._previewFeatures,activeProvider:t.activeProvider,inlineSchema:t.inlineSchema,overrideDatasources:po(f,t.datasourceNames),inlineDatasources:t.inlineDatasources,inlineSchemaHash:t.inlineSchemaHash,tracingHelper:this._tracingHelper,transactionOptions:{maxWait:f.transactionOptions?.maxWait??2e3,timeout:f.transactionOptions?.timeout??5e3,isolationLevel:f.transactionOptions?.isolationLevel},logEmitter:i,isBundled:t.isBundled,adapter:s},this._accelerateEngineConfig={...this._engineConfig,accelerateUtils:{resolveDatasourceUrl:mr,getBatchRequestPayload:sr,prismaGraphQLToJSError:ar,PrismaClientUnknownRequestError:j,PrismaClientInitializationError:I,PrismaClientKnownRequestError:X,debug:J("prisma:client:accelerateEngine"),engineVersion:Jo.version,clientVersion:t.clientVersion}},Ae("clientVersion",t.clientVersion),this._engine=bo(t,this._engineConfig),this._requestHandler=new br(this,i),f.log)<span class="cstat-no" title="statement not covered" >for(let A of f.log){let O=<span class="cstat-no" title="statement not covered" >typeof A=="string"?A:A.emit==="stdout"?A.level:null;<span class="cstat-no" title="statement not covered" >O</span>&amp;&amp;this.$on(O,<span class="fstat-no" title="function not covered" >S=&gt;{<span class="cstat-no" title="statement not covered" >a</span>t.log(`${at.tags[O]??""}`,S.message||S.query)}</span>)}</span>}</span></span>catch(f){<span class="cstat-no" title="statement not covered" >throw f.clientVersion=this._clientVersion,f}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._appliedParent=Tt(this)}<span class="fstat-no" title="function not covered" ></span>get[</span>Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"PrismaClient"}<span class="fstat-no" title="function not covered" ></span>$use(n</span>){<span class="cstat-no" title="statement not covered" >this._middlewares.use(n)}<span class="fstat-no" title="function not covered" ></span>$on(n</span>,i){<span class="cstat-no" title="statement not covered" >return n==="beforeExit"?this._engine.onBeforeExit(i):n&amp;&amp;this._engineConfig.logEmitter.on(n,i),this}<span class="fstat-no" title="function not covered" >$</span>connect(){<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >return this._engine.start()}</span>catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>}<span class="fstat-no" title="function not covered" ></span>async $</span>disconnect(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >await this._engine.stop()}</span>catch(n){<span class="cstat-no" title="statement not covered" >throw n.clientVersion=this._clientVersion,n}</span>finally{<span class="cstat-no" title="statement not covered" >Fn()}</span>}<span class="fstat-no" title="function not covered" ></span>$executeRawInternal(n</span>,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"executeRaw",args:o,transaction:n,clientMethod:i,argsMapper:on({clientMethod:i,activeProvider:a}),callsite:Ce(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$executeRaw(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n.raw!==void 0||n.sql!==void 0){let[s,a]=<span class="cstat-no" title="statement not covered" >Qo(n,i);<span class="cstat-no" title="statement not covered" >r</span>eturn nn(this._activeProvider,s.text,s.values,Array.isArray(n)?"prisma.$executeRaw`&lt;SQL&gt;`":"prisma.$executeRaw(sql`&lt;SQL&gt;`)"),this.$executeRawInternal(o,"$executeRaw",s,a)}<span class="cstat-no" title="statement not covered" ></span>t</span>hrow new W("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$executeRawUnsafe(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;(<span class="cstat-no" title="statement not covered" >n</span>n(this._activeProvider,n,i,"prisma.$executeRawUnsafe(&lt;SQL&gt;, [...values])"),this.$executeRawInternal(o,"$executeRawUnsafe",[n,...i])))}<span class="fstat-no" title="function not covered" ></span></span>$runCommandRaw(n</span>){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(t.activeProvider!=="mongodb")<span class="cstat-no" title="statement not covered" >throw new W(`The ${t.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`,{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._request({args:n,clientMethod:"$runCommandRaw",dataPath:[],action:"runCommandRaw",argsMapper:wo,callsite:Ce(this._errorFormat),transaction:i}))}<span class="fstat-no" title="function not covered" ></span></span>async $</span>queryRawInternal(n,i,o,s){let a=<span class="cstat-no" title="statement not covered" >this._activeProvider;<span class="cstat-no" title="statement not covered" ></span>return this._request({action:"queryRaw",args:o,transaction:n,clientMethod:i,argsMapper:on({clientMethod:i,activeProvider:a}),callsite:Ce(this._errorFormat),dataPath:[],middlewareArgsMapper:s})}<span class="fstat-no" title="function not covered" ></span>$queryRaw(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(n.raw!==void 0||n.sql!==void 0)<span class="cstat-no" title="statement not covered" >return this.$queryRawInternal(o,"$queryRaw",...Qo(n,i));<span class="cstat-no" title="statement not covered" >t</span></span>hrow new W("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n",{clientVersion:this._clientVersion})}</span>)}<span class="fstat-no" title="function not covered" ></span>$queryRawTyped(n</span>){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >i=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(!this._hasPreviewFlag("typedSql"))<span class="cstat-no" title="statement not covered" >throw new W("`typedSql` preview feature must be enabled in order to access $queryRawTyped API",{clientVersion:this._clientVersion});<span class="cstat-no" title="statement not covered" >r</span></span>eturn this.$queryRawInternal(i,"$queryRawTyped",n)}</span>)}<span class="fstat-no" title="function not covered" ></span>$queryRawUnsafe(n</span>,...i){<span class="cstat-no" title="statement not covered" >return this._createPrismaPromise(<span class="fstat-no" title="function not covered" >o=&gt;<span class="cstat-no" title="statement not covered" >t</span>his.$queryRawInternal(o,"$queryRawUnsafe",[n,...i]))}<span class="fstat-no" title="function not covered" ></span></span>_transactionWithArray({</span>promises:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >Vl.nextId(),s</span>=<span class="cstat-no" title="statement not covered" >Oo(n.length),a</span>=<span class="cstat-no" title="statement not covered" >n.map(<span class="fstat-no" title="function not covered" >(f</span>,h)=&gt;{<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(f?.[Symbol.toStringTag]!=="PrismaPromise")<span class="cstat-no" title="statement not covered" >throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");l</span></span>et T=<span class="cstat-no" title="statement not covered" >i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel,</span>C=<span class="cstat-no" title="statement not covered" >{kind:"batch",id:o,index:h,isolationLevel:T,lock:s};<span class="cstat-no" title="statement not covered" >r</span>eturn f.requestTransaction?.(C)??f}</span>);<span class="cstat-no" title="statement not covered" >r</span>eturn jo(a)}<span class="fstat-no" title="function not covered" ></span>async _</span>transactionWithCallback({callback:n,options:i}){let o=<span class="cstat-no" title="statement not covered" >{traceparent:this._tracingHelper.getTraceParent()},s</span>=<span class="cstat-no" title="statement not covered" >{maxWait:i?.maxWait??this._engineConfig.transactionOptions.maxWait,timeout:i?.timeout??this._engineConfig.transactionOptions.timeout,isolationLevel:i?.isolationLevel??this._engineConfig.transactionOptions.isolationLevel},a</span>=<span class="cstat-no" title="statement not covered" >await this._engine.transaction("start",o,s),f</span>;<span class="cstat-no" title="statement not covered" >try{let h=<span class="cstat-no" title="statement not covered" >{kind:"itx",...a};<span class="cstat-no" title="statement not covered" >f</span>=await n(this._createItxClient(h)),await this._engine.transaction("commit",o,a)}</span>catch(h){<span class="cstat-no" title="statement not covered" >throw await this._engine.transaction("rollback",o,a).catch(<span class="fstat-no" title="function not covered" >()=&gt;{}</span>),h}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn f}<span class="fstat-no" title="function not covered" ></span>_createItxClient(n</span>){<span class="cstat-no" title="statement not covered" >return le(Tt(le(zi(this),[K("_appliedParent",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._appliedParent._createItxClient(n)),K</span>("_createPrismaPromise",<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >s</span>n(n)),K</span>($l,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >n</span>.id)</span>])),[Xe(to)])}<span class="fstat-no" title="function not covered" ></span>$transaction(n</span>,i){let o;<span class="cstat-no" title="statement not covered" >typeof n=="function"?this._engineConfig.adapter?.adapterName==="@prisma/adapter-d1"?o=<span class="fstat-no" title="function not covered" >()=&gt;{<span class="cstat-no" title="statement not covered" >t</span>hrow new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.")}</span>:o=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._transactionWithCallback({callback:n,options:i}):o</span>=<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >t</span>his._transactionWithArray({promises:n,options:i});l</span></span>et s=<span class="cstat-no" title="statement not covered" >{name:"transaction",attributes:{method:"$transaction"}};<span class="cstat-no" title="statement not covered" >r</span>eturn this._tracingHelper.runInChildSpan(s,o)}<span class="fstat-no" title="function not covered" ></span>_request(n</span>){<span class="cstat-no" title="statement not covered" >n.otelParentCtx=this._tracingHelper.getActiveContext();l</span>et i=<span class="cstat-no" title="statement not covered" >n.middlewareArgsMapper??Bl,o</span>=<span class="cstat-no" title="statement not covered" >{args:i.requestArgsToMiddlewareArgs(n.args),dataPath:n.dataPath,runInTransaction:!!n.transaction,action:n.action,model:n.model},s</span>=<span class="cstat-no" title="statement not covered" >{middleware:{name:"middleware",middleware:!0,attributes:{method:"$use"},active:!1},operation:{name:"operation",attributes:{method:o.action,model:o.model,name:o.model?`${o.model}.${o.action}`:o.action}}},a</span>=<span class="cstat-no" title="statement not covered" >-1,f</span>=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >async h</span>=&gt;{let T=<span class="cstat-no" title="statement not covered" >this._middlewares.get(++a);<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span>f(T)<span class="cstat-no" title="statement not covered" >return this._tracingHelper.runInChildSpan(s.middleware,<span class="fstat-no" title="function not covered" >M=&gt;<span class="cstat-no" title="statement not covered" >T</span>(h,<span class="fstat-no" title="function not covered" >oe=&gt;(<span class="cstat-no" title="statement not covered" >M</span>?.end(),f(oe)</span>)));l</span></span></span>et{runInTransaction:C,args:k,...A}=<span class="cstat-no" title="statement not covered" >h,O</span>=<span class="cstat-no" title="statement not covered" >{...n,...A};<span class="cstat-no" title="statement not covered" >k</span>&amp;&amp;(O.args=i.middlewareArgsToRequestArgs(k)),n.transaction!==void 0&amp;&amp;C===!1&amp;&amp;delete O.transaction;l</span>et S=<span class="cstat-no" title="statement not covered" >await oo(this,O);<span class="cstat-no" title="statement not covered" >r</span>eturn O.model?eo({result:S,modelName:O.model,args:O.args,extensions:this._extensions,runtimeDataModel:this._runtimeDataModel,globalOmit:this._globalOmit}):S}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn this._tracingHelper.runInChildSpan(s.operation,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >f</span>(o))}<span class="fstat-no" title="function not covered" ></span></span>async _</span>executeRequest({args:n,clientMethod:i,dataPath:o,callsite:s,action:a,model:f,argsMapper:h,transaction:T,unpacker:C,otelParentCtx:k,customDataProxyFetch:A}){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >n=h?h(n):n;l</span>et O=<span class="cstat-no" title="statement not covered" >{name:"serialize"},S</span>=<span class="cstat-no" title="statement not covered" >this._tracingHelper.runInChildSpan(O,<span class="fstat-no" title="function not covered" >()=&gt;<span class="cstat-no" title="statement not covered" >e</span>r({modelName:f,runtimeDataModel:this._runtimeDataModel,action:a,args:n,clientMethod:i,callsite:s,extensions:this._extensions,errorFormat:this._errorFormat,clientVersion:this._clientVersion,previewFeatures:this._previewFeatures,globalOmit:this._globalOmit}));<span class="cstat-no" title="statement not covered" >r</span></span>eturn J.enabled("prisma:client")&amp;&amp;(Ae("Prisma Client call:"),Ae(`prisma.${i}(${Bi(n)})`),Ae("Generated request:"),Ae(JSON.stringify(S,null,2)+`</span></span>
`)),T?.kind==="batch"&amp;&amp;await T.lock,this._requestHandler.request({protocolQuery:S,modelName:f,action:a,clientMethod:i,dataPath:o,callsite:s,args:n,extensions:this._extensions,transaction:T,unpacker:C,otelParentCtx:k,otelChildCtx:this._tracingHelper.getActiveContext(),globalOmit:this._globalOmit,customDataProxyFetch:A})}catch(O){<span class="cstat-no" title="statement not covered" >throw O.clientVersion=this._clientVersion,O}</span>}<span class="cstat-no" title="statement not covered" >$metrics=new Ye(this);<span class="fstat-no" title="function not covered" >_</span>hasPreviewFlag(n</span>){<span class="cstat-no" title="statement not covered" >return!!this._engineConfig.previewFeatures?.includes(n)}<span class="fstat-no" title="function not covered" ></span>$applyPendingMigrations(){<span class="cstat-no" title="statement not covered" ></span>return this._engine.applyPendingMigrations()}<span class="cstat-no" title="statement not covered" ></span>$extends=Yi}<span class="cstat-no" title="statement not covered" ></span>return e}</span>function <span class="fstat-no" title="function not covered" >Qo(t</span>,e){<span class="cstat-no" title="statement not covered" >return jl(t)?[new Z(t,e),Ro]:[t,Ao]}f</span>unction <span class="fstat-no" title="function not covered" >jl(t</span>){<span class="cstat-no" title="statement not covered" >return Array.isArray(t)&amp;&amp;Array.isArray(t.raw)}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();v</span>ar Ql=<span class="cstat-no" title="statement not covered" >new Set(["toJSON","$$typeof","asymmetricMatch",Symbol.iterator,Symbol.toStringTag,Symbol.isConcatSpreadable,Symbol.toPrimitive]);f</span>unction <span class="fstat-no" title="function not covered" >Wo(t</span>){<span class="cstat-no" title="statement not covered" >return new Proxy(t,{<span class="fstat-no" title="function not covered" >get(e</span>,r){<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>if(r in e)<span class="cstat-no" title="statement not covered" >return e[r];<span class="cstat-no" title="statement not covered" ><span class="missing-if-branch" title="if path not taken" >I</span>i</span></span>f(!Ql.has(r))<span class="cstat-no" title="statement not covered" >throw new TypeError(`Invalid enum value: ${String(r)}`)}</span></span>})}<span class="cstat-no" title="statement not covered" ></span>u();<span class="cstat-no" title="statement not covered" >c</span>();<span class="cstat-no" title="statement not covered" >m</span>();<span class="cstat-no" title="statement not covered" >p</span>();<span class="cstat-no" title="statement not covered" >d</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >l</span>();<span class="cstat-no" title="statement not covered" >0</span>&amp;&amp;(module.exports={DMMF,Debug,Decimal,Extensions,MetricsClient,PrismaClientInitializationError,PrismaClientKnownRequestError,PrismaClientRustPanicError,PrismaClientUnknownRequestError,PrismaClientValidationError,Public,Sql,createParam,defineDmmfProperty,deserializeJsonResponse,deserializeRawResult,dmmfToRuntimeDataModel,empty,getPrismaClient,getRuntime,join,makeStrictEnum,makeTypedQueryFactory,objectEnumValues,raw,serializeJsonQuery,skip,sqltag,warnEnvConflicts,warnOnce});</span>
//# sourceMappingURL=wasm.js.map
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-05-21T22:28:03.832Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    